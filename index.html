<!DOCTYPE html>
<html lang="en">

<head>
    <title>C64 Programmer's Reference Guide</title>
    <link href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Mono" rel="stylesheet">
    <link href="style.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="utf-8">
</head>

<body>

    <div class="container">
        <div class="top" id="top">
            <h2 id="title">**** Commodore 64 Basic V2 ****</h2>
            <h2 id="subtitle"> 64K Ram System 38911 Basic Bytes Free </h2>
        </div>
        <div class="doc">
            <div class="sidebar">
                <nav id="navbar">
                    <header>
                        <h3>C64 Programmer's Reference Guide</h3>
                    </header>
                    <ul>
                        <li>
                            <h4>Introduction</h4>
                        </li>
                        <li>
                            <a class="nav-link" href="#How_to_Use_This_Reference_Guide">How to Use This Reference
                                Guide</a>
                        </li>
                    </ul>

                    <hr>

                    <ul>
                        <li>
                            <h4>BASIC Programming Rules</h4>
                        </li>
                        <li>
                            <a class="nav-link" href="#Screen_Display_Codes">Screen Display Codes</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Programming_Numbers_and_Variables">Programming Numbers and
                                Variables</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Expressions_and_Operators">Expressions and Operators</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Programming_Techniques">Programming Techniques</a>
                        </li>
                    </ul>

                    <hr>

                    <ul>
                        <li>
                            <h4>BASIC Language Vocabulary</h4>
                        </li>
                        <li>
                            <a class="nav-link" href="#BASIC_Language_Introduction">BASIC Language Introduction</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#BASIC_Keywords_Abbreviations_and_Function_Types">BASIC Keywords,
                                Abbreviations, and Function Types</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Description_of_BASIC_Keywords">Description of BASIC Keywords</a>
                        </li>
                        <li>
                            <table class="subnav">
                                <tr>
                                    <td>
                                        <a class="nav-link" href="#ABS">ABS</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#AND">AND</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#ASC">ASC</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#ATN">ATN</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#CHR$">CHR$</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#CLOSE">CLOSE</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#CLR">CLR</a>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <a class="nav-link" href="#CMD">CMD</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#COS">COS</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#DATA">DATA</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#DEF">DEF</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#END">END</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#EXP">EXP</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#FN">FN</a>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <a class="nav-link" href="#FOR">FOR</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#FOR">FOR</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#FRE">FRE</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#GET">GET</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#GET_Hash">GET#</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#GOSUB">GOSUB</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#GOTO">GOTO</a>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <a class="nav-link" href="#IF">IF</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#INPUT">INPUT</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#INPUT_Hash">INPUT#</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#INT">INT</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#LEFT$">LEFT$</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#LEN">LEN</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#LET">LET</a>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <a class="nav-link" href="#LIST">LIST</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#LOAD">LOAD</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#LOG">LOG</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#MID$">MID$</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#NEW">NEW</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#NEXT">NEXT</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#NOT">NOT</a>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <a class="nav-link" href="#ON">ON</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#OPEN">OPEN</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#OR">OR</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#PEEK">PEEK</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#POKE">POKE</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#POS">POS</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#PRINT">PRINT</a>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <a class="nav-link" href="#PRINT_Hash">PRINT#</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#READ">READ</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#REM">REM</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#RESTORE">RESTORE</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#RETURN">RETURN</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#RIGHT$">RIGHT$</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#RND">RND</a>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <a class="nav-link" href="#RUN">RUN</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#SAVE">SAVE</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#SGN">SGN</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#SIN">SIN</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#SPC">SPC</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#SQR">SQR</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#STATUS">STATUS</a>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <a class="nav-link" href="#STEP">STEP</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#STOP">STOP</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#STR$">STR$</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#SYS">SYS</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#TAB(">TAB(</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#TAN">TAN</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#THEN">THEN</a>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <a class="nav-link" href="#TIME">TIME</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#TIME$">TIME$</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#TO">TO</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#USR">USR</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#VAL">VAL</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#VERIFY">VERIFY</a>
                                    </td>
                                    <td>
                                        <a class="nav-link" href="#WAIT">WAIT</a>
                                    </td>
                                </tr>
                            </table>
                        </li>
                        <li>
                            <a class="nav-link" href="#Keyboard_and_Features">Keyboard and Features</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Screen_Editor">Screen Editor</a>
                        </li>
                    </ul>

                    <hr>

                    <ul>
                        <li>
                            <h4>Programming Graphics</h4>
                        </li>
                        <li>
                            <a class="nav-link" href="#Graphics_Overview">Graphics Overview</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Graphics_Locations">Graphics Locations</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Standard_Character_Mode">Standard Character Mode</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Programmable_Characters">Programmable Characters</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Multi-Color_Mode_Graphics">Multi-Color Mode Graphics</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Extended_Background_Color_Mode">Extended Background Color
                                Mode</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Bitmapped_Graphics">Bitmapped Graphics</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Multi-Color_Bitmap_Mode">Multi-Color Bitmap Mode</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Smooth_Scrolling">Smooth Scrolling</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Sprites">Sprites</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Other_Graphics_Features">Other Graphics Features</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Programming_Sprites_Another_Look">Programming Sprites: Another
                                Look</a>
                        </li>
                    </ul>

                    <hr>

                    <ul>
                        <li>
                            <h4>Sound and Music</h4>
                        </li>
                        <li>
                            <a class="nav-link" href="#Sound_Introduction">Sound Introduction</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Using_Multiple_Voices">Using Multiple Voices</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Changing_Waveforms">Changing Waveforms</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Envelope_Generator">Envelope Generator</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Filtering">Filtering</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Advanced_Techniques">Advanced Techniques</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Synchronization_and_Ring_Modulation">Synchronization and Ring
                                Modulation</a>
                        </li>
                    </ul>

                    <hr>

                    <ul>
                        <li>
                            <h4>BASIC to Machine Language</h4>
                        </li>
                        <li>
                            <a class="nav-link" href="#Machine_Language">What is Machine Language?</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Programming_in_Machine_Language">How Do You Write Programs in
                                Machine Language?</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Hexadecimal_Notation">Hexadecimal Notation</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Addressing_Modes">Addressing Modes</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Indexing">Indexing</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Subroutines">Subroutines</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Tips_for_the_Beginner">Useful Tips for the Beginner</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Approaching_a_Large_Task">Approaching a Large Task</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#MCS6510_Instruction_Set">MCS6510 Instruction Set</a>
                        </li>
                        <li>
                            <table class="subnav">
                                <tr>
                                    <td><a class="nav-link" href="#ADC">ADC</a></td>
                                    <td><a class="nav-link" href="#ML_AND">AND</a></td>
                                    <td><a class="nav-link" href="#ASL">ASL</a></td>
                                    <td><a class="nav-link" href="#BCC">BCC</a></td>
                                    <td><a class="nav-link" href="#BCS">BCS</a></td>
                                    <td><a class="nav-link" href="#BEQ">BEQ</a></td>
                                    <td><a class="nav-link" href="#BIT">BIT</a></td>
                                    <td><a class="nav-link" href="#BMI">BMI</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#BNE">BNE</a></td>
                                    <td><a class="nav-link" href="#BPL">BPL</a></td>
                                    <td><a class="nav-link" href="#BRK">BRK</a></td>
                                    <td><a class="nav-link" href="#BVC">BVC</a></td>
                                    <td><a class="nav-link" href="#BVS">BVS</a></td>
                                    <td><a class="nav-link" href="#CLC">CLC</a></td>
                                    <td><a class="nav-link" href="#CLD">CLD</a></td>
                                    <td><a class="nav-link" href="#CLI">CLI</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#CLV">CLV</a></td>
                                    <td><a class="nav-link" href="#CMP">CMP</a></td>
                                    <td><a class="nav-link" href="#CPX">CPX</a></td>
                                    <td><a class="nav-link" href="#CPY">CPY</a></td>
                                    <td><a class="nav-link" href="#DEC">DEC</a></td>
                                    <td><a class="nav-link" href="#DEX">DEX</a></td>
                                    <td><a class="nav-link" href="#DEY">DEY</a></td>
                                    <td><a class="nav-link" href="#EOR">EOR</a></td>

                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#INC">INC</a></td>
                                    <td><a class="nav-link" href="#INX">INX</a></td>
                                    <td><a class="nav-link" href="#INY">INY</a></td>
                                    <td><a class="nav-link" href="#JMP">JMP</a></td>
                                    <td><a class="nav-link" href="#JSR">JSR</a></td>
                                    <td><a class="nav-link" href="#LDA">LDA</a></td>
                                    <td><a class="nav-link" href="#LDX">LDX</a></td>
                                    <td><a class="nav-link" href="#LDY">LDY</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#LSR">LSR</a></td>
                                    <td><a class="nav-link" href="#NOP">NOP</a></td>
                                    <td><a class="nav-link" href="#ORA">ORA</a></td>
                                    <td><a class="nav-link" href="#PHA">PHA</a></td>
                                    <td><a class="nav-link" href="#PHP">PHP</a></td>
                                    <td><a class="nav-link" href="#PLA">PLA</a></td>
                                    <td><a class="nav-link" href="#PLP">PLP</a></td>
                                    <td><a class="nav-link" href="#ROL">ROL</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#ROR">ROR</a></td>
                                    <td><a class="nav-link" href="#RTI">RTI</a></td>
                                    <td><a class="nav-link" href="#RTS">RTS</a></td>
                                    <td><a class="nav-link" href="#SBC">SBC</a></td>
                                    <td><a class="nav-link" href="#SEC">SEC</a></td>
                                    <td><a class="nav-link" href="#SED">SED</a></td>
                                    <td><a class="nav-link" href="#SEI">SEI</a></td>
                                    <td><a class="nav-link" href="#STA">STA</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#STX">STX</a></td>
                                    <td><a class="nav-link" href="#STY">STY</a></td>
                                    <td><a class="nav-link" href="#TAX">TAX</a></td>
                                    <td><a class="nav-link" href="#TAY">TAY</a></td>
                                    <td><a class="nav-link" href="#TSX">TSX</a></td>
                                    <td><a class="nav-link" href="#TXA">TXA</a></td>
                                    <td><a class="nav-link" href="#TXS">TXS</a></td>
                                    <td><a class="nav-link" href="#TYA">TYA</a></td>
                                </tr>
                            </table>
                        </li>
                        <li>
                            <a class="nav-link" href="#Instruction_Addressing_Modes">Instruction Addressing Modes</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Memory_Management">Memory Management</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#The_KERNAL">The KERNAL</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#KERNAL_Power-up_Activities">KERNAL Power-up Activities</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#KERNAL_Routines">User Callable KERNAL Routines</a>
                        </li>
                        <li>
                            <table class="subnav">
                                <tr>
                                    <td><a class="nav-link" href="#ACPTR">ACPTR</a></td>
                                    <td><a class="nav-link" href="#CHKIN">CHKIN</a></td>
                                    <td><a class="nav-link" href="#CHKOUT">CHKOUT</a></td>
                                    <td><a class="nav-link" href="#CHRIN">CHRIN</a></td>
                                    <td><a class="nav-link" href="#CHROUT">CHROUT</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#CIOUT">CIOUT</a></td>
                                    <td><a class="nav-link" href="#CINT">CINT</a></td>
                                    <td><a class="nav-link" href="#CLALL">CLALL</a></td>
                                    <td><a class="nav-link" href="#CLOSE">CLOSE</a></td>
                                    <td><a class="nav-link" href="#CLRCHN">CLRCHN</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#GETIN">GETIN</a></td>
                                    <td><a class="nav-link" href="#IOBASE">IOBASE</a></td>
                                    <td><a class="nav-link" href="#IOINIT">IOINIT</a></td>
                                    <td><a class="nav-link" href="#LISTEN">LISTEN</a></td>
                                    <td><a class="nav-link" href="#LOAD">LOAD</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#MEMBOT">MEMBOT</a></td>
                                    <td><a class="nav-link" href="#MEMTOP">MEMTOP</a></td>
                                    <td><a class="nav-link" href="#OPEN">OPEN</a></td>
                                    <td><a class="nav-link" href="#PLOT">PLOT</a></td>
                                    <td><a class="nav-link" href="#RAMTAS">RAMTAS</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#RDTIM">RDTIM</a></td>
                                    <td><a class="nav-link" href="#READST">READST</a></td>
                                    <td><a class="nav-link" href="#RESTOR">RESTOR</a></td>
                                    <td><a class="nav-link" href="#SAVE">SAVE</a></td>
                                    <td><a class="nav-link" href="#SCNKEY">SCNKEY</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#SCREEN">SCREEN</a></td>
                                    <td><a class="nav-link" href="#SECOND">SECOND</a></td>
                                    <td><a class="nav-link" href="#SETLFS">SETLFS</a></td>
                                    <td><a class="nav-link" href="#SETMSG">SETMSG</a></td>
                                    <td><a class="nav-link" href="#SETNAM">SETNAM</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#SETTIM">SETTIM</a></td>
                                    <td><a class="nav-link" href="#SETTMO">SETTMO</a></td>
                                    <td><a class="nav-link" href="#STOP">STOP</a></td>
                                    <td><a class="nav-link" href="#TALK">TALK</a></td>
                                    <td><a class="nav-link" href="#TKSA">TKSA</a></td>
                                </tr>
                                <tr>
                                    <td><a class="nav-link" href="#UDTIM">UDTIM</a></td>
                                    <td><a class="nav-link" href="#UNLSN">UNLSN</a></td>
                                    <td><a class="nav-link" href="#UNTLK">UNTLK</a></td>
                                    <td><a class="nav-link" href="#VECTOR">VECTOR</a></td>
                                    <td></td>
                                </tr>
                            </table>
                        </li>
                        <li>
                            <a class="nav-link" href="#Using_Machine_Language_from_BASIC">Using Machine Language from
                                BASIC</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Memory_Map">Memory Map</a>
                        </li>
                    </ul>

                    <hr>

                    <ul>
                        <li>
                            <h4>I/O Guide</h4>
                        </li>
                        <li>
                            <a class="nav-link" href="#I/O_Introduction">Introduction</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Output_to_the_TV">Output to the TV</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Output_to_Other_Devices">Output to Other Devices</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Game_Ports">Game Ports</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#RS-232_Interface">RS-232 Interface</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#User_Ports">User Port</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Serial_Bus">Serial Bus</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Expansion_Port">Expansion Port</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#Z-80_Microprocessor_Cartridge">Z-80 Microprocessor Cartridge</a>
                        </li>
                    </ul>

                    <hr>

                    <ul>
                        <li>
                            <h4>Appendices</h4>
                        </li>
                        <li>
                            <a class="nav-link" href="#A_Abbreviations_for_Basic">A) Abbreviations for BASIC
                                Keywords</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#B_Screen_Display_Codes">B) Screen Display Codes</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#C_ASCII_and_CHR$_Codes">C) ASCII and CHR$ Codes</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#D_Screen_and_Color_Memory_Maps">D)Screen and Color Memory
                                Maps</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#E_Music_Note_Values">E) Music Note Values</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#F_Bibliography">F) Bibliography</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#G_VIC_Chip_Register_Map">G) VIC Chip Register Map</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#H_Deriving_Mathematical_Functions">H) Deriving Mathematical
                                Functions</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#I_Pinouts_for_I/O_Devices">I) Pinouts for I/O Devices</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#J_Standard_BASIC_to_C64_BASIC">J) Standard BASIC to C64 BASIC</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#K_Error_Messages">K) Error Messages</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#L_6510_CPU_Specifications">L) 6510 CPU Specifications</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#M_6526_Complex_Interface_Adapter_Chip_Specifications">M) 6526
                                Complex Interface Adapter Chip Specifications</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#N_6566/6567_VIC-II_Chip_Specifications">N) 6566/6567 VIC-II Chip
                                Specifications</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#O_6581_SID_Chip_Specifications">O) 6581 SID Chip
                                Specifications</a>
                        </li>
                        <li>
                            <a class="nav-link" href="#P_Glossary">P) Glossary</a>
                        </li>
                    </ul>
                </nav>
            </div>
            <div class="content">
                <main id="main-doc">
                    <h3>Introduction</h3>
                    <section class="main-section" id="How_to_Use_This_Reference_Guide">
                        <header>
                            <h4>How to Use This Reference Guide</h4>
                        </header>
                        <p>Throughout this guide, certain notations will be used to denote the syntax for BASIC commands
                            and statements to show both the required and optional parts of each BASIC keyword. The rules
                            for interpreting statement syntax are as
                            follows:</p>
                        <ol>
                            <li>BASIC keywords will always be in CAPITAL letters.</li>
                            <li>Items shown in quotation marks (" ") indicate variable data that must be input by the
                                user.
                            </li>
                            <li>Items shown in square brackets ([ ]) indicate optional parameters (limitations or
                                additional qualifiers for statements). If you use an optional parameter, you MUST
                                provide the data for said parameter. Ellipses (...) show that
                                an optional item can be repeated as often as a programming line allows.</li>
                            <li>If an item is in square brackets and underlined, you must use those certain characters
                                in an optional parameter. Spelling must also be exact.</li>
                            <li>Items inside angle brackets (&lt; &gt;); indicate variable data provided by the user. A
                                slash (/) indicates you must make a choice between two mutually exclusive options.</li>
                        </ol>

                        <p class="example">Example of syntax format</p>
                        <blockquote>
                            OPEN &lt;file-number&gt; , &lt;device&gt; , [&lt;address&gt;] , ["&lt;drive&gt;:
                            &lt;file-name&gt;] , [&lt;mode&gt;]"
                        </blockquote>

                        <p class="example">Example of actual statement</p>
                        <blockquote>
                            <code>
                                10 OPEN 2,8,6,"0:STOCK FOLIO,S,W"
                                <br>20 OPEN 1,1,2,"CHECKBOOK"
                                <br>30 OPEN 3,4
                            </code>
                        </blockquote>

                        <p>When you apply the syntax conventions in practical situations, the parameter sequence may not
                            be exactly the same as in the examples provided. Examples are not meant to show every
                            possible sequence. They are only meant to present
                            all required and optional parameters.</p>

                        <p>Programming examples are shown with blanks separating words and operators. However, BASIC
                            normally doesn't require blanks between words unless leaving them out would give you an
                            ambiguous or incorrect syntax.
                        </p>

                        <p>Shown below are some examples and descriptions of the symbols used for various statement
                            parameters in the following chapters. This is not comprehensive, but it does give you a
                            better understanding of how syntax examples are presented.</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Example</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>&lt;file-num&gt;</td>
                                    <td>
                                        <code>50</code>
                                    </td>
                                    <td>Logical file number</td>
                                </tr>
                                <tr>
                                    <td>&lt;device&gt;</td>
                                    <td>
                                        <code>4</code>
                                    </td>
                                    <td>Hardware device number</td>
                                </tr>
                                <tr>
                                    <td>&lt;address&gt;</td>
                                    <td>
                                        <code>15</code>
                                    </td>
                                    <td>Serial bus secondary device address number</td>
                                </tr>
                                <tr>
                                    <td>&lt;drive&gt;</td>
                                    <td>
                                        <code>8</code>
                                    </td>
                                    <td>Physical disk drive number</td>
                                </tr>
                                <tr>
                                    <td>&lt;file-name&gt;</td>
                                    <td>
                                        <code>"TEST.DATA"</code>
                                    </td>
                                    <td>Name of data or program file</td>
                                </tr>
                                <tr>
                                    <td>&lt;constant&gt;</td>
                                    <td>
                                        <code>"ABCDEFG"</code>
                                    </td>
                                    <td>Literal data supplied by programmer</td>
                                </tr>
                                <tr>
                                    <td>&lt;variable&gt;</td>
                                    <td>
                                        <code>X145</code>
                                    </td>
                                    <td>Any BASIC data variable name or constant</td>
                                </tr>
                                <tr>
                                    <td>&lt;string&gt;</td>
                                    <td>
                                        <code>AB$</code>
                                    </td>
                                    <td>Use of string type variable required</td>
                                </tr>
                                <tr>
                                    <td>&lt;number&gt;</td>
                                    <td>
                                        <code>12345</code>
                                    </td>
                                    <td>Use of a numeric type variable required</td>
                                </tr>
                                <tr>
                                    <td>&lt;line-number&gt;</td>
                                    <td>
                                        <code>1000</code>
                                    </td>
                                    <td>Actual program line number</td>
                                </tr>
                                <tr>
                                    <td>&lt;numeric&gt;</td>
                                    <td>
                                        <code>1.5E4</code>
                                    </td>
                                    <td>Integer or floating point variable</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <h3>BASIC Programming Rules</h3>
                    <section class="main-section" id="Screen_Display_Codes">
                        <header>
                            <h4>Screen Display Codes (Character Set)</h4>
                        </header>
                        <h5>The Operating System (OS)</h5>
                        <p>The Operating System (OS) is contained in the ROM chips and is a combination of three program
                            modules:
                        </p>
                        <ol>
                            <li>The BASIC Interpreter</li>
                            <li>The KERNAL</li>
                            <li>The Screen Editor</li>
                        </ol>
                        <p>
                            <em>The BASIC Interpreter</em> is responsible for analyzing BASIC statement syntax and for
                            performing the required calculations and/or data manipulation. It has a vocabulary of 65
                            keywords. Alphanumeric (A-Z, a-z, 0-9) characters
                            are used to make both keywords and variable names. Some punctuation and special characters
                            have meanings for the Interpreter.
                        </p>
                        <table>
                            <thead>
                                <tr>
                                    <th>Character</th>
                                    <th>Name &amp; Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>&nbsp;</td>
                                    <td>BLANK &mdash; separates keywords and variable names</td>
                                </tr>
                                <tr>
                                    <td>;</td>
                                    <td>SEMI-COLON &mdash; used in variable lists to format output</td>
                                </tr>
                                <tr>
                                    <td>=</td>
                                    <td>EQUAL SIGN &mdash; value assignment and relationship testing</td>
                                </tr>
                                <tr>
                                    <td>+</td>
                                    <td>PLUS SIGN &mdash; addition operator or string concatenation</td>
                                </tr>
                                <tr>
                                    <td>-</td>
                                    <td>MINUS SIGN &mdash; subtraction operator, unary minus (-1)</td>
                                </tr>
                                <tr>
                                    <td>*</td>
                                    <td>ASTERISK &mdash; multiplication operator</td>
                                </tr>
                                <tr>
                                    <td>/</td>
                                    <td>SLASH &mdash; division operator</td>
                                </tr>
                                <tr>
                                    <td>&uarr;</td>
                                    <td>UP ARROW &mdash; exponentiation operator</td>
                                </tr>
                                <tr>
                                    <td>(</td>
                                    <td>LEFT PARENTHESIS &mdash; expression evaluation, functions</td>
                                </tr>
                                <tr>
                                    <td>)</td>
                                    <td>RIGHT PARENTHESIS &mdash; expression evaluation, functions</td>
                                </tr>
                                <tr>
                                    <td>%</td>
                                    <td>PERCENT &mdash; declares variable name as integer</td>
                                </tr>
                                <tr>
                                    <td>#</td>
                                    <td>NUMBER &mdash; comes before logical file number in I/O statements</td>
                                </tr>
                                <tr>
                                    <td>$</td>
                                    <td>DOLLAR SIGN &mdash; declares variable name as string</td>
                                </tr>
                                <tr>
                                    <td>,</td>
                                    <td>COMMA &mdash; used in variable lists to format output, separates command
                                        parameters
                                    </td>
                                </tr>
                                <tr>
                                    <td>.</td>
                                    <td>PERIOD &mdash; decimal point in floating point constants</td>
                                </tr>
                                <tr>
                                    <td>"</td>
                                    <td>QUOTATION MARK &mdash; encloses string constants</td>
                                </tr>
                                <tr>
                                    <td>:</td>
                                    <td>COLON &mdash; separates multiple BASIC statements in a line</td>
                                </tr>
                                <tr>
                                    <td>?</td>
                                    <td>QUESTION MARK &mdash; abbreviation for
                                        <code>print</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>&lt;</td>
                                    <td>LESS THAN &mdash; relationship operator</td>
                                </tr>
                                <tr>
                                    <td>&gt;</td>
                                    <td>GREATER THAN &mdash; relationship operator</td>
                                </tr>
                                <tr>
                                    <td>&pi;</td>
                                    <td>PI &mdash; numeric constant 3.141592654</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>
                            <em>The KERNAL</em> handles most of the interrupt level processing and does the actual input
                            and output of data.</p>

                        <p>
                            <em>The Screen Editor</em> controls output to the video screen and the editing of BASIC
                            programs. It also intercepts input from the keyboard to decide whether characters should be
                            acted on immediately or passed to the BASIC
                            Interpreter.</p>

                        <p>The OS gives you two modes of BASIC operation:</p>

                        <ol>
                            <li>
                                <em>DIRECT MODE</em> &mdash; In direct mode, BASIC statements do not have line numbers
                                and are executed when the RETURN key is pressed.</li>
                            <li>
                                <em>PROGRAM MODE</em> &mdash; Program mode is used for writing BASIC programs. All
                                statements MUST have line numbers. You can use more than one statement per line, but you
                                are limited to 80 characters per line.</li>
                        </ol>

                        <p>There are two complete character sets available for use.</p>

                        <ol>
                            <li>Set 1 includes all uppercase letters and 0-9. When pressing the &lt;SHIFT&gt; key, the
                                graphic character on the right side of the key will be shown. When pressing the
                                Commodore (CMDRE) key, the graphic character on the left
                                side of the key will be displayed. If there is no graphic character on the key, the
                                topmost character on the key will be displayed when holding the &lt;SHIFT&gt; key while
                                typing.</li>
                            <li>Set 2 is essentially the same character set but with lowercase letters instead.</li>
                        </ol>
                        <p>To switch between character sets, press &lt;SHIFT+CMDRE&gt;.</p>
                    </section>
                    <hr>
                    <section class="main-section" id="Programming_Numbers_and_Variables">
                        <header>
                            <h4>Programming Numbers and Variables</h4>
                        </header>
                        <h5>Integer, Floating-point, and String Constants</h5>

                        <p>
                            <em>Constants</em> are data values you put into BASIC statements. BASIC uses these values to
                            represent data during statement execution. CBM BASIC can recognize and manipulate three
                            types of constants:
                        </p>

                        <ol>
                            <li>Integers</li>
                            <li>Floating-point numbers</li>
                            <li>Strings</li>
                        </ol>

                        <p>
                            <em>Integers</em> are whole numbers between -32768 and 32767. Please note, integers do not
                            use commas or decimals between digits. If the plus sign (+) is left out, the number is
                            assumed positive. Zeroes before a constant are
                            ignored. Therefore, they should not be used since they waste memory and slow down your
                            program. Integers are stored as two-byte binary numbers.
                        </p>

                        <p class="example">Example integers</p>
                        <blockquote>
                            <code>-12
                                <br>8765
                                <br>-32768
                                <br>+44
                                <br>0
                                <br>-32767
                            </code>
                        </blockquote>

                        <p>
                            <em>Floating-point numbers</em> are positive or negative numbers and can contain fractions
                            shown in decimal form. Floating-point constants can be used in either simple number format
                            or scientific notation. Floating-point constants
                            will show up to nine digits on screen from -99999999 to 999999999. If more than nine digits
                            are entered, the number will be rounded based on the tenth digit. It will be rounded up if
                            the tenth digit is greater than or equal
                            to 5 and rounded down if it's less than 5. Floating-points are stored using five bytes of
                            memory and are manipulated in calculations with ten places of accuracy. However, they are
                            rounded to nine digits when printed.</p>

                        <p class="example">Example floating-point simple numbers</p>
                        <blockquote>
                            <code>1.23
                                <br>-.998877
                                <br>+3.14159
                                <br>.7777777
                                <br>-333.
                                <br>.01
                            </code>
                        </blockquote>

                        <p> Numbers smaller than .01 or greater than 999999999 will be shown in scientific notation. A
                            floating-point number in scientific notation is made up of three parts: the mantissa, the
                            letter E, and the exponent.
                        </p>

                        <p>The mantissa is a simple floating-point number. The letter E signifies the number is in
                            exponential form. In other words, it represents * 10, and the exponent is what
                            multiplication power of 10 the number is raised to. Both the
                            mantissa and the exponent are signed (+ or -) numbers. Exponents can range from -39 to +38
                            and indicate the number of places the decimal point in the mantissa would move left or right
                            if the value of the constant was shown
                            as a simple number.</p>

                        <p>There is a limit to the size of floating-point numbers that BASIC can handle, even in
                            scientific notation. The largest number possible is +1.70141183E+38, and any calculations
                            which result in a number exceeding the maximum will
                            display
                            <code>?OVERFLOW ERROR</code>. The smallest number BASIC can handle is +2.93873588E-39, and
                            any calculations which result in a number less than the minimum will give you zero as an
                            answer and
                            <em>no</em> error message.</p>

                        <p class="example">Example scientific notation</p>
                        <blockquote>
                            <pre>
235.988e-3          (.235988)
2359e6              (2359000000)
-7.09e-12           (-.00000000000709)
                            </pre>
                        </blockquote>

                        <p>
                            <em>Strings</em> are groups of alphanumeric information. When you enter a string from the
                            keyboard, it can have any length up to the space available in the 80-character line. A
                            string can contain blanks, alphanumeric characters,
                            punctuation, and color or cursor controls in any combination. You can also put commas in
                            between numbers. THE ONLY CHARACTERS NOT ALLOWED IN STRINGS ARE DOUBLE QUOTATION MARKS(" ").
                            Double quotes are used to define the beginning
                            and the end of a string. A string can also have a null value &mdash; which means it has no
                            character data. You can leave the ending quote off of a string if it is the last item of a
                            line followed by a colon.</p>

                        <p class="example">Example strings</p>
                        <blockquote>
                            <code>
                                "" (null string)
                                <br>"HELLO WORLD"
                                <br>"$25,000"
                            </code>
                        </blockquote>

                        <h5>Integer, floating-point, and string variables</h5>

                        <p>
                            <em>Variables</em> are names that represent data values used in BASIC statements. The value
                            of a variable can be assigned by setting it equal to a constant or can be the result of
                            calculations in the program. Like constants,
                            variables can be integers, floating-point numbers, or strings. If you reference a variable
                            before it has been assigned, the BASIC Interpreter will automatically assign a value of 0
                            for numbers or
                            <em>null</em> for strings.</p>

                        <p>Variables can be any length, but only the first two characters are considered significant in
                            CBM BASIC. In other words, any variable name
                            <em>cannot</em> have the same first two characters as another. They also cannot be the same
                            as BASIC keywords, nor can they contain keywords in the middle of the name. If you
                            accidentally use a keyword in a variable name, you
                            will see a
                            <code>?SYNTAX ERROR</code>.</p>

                        <p>The characters used to form variable names are alphanumeric, and the first character must be
                            a letter. Data type declaration characters (% and $) can be used as the last character of
                            the name. The percent sign (%) declares the
                            variable to be an integer, and the dollar sign ($) declares a string. If no declaration
                            character is used, the Interpreter automatically assumes it to be a floating-point number.
                        </p>

                        <p class="example">Example variables</p>
                        <blockquote>
                            <pre>
    A$="GROSS SALES"        (string)
    MTH$="JAN"+A$           (string)
    K%=5                    (integer)
    CNT%=CNT%+1             (integer)
    FP=12.5                 (floating-point)
    SUM=FP*CNT%             (floating-point)
                            </pre>
                        </blockquote>

                        <h5>Integer, floating-point, and string arrays</h5>

                        <p>An
                            <em>array</em> is a table (or list) of associated data items referred to by a variable
                            &mdash; in other words, a sequence of related variables. Individual variables are referred
                            to as
                            <em>elements</em> of an array.</p>

                        <p>Arrays are a useful shorthand way of describing a large number of related variables. If a
                            table of numbers has 10 rows of 20 numbers, there are 200 in the table. Without an array,
                            each individual number would require a unique variable
                            name. However, these numbers can be assigned to an array, and all elements assigned to the
                            array are referred to by their specific locations within the array.
                        </p>

                        <p>Array names, like constants and variables, can be integers, floating-point numbers, or
                            strings, and each element in the array has the same data type as the array name. Arrays can
                            have a single dimension (a simple list) or multiple
                            dimensions (a grid marked in rows and columns).
                        </p>

                        <p>The maximum number of dimensions an array can have in theory is 255. The maximum number of
                            elements per dimension is 32767. Practically speaking, array sizes are limited by the memory
                            space to hold their data and/or the 80 character
                            logical screen line. If an array has only one dimension, and its subscript value will never
                            exceed 10 (11 items, 0 - 10), the array will be created by the Interpreter and filled with
                            zeroes (or null values in the case of strings)
                            the first time any element of the array is referenced. Otherwise, the BASIC DIM statement
                            must be used to define the shape and size of the array.</p>

                        <p class="example">Required memory to store an array</p>
                        <blockquote>
                            <ul>
                                <li>5 bytes for the array name</li>
                                <li>+ 2 bytes for each dimension of the array</li>
                                <li>+ 2 bytes per element for integers</li>
                                <li>OR + 5 bytes per element for floating-point</li>
                                <li>OR + 3 bytes per element for strings</li>
                                <li>AND + 1 byte per character in each string element</li>
                            </ul>
                        </blockquote>

                        <p>Subscripts can be integer constants, variables, or an expression that gives an integer as the
                            result. Separate subscripts, with commas between them, are required for each dimension of
                            the array. Subscripts can have values from
                            zero up to the number of elements in the respective dimensions of the array. Values outside
                            this range will show a
                            <code>?BAD SUBSCRIPT</code> error.</p>

                        <p class="example">Example array names, values, and data types</p>
                        <blockquote>
                            <pre>
A$(0)="GROSS SALES"     (string array)
MTH$(K%)="JAN"          (string array)
G2%(X)=5                (integer array)
CNT%(G2%(X))=CNT%(1)-2  (integer array)
FP(12*K%)=24.8          (floating-point array)
SUM(CNT%(1))=FPK%      (floating-point array)
A(5)=0                  (sets the 5th element in the one-
                        dimensional array "A" to 0)
B(5,6)=0                (sets the element in row position 5 and column 
                         position 6 in the two-dimensional 
                         array "B" to 0)
C(1,2,3)=0              (sets the element in row position 1, column 
                         position 2, and depth position 3 in the three-
                         dimensional array "C" to 0)
                            </pre>
                        </blockquote>
                    </section>
                    <hr>
                    <section class="main-section" id="Expressions_and_Operators">
                        <header>
                            <h4>Expressions and Operators</h4>
                        </header>

                        <p>Expressions are formed using constants, variables, and/or arrays. An expression can be a
                            single constant, simple variable, or an array variable of any type. It can also be a
                            combination of constants and variables with arithmetic,
                            relational, or logical operators designed to produce a single value. Expressions can be
                            separated into two classes:
                            <em>arithmetic</em> and
                            <em>string</em>.</p>

                        <p>Expressions are normally thought of as having two or more data items called
                            <em>operands</em>. Each operand is separated by a single operator to produce the desired
                            result. This is usually done by assigning the value of the expression to a variable name.
                            All examples of constants and variables shown
                            previously were also examples of expressions.
                        </p>

                        <p>An operator is a special symbol the BASIC Interpreter recognizes as representing an operation
                            to be performed on the variables or constant data. One or more operators combined with one
                            or more variables and/or constants form an
                            expression. Arithmetic, relational, and logical operators are recognized by C64 BASIC.</p>

                        <h5>Arithmetic Expressions</h5>

                        <p>Arithmetic expressions will give an integer or floating-point value. Arithmetic operators (+,
                            -, *, /, &uarr;) are used to perform addition, subtraction, multiplication, division, and
                            exponentiation operations respectively.</p>

                        <h5>Arithmetic operations</h5>

                        <p>An arithmetic operator defines an arithmetic operation which is performed on the two operands
                            on either side of the operator. Arithmetic operations are performed using floating-point
                            numbers. Integers are converted to floating-point
                            numbers before an arithmetic operation is performed.
                        </p>

                        <p>
                            <strong>ADDITION (+): </strong>The plus sign specifies that the operand on the right is
                            added to the operand on the left.</p>

                        <p class="example">Examples:</p>
                        <blockquote>
                            <code>
                                2+2
                                <br>A+B+C
                                <br>X%+1
                                <br>BR+10E-2
                            </code>
                        </blockquote>

                        <p>
                            <strong>SUBTRACTION (-): </strong>The minus sign (-) specifies that the operand on the right
                            is subtracted from the operand on the left.</p>

                        <p class="example">Examples:</p>
                        <blockquote>
                            <code>
                                4-1
                                <br>100-64
                                <br>A-B
                                <br>55-142
                            </code>
                        </blockquote>

                        <p>The minus can also be used as a unary minus to make a number negative.</p>

                        <p class="example">Examples:</p>
                        <blockquote>
                            <code>
                                -5
                                <br>-9E4
                                <br>-B
                                <br>4-(-2)
                            </code>
                        </blockquote>

                        <p>
                            <strong>MULTIPLICATION (*): </strong>An asterisk (*) specifies that the operand on the left
                            is multiplied by the operand on the right.</p>

                        <p class="example">Examples:</p>

                        <blockquote>
                            <code>
                                100*2
                                <br>50*0
                                <br>A*X1
                                <br>R%*14
                            </code>
                        </blockquote>

                        <p>
                            <strong>DIVISION (/): </strong>The slash (/) specifies that the operand on the left is
                            divided by the operand on the right.</p>

                        <p class="example">Examples:</p>
                        <blockquote>
                            <code>
                                10/2
                                <br>6400/4
                                <br>A/B
                                <br>4E2/X2
                            </code>
                        </blockquote>

                        <p>
                            <strong>EXPONENTIATION (&uarr;): </strong>The up arrow (&uarr;) specifies that the operand
                            on the left is raised to the power specified by the operand on the right (the exponent). The
                            exponent can be any number so long as the
                            result of the operation is a valid floating-point number.
                        </p>

                        <p class="example">Examples:</p>
                        <blockquote>
                            <code>
                                2&uarr;2 (2 * 2)
                                <br>3&uarr;3 (3 * 3 * 3)
                                <br>4&uarr;4 (4 * 4 * 4 * 4)
                                <br>AB&uarr;CD
                                <br>3&uarr;-2 (&#8531; * &#8531;)
                            </code>
                        </blockquote>

                        <h5>Relational operators</h5>

                        <p>The relational operators (&lt;, =, &gt;, &lt;=, &gt;=, &lt;&gt;) are primarily used to
                            compare the values of two operands, but they also produce an arithmetic result. The
                            relational operators and the logical operators (AND, OR,
                            and NOT) when used in comparisons actually produce an arithmetic true/false evaluation of an
                            expression. If the relationship stated in the expression is true, the result is assigned an
                            integer value of -1, and if it's false,
                            the assigned value is 0. These are the relational operators:</p>

                        <blockquote>
                            <code>
                                &lt; less than
                                <br>= equal to
                                <br>&gt; greater than
                                <br>&lt;= less than or equal to
                                <br>&gt;= greater than or equal to
                                <br>&lt;&gt; not equal to
                            </code>
                        </blockquote>

                        <p class="example">Examples:</p>
                        <blockquote>
                            <pre>
1=5-4       result true (-1)
14&gt;66       result false (0)
15&gt;=15      result true (-1)
"A"&lt;"B"     result true (-1)
"X"="YY"    result false (0)
BB$&lt;&gt;CC$
                                </pre>
                        </blockquote>

                        <p>Relational operators can be used to compare strings. For comparison purposes, the letters of
                            the alphabet have the order A &lt; B &lt; C &lt; D, etc. Strings are compared by evaluating
                            the relationship between corresponding characters
                            from left to right.</p>

                        <p>Numeric data items can ONLY be compared (or assigned) to other numeric items. The same is
                            true when comparing strings, otherwise the BASIC error message
                            <code>?TYPE MISMATCH</code> will occur. Numeric operands are compared by first converting
                            the values of either or both operands from integer to floating-point form, as necessary.
                            Then the relationship of the floating-point
                            values is evaluated to give a true/false result.
                        </p>

                        <p>At the end of all comparisons, you get an integer no matter what data type the operand is
                            (even if both are strings). Because of this, a comparison of two operands can be used as an
                            operand in performing calculations. The result
                            will be -1 or 0 and can be used as anything but a divisor, since division by zero is
                            illegal.</p>

                        <h5>Logical operators</h5>

                        <p>The logical operators (AND, OR, NOT) can be used to modify the meanings of the relational
                            operators or to produce an arithmetic result. Logical operators can produce results other
                            than -1 and 0, though any nonzero result is considered
                            true when testing for a true/false condition.
                        </p>

                        <p>The logical operators (sometimes called Boolean operators) can also be used to perform logic
                            operations on individual binary digits (bits) in two operands. But when you're using the NOT
                            operator, the operation is performed only
                            on the single operand to the right. The operands must be in the integer range of values
                            (-32768 to +32767) (floating-point numbers are converted to integers) and logical operations
                            give an integer result.</p>

                        <p>Logical operations are performed bit-by-corresponding-bit on the two operands. The logical
                            AND produces a bit result of 1 only if both operand bits are 1. The logical OR produces a
                            bit result of 1 if either operand bit is 1. The
                            logical NOT is the opposite value of each bit as a single operand. In other words, it's
                            really saying, "If it's NOT 1, then it is 0. If it's NOT 0, then it is 1."
                        </p>

                        <p>The exclusive OR (XOR) doesn't have a logical operator but it is performed as part of the
                            WAIT statement. Exclusive OR means that if the bits of two operands are equal then the
                            result is 0 otherwise the result is 1.</p>

                        <p>Logical operations are defined by groups of statements which, taken together, constitute a
                            Boolean "truth table"</p>

                        <table>
                            <tr>
                                <td>
                                    The AND operation results in a 1 only if BOTH bits are 1:
                                    <br>
                                    <br>1 AND 1 = 1
                                    <br>0 AND 1 = 0
                                    <br>1 AND 0 = 0
                                    <br>0 AND 0 = 0
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    The OR operation results in a 1 if EITHER bit is 1:
                                    <br>
                                    <br>1 OR 1 = 1
                                    <br>0 OR 1 = 1
                                    <br>0 OR 0 = 1
                                    <br>0 OR 0 = 0
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    The NOT operation logically complements each bit:
                                    <br>
                                    <br>NOT 1 = 0
                                    <br>NOT 0 = 1
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    The exclusive OR (XOR) is part of the WAIT statement:
                                    <br>
                                    <br>1 XOR 1 = 0
                                    <br>1 XOR 0 = 1
                                    <br>0 XOR 1 = 1
                                    <br>0 XOR 0 = 0
                                </td>
                            </tr>
                        </table>

                        <p>The logical operators AND, OR and NOT specify a Boolean arithmetic operation to be performed
                            on the two operand expressions on either side of the operator. In the case of NOT, only the
                            operand on the RIGHT is considered. Logical
                            operations (or Boolean arithmetic) aren't performed until all arithmetic and relational
                            operations in an expression have been completed.
                        </p>

                        <p class="example">Examples:</p>
                        <blockquote>
                            <pre>
IF A=100 AND B=100 THEN 10 (if both A and B have a value of 100, 
                            then the result is true)
A=96 AND 32: PRINT A       (A=32)
IF A=100 OR B=100 THEN 20  (if A or B is 100 then the result is true)
A=64 OR 32: PRINT A        (A=96)
IF NOT X&lt;Y THEN 30         (if X&gt;=Y the result is true)
X= NOT 96                  (result is -97 (two's complement))
                                </pre>
                        </blockquote>

                        <h5>Hierarchy of operations</h5>

                        <p>All expressions perform the different types of operations according to a fixed hierarchy. In
                            other words, certain operations are performed before other operations. The normal order of
                            operations can be modified by enclosing two
                            or more operands within parentheses ( ), creating a
                            <em>subexpression</em>. The parts of an expression enclosed in parentheses will be reduced
                            to a single value before working on parts outside the parentheses.</p>

                        <p>When you use parentheses in expressions, they must be paired so that you always have an equal
                            number of left and right parentheses. Otherwise, the BASIC error message
                            <code>?SYNTAX ERROR</code> will appear.</p>

                        <p>Expressions which have operands inside parentheses may themselves be enclosed in parentheses,
                            forming complex expressions of multiple levels. This is called nesting. Parentheses can be
                            nested in expressions to a maximum depth of
                            ten levels &mdash; ten matching sets of parentheses. The inner-most expression has its
                            operations performed first.</p>

                        <p class="example">Examples of expressions</p>
                        <blockquote>
                            <code>
                                A+B
                                <br>C^(D+E)/2
                                <br>((X-C^(D+E)/2)*10)+1
                                <br>GG$&gt;HH$
                                <br>JJ$+"MORE"
                                <br>K%=1 AND M&lt;&gt;X
                                <br>K%=2 OR (A=B AND M&lt;X)
                                <br>NOT (D=E)
                            </code>
                        </blockquote>

                        <p>The BASIC Interpreter will normally perform operations on expressions by performing
                            arithmetic operations first, then relational operations, and logical operations lost. Both
                            arithmetic and logical operators have an order of precedence
                            (or hierarchy of operations) within themselves. On the other hand, relational operators do
                            not have an order of precedence and will be performed as the expression is evaluated from
                            left to right.</p>

                        <p>If all remaining operators in an expression have the same level of precedence then operations
                            happen from left to right. When performing operations on expressions within parentheses, the
                            normal order of precedence is maintained.</p>

                        <p class="example">Hierarchy of operations</p>
                        <table>
                            <thead>
                                <tr>
                                    <th>Operator</th>
                                    <th>Description</th>
                                    <th>Example</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>&uarr;</td>
                                    <td>Exponentiation</td>
                                    <td>
                                        <code>BASE&uarr;EXP</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>-</td>
                                    <td>Negation (unary minus)</td>
                                    <td>
                                        <code>-A</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>
                                        <code>* /</code>
                                    </td>
                                    <td>
                                        Multiplication
                                        <br>Division
                                    </td>
                                    <td>
                                        <code>
                                            AB * CD
                                            <br>EF / GH
                                        </code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>+ -</td>
                                    <td>
                                        Addition
                                        <br>Subtraction
                                    </td>
                                    <td>
                                        <code>
                                            CNT + 2
                                            <br>JK - PQ
                                        </code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>&lt; = &gt;</td>
                                    <td>Relational Operations</td>
                                    <td>
                                        <code>A &lt;= B</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>NOT</td>
                                    <td>Logical NOT (integer two's complement)</td>
                                    <td>
                                        <code>NOT K%</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>AND</td>
                                    <td>Logical AND</td>
                                    <td>
                                        <code>JK AND 128</code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>OR</td>
                                    <td>Logical OR</td>
                                    <td>
                                        <code>PQ OR 15</code>
                                    </td>
                                </tr>
                            </tbody>
                        </table>

                        <h5>String Operations</h5>

                        <p>Strings are compared using the same relational operators that are used for comparing numbers.
                            String comparisons are mode by taking one character at a time (left-to-right) from each
                            string and evaluating each character code position
                            from the PET/CBM character set. If the character codes are the same, the characters are
                            equal. If the character codes differ, the character with the lower code number is lower in
                            the character set. The comparison stops when
                            the end of either string is reached. All other things being equal, the shorter string is
                            considered less than the longer string. Leading or trailing blanks ARE significant.</p>

                        <p>Regardless of the data types, at the end of all comparisons you get an integer result. This
                            is true even if both operands are strings. Because of this a comparison of two string
                            operands can be used as an operand in performing
                            calculations. The result will be -1 or 0 (true or false) and can be used as anything but a
                            divisor since division by zero is illegal.
                        </p>

                        <h5>String expressions</h5>

                        <p>Expressions are treated as if an implied "&lt;&gt;0" follows them. This means that if an
                            expression is true then the next BASIC statements on. the same program line are executed. If
                            the expression is false the rest of the line
                            is ignored and the next line in the program is executed.
                        </p>

                        <p>Just as with numbers, you can also perform operations on string variables. The only string
                            arithmetic operator recognized by CBM BASIC is the plus sign (+) which is used to perform
                            concatenation of strings. When strings are concatenated,
                            the string on the right of the plus sign is appended to the string on the left, forming a
                            third string as a result. The result can be printed immediately, used in a comparison, or
                            assigned to a variable name. If a string data
                            item is compared with (or set equal to) a numeric item, or vice-versa, the BASIC error
                            message
                            <code>?TYPE MISMATCH</code> will occur.</p>

                        <p class="example">Examples of string expressions and concatenation</p>
                        <blockquote>
                            <pre>
10 A$="FILE": B$="NAME"
NAM$=A$+B$              (gives the string: FILENAME)
RES$="NEW "+A$+B$       (gives the string: NEW FILENAME)
                                </pre>
                        </blockquote>

                    </section>
                    <hr>
                    <section class="main-section" id="Programming_Techniques">
                        <header>
                            <h4>Programming Techniques</h4>
                        </header>
                        <h5>Data Conversion</h5>

                        <p>When necessary, the CBM BASIC Interpreter will convert a numeric data item from an integer to
                            floating-point, or vice-versa, according to the following rules:</p>

                        <ol>
                            <li>All arithmetic and relational operations are performed in floating-point format.
                                Integers are converted to floating-point form for evaluation of the expression, and the
                                result is converted back to integer. Logical operations
                                convert their operands to integers and return an integer result.
                            </li>
                            <li>If a numeric variable name of one type is set equal to a numeric data item of a
                                different type, the number will be converted and stored as the data type declared in the
                                variable name.
                            </li>
                            <li>When a floating-point value is converted to an integer, the fractional portion is
                                truncated (eliminated) and the integer result is less than or equal to the
                                floating-point value. If the result is outside the range of +32767
                                thru -32768, the BASIC error message
                                <code>?ILLEGAL QUANTITY</code> will occur.</li>
                        </ol>

                        <h5>Using the Input Statement</h5>

                        <p>Now that you know what variables are, let's take that information and put it together with
                            the INPUT statement for some practical programming applications.</p>

                        <p>In our first example, you can think of a variable as a "storage compartment" where the
                            Commodore 64 stores the user's response to your prompt question. To write a program which
                            asks the user to type in a name, you might assign
                            the variable N$ to the name typed in. Now every time you PRINT N$ in your program, the
                            Commodore 64 will automatically PRINT the name that the user typed in.
                        </p>

                        <p>Type the word NEW on your Commodore 64. Hit the RETURN key and try this example:</p>

                        <blockquote>
                            <code>
                                10 PRINT"YOUR NAME": INPUT N$
                                <br>20 PRINT"HELLO",N$
                            </code>
                        </blockquote>

                        <p>In this example you used N to remind yourself that this variable stands for "NAME". The
                            dollar sign ($) is used to tell the computer that you're using a string variable. It is
                            important to differentiate between the two types of
                            variables:</p>

                        <ol>
                            <li>Numeric</li>
                            <li>String</li>
                        </ol>

                        <p>You probably remember from the earlier sections that numeric variables are used to store
                            number values such as 1, 100, 4000, etc. A numeric variable can be a single letter (A), any
                            two letters (AB), a letter and a number (AI),
                            or two letters and a number (AB1). You can save memory space by using shorter variables.
                            Another helpful hint is to use letters and numbers for different categories in the same
                            program (AI, A2, A3). Also, if you want whole
                            numbers for an answer instead of numbers with decimal points, all you have to do is put a
                            percent sign (%) at the end of your variable name (AB%, AI%, etc.)</p>

                        <p>Now let's look at a few examples that use different types of variables and expressions with
                            the INPUT statement.
                        </p>

                        <blockquote>
                            <code>10 PRINT"ENTER A NUMBER": INPUT A
                                <br>20 PRINT A
                                <br>
                                <br>10 PRINT"ENTER A WORD": INPUT A$
                                <br>20 PRINT A$
                                <br>
                                <br>10 PRINT"ENTER A NUMBER": INPUT A
                                <br>20 PRINT A "TIMES 5 EQUALS" A*5
                            </code>
                        </blockquote>

                        <p>Calculations are important in most programs. You have a choice of using "actual numbers" or
                            variables when doing calculations, but if you're working with numbers supplied by a user you
                            must use numeric variables. Begin by asking
                            the user to type in two numbers like this:</p>

                        <blockquote>
                            <code>10 PRINT"TYPE 2 NUMBERS": INPUT A: INPUT N</code>
                        </blockquote>

                        <p>Now multiply those two numbers together to create a new variable C as shown in line 20 below:
                        </p>

                        <blockquote>
                            <code>20 C=A*B</code>
                        </blockquote>

                        <p>To PRINT the result as a message type</p>

                        <blockquote>
                            <code>30 PRINT A "TIMES" B "EQUALS" C</code>
                        </blockquote>

                        <p>Enter these 3 lines and RUN the program. Notice that the messages are inside the quotes while
                            the variables are not.</p>

                        <p>Now let's say that you wanted a dollar sign ($) in front of the number represented by
                            variable C. The $ must be PRINTed inside quotes and in front of variable C. To add the $ to
                            your program hit the &lt;RUN/STOP&gt; and &lt;RESTORE&gt;
                            keys. Now type in line 40 as follows:
                        </p>

                        <blockquote>
                            <code>40 PRINT"$" C</code>
                        </blockquote>

                        <p>Now hit &lt;RETURN&gt;, type RUN, and hit &lt;RETURN&gt; again. The dollar sign goes in
                            quotes because the variable C only represents a number and can't contain a $. If the number
                            represented by C was 100 then the Commodore 64
                            screen would display $100. But, if you tried to PRINT $C without using the quotes, you would
                            get a
                            <code>?SYNTAX ERROR</code> message.</p>

                        <p>One last tip about $$$: You can create a variable that represents a dollar sign which you can
                            then substitute for the $ when you want to use it with numeric variables. For example:</p>

                        <blockquote>
                            <code>10 Z$="$"</code>
                        </blockquote>

                        <p>Now whenever you need a dollar sign you can use the string variable Z$. Try this:</p>

                        <blockquote>
                            <code>20 PRINT Z$A</code>
                        </blockquote>

                        <p>Line 10 defines the $ as a string variable called Z$, and then INPUTs a number called A. Line
                            20 PRINTs Z$ ($) next to A (number).</p>

                        <p>You'll probably find that it's easier to assign certain characters, like dollar signs, to a
                            string variable than to type "$" every time you want to calculate dollars or other items
                            which require quotes like %.</p>

                        <p class="example">Income/Expense Budget Example</p>
                        <blockquote>
                            <code>
                                START TOK64 PAGE20.PRG
                                <br>5 PRINT"{CLEAR}"
                                <br>10 PRINT"MONTHLY INCOME":INPUT IN
                                <br>20 PRINT
                                <br>30 PRINT"EXPENSE CATEGORY 1":INPUT E1$
                                <br>40 PRINT"EXPENSE AMOUNT":INPUT E1
                                <br>50 PRINT
                                <br>60 PRINT"EXPENSE CATEGORY 2":INPUT E2$
                                <br>70 PRINT"EXPENSE AMOUNT":INPUT E2
                                <br>80 PRINT
                                <br>90 PRINT"EXPENSE CATEGORY 3":INPUT E3$
                                <br>100 PRINT"EXPENSE AMOUNT":INPUT E3
                                <br>110 PRINT"{CLEAR}"
                                <br>120 E=E1+E2+E3
                                <br>130 EP=E/IN
                                <br>140 PRINT"MONTHLY INCOME: $"IN
                                <br>150 PRINT"TOTAL EXPENSES: $"E
                                <br>160 PRINT"BALANCE EQUALS: $"IN-E
                                <br>170 PRINT
                                <br>180 PRINT E1$"="(E1/E)*100"% OF TOTAL EXPENSES"
                                <br>190 PRINT E2$"="(E2/E)*100"% OF TOTAL EXPENSES"
                                <br>200 PRINT E3$"="(E3/E)*100"% OF TOTAL EXPENSES"
                                <br>210 PRINT
                                <br>220 PRINT"YOUR EXPENSES="EP*100"% OF YOUR TOTAL INCOME"
                                <br>230 FORX=1TO5000:NEXT:PRINT
                                <br>240 PRINT"REPEAT? (Y OR N)":INPUT Y$:IF Y$="Y"THEN 5
                                <br>250 PRINT"{CLEAR}":END
                            </code>
                        </blockquote>

                        <p class="example table">EXPLANATION OF INCOME/EXPENSE BUDGET EXAMPLE</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Line(s)</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>5</td>
                                    <td>Clears the screen</td>
                                </tr>
                                <tr>
                                    <td>10</td>
                                    <td>PRINT/INPUT statement</td>
                                </tr>
                                <tr>
                                    <td>20</td>
                                    <td>Inserts blank line</td>
                                </tr>
                                <tr>
                                    <td>30</td>
                                    <td>Expense Category = E1$</td>
                                </tr>
                                <tr>
                                    <td>40</td>
                                    <td>Expense Amount = E1</td>
                                </tr>
                                <tr>
                                    <td>50</td>
                                    <td>Inserts blank line</td>
                                </tr>
                                <tr>
                                    <td>60</td>
                                    <td>Expense Category 2 = E2$</td>
                                </tr>
                                <tr>
                                    <td>70</td>
                                    <td>Expense Amount = E2</td>
                                </tr>
                                <tr>
                                    <td>80</td>
                                    <td>Inserts blank line</td>
                                </tr>
                                <tr>
                                    <td>90</td>
                                    <td>Expense Category 3 = E3$</td>
                                </tr>
                                <tr>
                                    <td>100</td>
                                    <td>Expense Amount = E3</td>
                                </tr>
                                <tr>
                                    <td>110</td>
                                    <td>Clears the screen</td>
                                </tr>
                                <tr>
                                    <td>120</td>
                                    <td>Add Expense Amounts = E</td>
                                </tr>
                                <tr>
                                    <td>130</td>
                                    <td>Calculate Expense/Income %</td>
                                </tr>
                                <tr>
                                    <td>140</td>
                                    <td>Display Income</td>
                                </tr>
                                <tr>
                                    <td>150</td>
                                    <td>Display Total Expenses</td>
                                </tr>
                                <tr>
                                    <td>160</td>
                                    <td>Display Income - Expenses</td>
                                </tr>
                                <tr>
                                    <td>170</td>
                                    <td>Inserts blank line</td>
                                </tr>
                                <tr>
                                    <td>180-200</td>
                                    <td>Calculates % each expense amount is of total expenses</td>
                                </tr>
                                <tr>
                                    <td>210</td>
                                    <td>Inserts blank line</td>
                                </tr>
                                <tr>
                                    <td>220</td>
                                    <td>Displays E/IN %</td>
                                </tr>
                                <tr>
                                    <td>230</td>
                                    <td>Time delay loop</td>
                                </tr>
                            </tbody>
                        </table>

                        <h5>Using the GET Statement</h5>
                        <p> Most simple programs use the INPUT statement to get data from the person operating the
                            computer. When you're dealing with more complex needs, like protection from typing errors,
                            the GET statement gives you more flexibility and
                            your program more "intelligence." This section shows you how to use the GET statement to add
                            some special screen editing features to your programs.</p>

                        <p> The Commodore 64 has a keyboard buffer that holds up to 10 characters. This means that if
                            the computer is busy doing some operation and it's not reading the keyboard, you can still
                            type in up to 10 characters, which will be used
                            as soon as the Commodore 64 finishes what it was doing. To demonstrate this, type in this
                            program on your Commodore 64:</p>

                        <blockquote>
                            <code>
                                NEW
                                <br>10 TI$="000000"
                                <br>20 IF TI$ &lt; "000015" THEN 20
                            </code>
                        </blockquote>

                        <p>Now type RUN, hit &lt;RETURN&gt;, and while the program is RUNning type in the word HELLO.
                        </p>

                        <p>Notice that nothing happened for about 15 seconds when the program started. Only then did the
                            message HELLO appear on the screen.</p>

                        <p>Imagine standing in line for a movie. The first person in the line is the first to get a
                            ticket and leave the line. The last person in line is last for a ticket. The GET statement
                            acts like a ticket taker. First it looks to see
                            if there are any characters "in line." In other words have any keys been typed. If the
                            answer is yes then that character gets placed in the appropriate variable. If no key was
                            pressed then an empty value is assigned to a variable.
                        </p>

                        <p>At this point it's important to note that if you try to put more than 10 characters into the
                            buffer at one time, all those over the 10th character will be lost.</p>

                        <p>Since the GET statement will keep going even when no character is typed, it is often
                            necessary to put the GET statement into a loop so that it will have to wait until someone
                            hits a key or until a character is received through
                            your program.</p>

                        <p>Below is the recommended form for the GET statement. Type NEW to erase your previous program.
                        </p>

                        <blockquote>
                            <code>10 GET A$: IF A$=""THEN 10</code>
                        </blockquote>

                        <p> Notice that there is
                            <em>no space</em> between the quote marks(" ") on this line. This indicates an empty value
                            and sends the program back to the GET statement in a continuous loop until someone hits a
                            key on the computer. Once a key is hit the
                            program will continue with the line following line 10. Add this line to your program:</p>

                        <blockquote>
                            <code>100 PRINT A$;: GOTO 10</code>
                        </blockquote>

                        <p>Now RUN the program. Notice that no cursor appears on the screen, but any character you type
                            will be printed in the screen. This 2-line program can be turned into part of a screen
                            editor program as shown below.</p>

                        <p>There are many things you can do with a screen editor. You can have a flashing cursor. You
                            can keep certain keys like &lt;CLR/HOME&gt; from accidentally erasing the whole screen. You
                            might even want to be able to use your function
                            keys to represent whole words or phrases. And speaking of function keys, the following
                            program lines give each function key a special purpose. Remember this is only the beginning
                            of a program that you can customize for your
                            needs.
                        </p>

                        <blockquote>
                            <code>
                                20 IF A$ = CHR$(133) THEN POKE 53280,8: GOTO 10
                                <br>30 IF A$ = CHR$(134) THEN POKE 53281,4: GOTO 10
                                <br>40 IF A$ = CHR$(135) THEN A$="DEAR SIR:"+CHR$(13)
                                <br>50 IF A$ = CHR$(136) THEN A$="SINCERELY,"+CHR$(13)
                            </code>
                        </blockquote>

                        <p>The CHR$ numbers in parentheses come from the CHR$ code chart in Appendix C. The chart lists
                            a different number for each character. The four function keys are set up to perform the
                            tasks represented by the instructions that follow
                            the word THEN in each line. By changing the CHR$ number inside each set of parentheses you
                            can designate different keys. Different instructions would be performed if you changed the
                            information after the THEN statement.</p>

                        <h5 id="crunching">How to Crunch BASIC Programs</h5>
                        <p>You can pack more instructions &mdash; and power &mdash; into your BASIC programs by making
                            each program as short as possible. This process of shortening programs is called
                            "crunching."
                        </p>

                        <p>Crunching programs lets you squeeze the maximum possible number of instructions into your
                            program. It also helps you reduce the size of programs which might not otherwise run in a
                            given size; and if you're writing a program which
                            requires the input of data such as inventory items, numbers or text, a short program will
                            leave more memory space free to hold data.
                        </p>

                        <h5>Abbreviating Keywords</h5>

                        <p>A list of keyword abbreviations is given in Appendix A. This is helpful when you program
                            because you can actually crowd more information on each line using abbreviations. The most
                            frequently used abbreviation is the question mark
                            (?) which is the BASIC abbreviation for the PRINT command. However, if you LIST a program
                            that has abbreviations, the Commodore 64 will automatically print out the listing with the
                            full-length keywords. If any program line
                            exceeds 80 characters (2 lines on the screen) with the keywords unabbreviated, and you want
                            to change it, you will have to re-enter that line with the abbreviations before saving the
                            program. SAVEing a program incorporates
                            the keywords without inflating any lines because BASIC keywords are tokenized by the
                            Commodore 64. Usually, abbreviations are added after a program is written and it isn't going
                            to be LISTed any more before SAVEing.</p>

                        <h5>Shortening Program Line Numbers</h5>
                        <p>Most programmers start their programs at line 100 and number each line at intervals of 10
                            (i.e., 100, 110, 120). This allows extra lines of instruction to be added (111, 112, etc.)
                            as the program is developed. One means of crunching
                            the program after it is completed is to change the fine numbers to the lowest numbers
                            possible (i.e., 1, 2, 3) because longer line numbers take more memory than shorter numbers
                            when referenced by GOTO and GOSUB statements.
                            For instance, the number 100 uses 3 bytes of memory (one for each number) while the number 1
                            uses only 1 byte.</p>

                        <h5>Putting Multiple Instructions on Each Line</h5>
                        <p>You can put more than one instruction on each numbered line in your program by separating
                            them by a colon. The only limitation is that all the instructions on each line, including
                            colons, should not exceed the standard 80-character
                            line length. Here is an example of two programs, before and after crunching:</p>

                        <p class="example">Before Crunching:</p>
                        <blockquote>
                            <code>
                                10 PRINT"HELLO...";
                                <br>20 FOR T=1 TO 500: NEXT
                                <br>30 PRINT"HELLO, AGAIN..."
                                <br>40 GOTO 10
                            </code>
                        </blockquote>

                        <p class="example">After Crunching:</p>
                        <blockquote>
                            <code>
                                10 PRINT"HELLO...";:FORT=1TO500:NEXT:
                                <br>PRINT"HELLO, AGAIN...":GOTO10
                            </code>
                        </blockquote>

                        <h5>Removing REM Statements</h5>
                        <p>REM statements are helpful in reminding yourself &mdash; or showing other programmers &mdash;
                            what a particular section of a program is doing. However, when the program is completed and
                            ready to use, you probably won't need those
                            REM statements anymore and you can save quite a bit of space by removing the REM statements.
                            If you plan to revise or study the program structure in the future, it's a good idea to keep
                            a copy on file with the REM statements
                            intact.
                        </p>

                        <h5>Using Variables</h5>
                        <p>If a number, word or sentence is used repeatedly in your program it's usually best to define
                            those long words or numbers with a one or two letter variable. Numbers can be defined as
                            single letters. Words and sentences can be defined
                            as string variables using a letter and dollar sign. Here's one example:</p>

                        <p class="example">Before Crunching:</p>
                        <blockquote>
                            <code>
                                10 POKE 54296,15
                                <br>20 POKE 54276,33
                                <br>30 POKE 54273,10
                                <br>40 POKE 54273,40
                                <br>50 POKE 54273,70
                                <br>60 POKE 54296,0
                            </code>
                        </blockquote>

                        <p class="example">After Crunching:</p>
                        <blockquote>
                            <code>
                                10 V=54296:F=54273
                                <br>20 POKEV,15:POKE54276,33
                                <br>30 POKEF,10:POKEF,40:POKEF,70
                                <br>40 POKEV,0
                            </code>
                        </blockquote>

                        <h5>Using READ and DATA Statements</h5>
                        <p>Large amounts of data can be typed in as one piece of data at a time, over and over again, or
                            you can print the instructional part of the program
                            <em>once</em> and print all the data to be handled in a long running list called the DATA
                            statement. This is especially good for crowding large lists of numbers into a program.</p>

                        <h5>Using Arrays and Matrices</h5>
                        <p>Arrays and matrices are similar to DATA statements in that long amounts of data can be
                            handled as a list, with the data handling portion of the program drawing from that list, in
                            sequence. Arrays differ in that the list can be
                            multi-dimensional.</p>

                        <h5>Eliminating Spaces</h5>
                        <p>One of the easiest ways to reduce the size of your program is to eliminate all the spaces.
                            Although we often include spaces in sample programs to provide clarity, you actually don't
                            need any spaces in your program and will save
                            space if you eliminate them.</p>

                        <h5>Using GOSUB Routines</h5>
                        <p>If you use a particular line or instruction over and over, it might be wise to GOSUB to the
                            line from several places in your program, rather than write the whole line or instruction
                            every time you use it.</p>

                        <h5>Using TAB and SPC</h5>
                        <p>Instead of PRINTing several cursor commands to position a character on the screen, it is
                            often more economical to use the TAB and SPC instructions to position words or characters on
                            the screen.
                        </p>
                    </section>

                    <h3>BASIC Language Vocabulary</h3>

                    <section class="main-section" id="BASIC_Language_Introduction">
                        <header>
                            <h4>BASIC Language Introduction</h4>
                        </header>
                        <p>This section explains CBM BASIC Language keywords. First we give you an easy to read list of
                            keywords, their abbreviations and what each letter looks like on the screen. Then we explain
                            how the syntax and operation of each keyword
                            works in detail, and examples are shown to give you an idea as to how to use them in your
                            programs.</p>

                        <p>As a convenience, Commodore 64 BASIC allows you to abbreviate most keywords. Abbreviations
                            are entered by typing enough letters of the keyword to distinguish it from all other
                            keywords, with the last letter or graphics entered
                            holding down the SHIFT key.</p>

                        <p>Abbreviations do not save any memory when they're used in programs, because all keywords are
                            reduced to single-character "tokens" by the BASIC Interpreter. When a program containing
                            abbreviations is listed, all keywords appear
                            in their fully spelled form. You can use abbreviations to put more statements onto a program
                            line even if they won't fit onto the 80-character logical screen line. The Screen Editor
                            works on an 80-character line. This means
                            that if you use abbreviations on any line that goes over 80 characters, you will not be able
                            to edit that line when LISTed. Instead, what you'll have to do is:</p>

                        <ol>
                            <li>Retype the entire line including all abbreviations, or</li>
                            <li>Break the single line of code into two lines, each with its own line number, etc.</li>
                        </ol>

                        <p>A complete list of keywords, abbreviations, and their appearance on the screen is presented
                            in Table 2-1. They are followed by an alphabetical description of all the statements,
                            commands, and functions available on your Commodore
                            64.</p>

                        <p>This section also explains the BASIC functions built into the BASIC Language Interpreter.
                            Built-in functions can be used in direct mode statements or in any program, without having
                            to define the function further. This is NOT the
                            case with user-defined functions. The results of built-in BASIC functions can be used as
                            immediate output or they can be assigned to a variable name of an appropriate type. There
                            are two types of BASIC functions:</p>

                        <ol>
                            <li>Numeric</li>
                            <li>String</li>
                        </ol>

                        <p>Arguments of built-in functions are always enclosed in parentheses ( ). The parentheses
                            always come directly after the function keyword and
                            <em>no spaces</em> between the last letter of the keyword and the left parenthesis (.</p>

                        <p>The type of argument needed is generally decided by the data type in the result. Functions
                            which return a string value as their result are identified by having a dollar sign ($) as
                            the last character of the keyword. In some cases
                            string functions contain one or more numeric argument. Numeric functions will convert
                            between integer and floating-point format as needed. In the descriptions that follow, the
                            data type of the value returned is shown with each
                            function name. The types of arguments are also given with the statement format.
                        </p>
                    </section>
                    <hr>
                    <section class="main-section" id="BASIC_Keywords_Abbreviations_and_Function_Types">
                        <header>
                            <h4>BASIC Keywords, Abbreviations, and Function Types</h4>
                        </header>
                        <table>
                            <thead>
                                <tr>
                                    <th>Command</th>
                                    <th>Abbreviation</th>
                                    <th>Screen</th>
                                    <th>Function Type</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>ABS</td>
                                    <td>A &lt;SHIFT+B&gt;</td>
                                    <td>
                                        <code class="screen">A|</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>AND</td>
                                    <td>A &lt;SHIFT+N&gt;</td>
                                    <td>
                                        <code class="screen">A&#9585;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>ASC</td>
                                    <td>A &lt;SHIFT+S&gt;</td>
                                    <td>
                                        <code class="screen">A&hearts;</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>ATN</td>
                                    <td>A &lt;SHIFT+T&gt;</td>
                                    <td>
                                        <code class="screen">A|</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>CHR$</td>
                                    <td>C &lt;SHIFT+H&gt;</td>
                                    <td>
                                        <code class="screen">C|</code>
                                    </td>
                                    <td>String</td>
                                </tr>
                                <tr>
                                    <td>CLOSE</td>
                                    <td>C &lt;SHIFT+L&gt;</td>
                                    <td>
                                        <code class="screen">C&#9492;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>CMD</td>
                                    <td>C &lt;SHIFT+M&gt;</td>
                                    <td>
                                        <code class="screen">C&#9586;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>CONT</td>
                                    <td>C &lt;SHIFT+O&gt;</td>
                                    <td>
                                        <code class="screen">C&#9484;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>COS</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">COS</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>DATA</td>
                                    <td>D &lt;SHIFT+A&gt;</td>
                                    <td>
                                        <code class="screen">D&spades;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>DEF</td>
                                    <td>D &lt;SHIFT+I&gt;</td>
                                    <td>
                                        <code class="screen">D&#9582;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>END</td>
                                    <td>E &lt;SHIFT+N&gt;</td>
                                    <td>
                                        <code class="screen">E&#9585;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>EXP</td>
                                    <td>E &lt;SHIFT+X&gt;</td>
                                    <td>
                                        <code class="screen">E&clubs;</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>FN</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">FN</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>FOR</td>
                                    <td>F &lt;SHIFT+O&gt;</td>
                                    <td>
                                        <code class="screen">F&#9484;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>FRE</td>
                                    <td>F &lt;SHIFT+R&gt;</td>
                                    <td>
                                        <code class="screen">F&#9472;</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>GET</td>
                                    <td>G &lt;SHIFT+E&gt;</td>
                                    <td>
                                        <code class="screen">G&#9472;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>GET#</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">GET#</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>GOSUB</td>
                                    <td>GO &lt;SHIFT+S&gt;</td>
                                    <td>
                                        <code class="screen">GO&hearts;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>GOTO</td>
                                    <td>G &lt;SHIFT+O&gt;</td>
                                    <td>
                                        <code class="screen">G&#9484;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>IF</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">IF</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>INPUT</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">INPUT</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>INPUT#</td>
                                    <td>I &lt;SHIFT+N&gt;</td>
                                    <td>
                                        <code class="screen">I&#9585;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>INT</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">INT</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>LEFT$</td>
                                    <td>LE &lt;SHIFT+F&gt;</td>
                                    <td>
                                        <code class="screen">LE&#9472;</code>
                                    </td>
                                    <td>String</td>
                                </tr>
                                <tr>
                                    <td>LEN</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">LEN</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>LET</td>
                                    <td>L &lt;SHIFT+E&gt;</td>
                                    <td>
                                        <code class="screen">L&#9472;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>LIST</td>
                                    <td>L &lt;SHIFT+I&gt;</td>
                                    <td>
                                        <code class="screen">L&#9582;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>LOAD</td>
                                    <td>L &lt;SHIFT+O&gt;</td>
                                    <td>
                                        <code class="screen">L&#9484;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>LOG</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">LOG</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>MID$</td>
                                    <td>M &lt;SHIFT+I&gt;</td>
                                    <td>
                                        <code class="screen">M&#9582;</code>
                                    </td>
                                    <td>String</td>
                                </tr>
                                <tr>
                                    <td>NEW</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">NEW</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>NEXT</td>
                                    <td>N &lt;SHIFT+E&gt;</td>
                                    <td>
                                        <code class="screen">N&#9472;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>NOT</td>
                                    <td>N &lt;SHIFT+O&gt;</td>
                                    <td>
                                        <code class="screen">N&#9484;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>ON</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">ON</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>OPEN</td>
                                    <td>O &lt;SHIFT+P&gt;</td>
                                    <td>
                                        <code class="screen">O&#9488;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>OR</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">OR</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>PEEK</td>
                                    <td>P &lt;SHIFT+E&gt;</td>
                                    <td>
                                        <code class="screen">P&#9472;</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>POKE</td>
                                    <td>P &lt;SHIFT+O&gt;</td>
                                    <td>
                                        <code class="screen">P&#9484;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>POS</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">POS</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>PRINT</td>
                                    <td>?</td>
                                    <td>
                                        <code class="screen">?</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>PRINT#</td>
                                    <td>P &lt;SHIFT+R&gt;</td>
                                    <td>
                                        <code class="screen">P&#9472;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>READ</td>
                                    <td>R &lt;SHIFT+E&gt;</td>
                                    <td>
                                        <code class="screen">R&#9472;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>REM</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">REM</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>RESTORE</td>
                                    <td>RE &lt;SHIFT+S&gt;</td>
                                    <td>
                                        <code class="screen">RE&hearts;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>RETURN</td>
                                    <td>RE &lt;SHIFT+T&gt;</td>
                                    <td>
                                        <code class="screen">RE|</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>RIGHT$</td>
                                    <td>R &lt;SHIFT+I&gt;</td>
                                    <td>
                                        <code class="screen">R&#9582;</code>
                                    </td>
                                    <td>String</td>
                                </tr>
                                <tr>
                                    <td>RND</td>
                                    <td>R &lt;SHIFT+N&gt;</td>
                                    <td>
                                        <code class="screen">R&#9585;</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>RUN</td>
                                    <td>R &lt;SHIFT+U&gt;</td>
                                    <td>
                                        <code class="screen">R&#9581;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>SAVE</td>
                                    <td>S &lt;SHIFT+A&gt;</td>
                                    <td>
                                        <code class="screen">S&spades;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>SGN</td>
                                    <td>S &lt;SHIFT+G&gt;</td>
                                    <td>
                                        <code class="screen">S|</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>SIN</td>
                                    <td>S &lt;SHIFT+I&gt;</td>
                                    <td>
                                        <code class="screen">S&#9582;</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>SPC(</td>
                                    <td>S &lt;SHIFT+P&gt;</td>
                                    <td>
                                        <code class="screen">S&#9488;</code>
                                    </td>
                                    <td>Special</td>
                                </tr>
                                <tr>
                                    <td>SQR</td>
                                    <td>S &lt;SHIFT+Q&gt;</td>
                                    <td>
                                        <code class="screen">S&#9679;</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>STATUS</td>
                                    <td>ST</td>
                                    <td>
                                        <code class="screen">ST</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>STEP</td>
                                    <td>ST &lt;SHIFT+E&gt;</td>
                                    <td>
                                        <code class="screen">ST&#9472;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>STOP</td>
                                    <td>S &lt;SHIFT+T&gt;</td>
                                    <td>
                                        <code class="screen">S|</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>STR$</td>
                                    <td>ST &lt;SHIFT+R&gt;</td>
                                    <td>
                                        <code class="screen">ST&#9472;</code>
                                    </td>
                                    <td>String</td>
                                </tr>
                                <tr>
                                    <td>SYS</td>
                                    <td>S &lt;SHIFT+Y&gt;</td>
                                    <td>
                                        <code class="screen">S|</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>TAB(</td>
                                    <td>T &lt;SHIFT+A&gt;</td>
                                    <td>
                                        <code class="screen">T&spades;</code>
                                    </td>
                                    <td>Special</td>
                                </tr>
                                <tr>
                                    <td>TAN</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">TAN</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>THEN</td>
                                    <td>T &lt;SHIFT+H&gt;</td>
                                    <td>
                                        <code class="screen">T|</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>TIME</td>
                                    <td>TI</td>
                                    <td>
                                        <code class="screen">TI</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>TIME$</td>
                                    <td>TI$</td>
                                    <td>
                                        <code class="screen">TI$</code>
                                    </td>
                                    <td>String</td>
                                </tr>
                                <tr>
                                    <td>TO</td>
                                    <td>none</td>
                                    <td>
                                        <code class="screen">TO</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>USR</td>
                                    <td>U &lt;SHIFT+S&gt;</td>
                                    <td>
                                        <code class="screen">U&hearts;</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>VAL</td>
                                    <td>V &lt;SHIFT+A&gt;</td>
                                    <td>
                                        <code class="screen">V&spades;</code>
                                    </td>
                                    <td>Numeric</td>
                                </tr>
                                <tr>
                                    <td>VERIFY</td>
                                    <td>V &lt;SHIFT+E&gt;</td>
                                    <td>
                                        <code class="screen">C&#9472;</code>
                                    </td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>WAIT</td>
                                    <td>W &lt;SHIFT+A&gt;</td>
                                    <td>
                                        <code class="screen">W&spades;</code>
                                    </td>
                                    <td></td>
                                </tr>
                            </tbody>
                        </table>
                        <p class="table-note">
                            <strong>NOTE:</strong> Some graphics characters shown above may not look exactly like
                            characters shown on real C64 hardware or in emulation.</p>
                    </section>
                    <hr>
                    <section class="main-section" id="Description_of_BASIC_Keywords">
                        <header>
                            <h4>Description of BASIC Keywords</h4>
                        </header>

                        <h5 id="ABS">ABS</h5>

                        <p>
                            <strong>TYPE:</strong> Function, Numeric</p>
                        <p>
                            <strong>FORMAT:</strong> ABS(&lt;expression&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> Returns the absolute value of the number, which is its value
                            without any signs. The absolute value of a negative number is that number multiplied by -1.
                        </p>

                        <p class="example">Examples of ABS Function</p>
                        <blockquote>
                            <code>
                                10 X = ABS (Y)
                                <br>10 PRINT ABS (X*J)
                                <br>10 IF X = ABS (X) THEN PRINT"POSITIVE"
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="AND">AND</h5>

                        <p>
                            <strong>TYPE:</strong> Operator</p>
                        <p>
                            <strong>FORMAT:</strong> &lt;expression&gt; AND &lt;expression&gt;</p>
                        <p>
                            <strong>ACTION:</strong> AND is used in Boolean operations to test bits. It is also used in
                            operations to check the truth of both operands.</p>

                        <p>In Boolean algebra, the result of an AND operation is 1 only if both numbers being ANDed are
                            1. The result is 0 if either or both is 0 (false).</p>

                        <p class="example">Examples of 1-Bit AND Operation</p>
                        <blockquote>
                            <pre>
        0        1        0        1
    AND 0    AND 0    AND 1    AND 1
    -----    -----    -----    -----
        0        0        0        1
            </pre>
                        </blockquote>

                        <p>The Commodore 64 performs the AND operation on numbers in the range from -32768 to +32767.
                            Any fractional values are not used, and numbers beyond the range will cause an
                            <code>?ILLEGAL QUANTITY</code> error message. When converted to binary format, the range
                            allowed yields 16 bits for each number. Corresponding bits are ANDed together, forming a
                            16-bit result in the same range.
                        </p>

                        <p class="example">Examples of 16-Bit AND Operation</p>
                        <blockquote>
                            <pre>
                             17
                        AND 194
                        -------
               0000000000010001
           AND 0000000011000010
      -------------------------
      (BINARY) 0000000000000000
      -------------------------
      (DECIMAL)               0

                          32007
                      AND 28761
                     ----------
               0111110100000111
           AND 0111000001011001
     --------------------------
      (BINARY) 0111000000000001
     --------------------------
     (DECIMAL)            2867  
                           -241
                      AND 15359
                     ----------
               1111111100001111
           AND 0011101111111111
     --------------------------
      (BINARY) 0011101100001111
     --------------------------
     (DECIMAL)            15119
            </pre>
                        </blockquote>

                        <p>When evaluating a number for truth or falsehood, the computer assumes the number is true as
                            long as its value isn't 0. When evaluating a comparison, it assigns a value of -I if the
                            result is true, while false has a value of 0.
                            In binary format, -1 is all 1's and 0 is all 0's. Therefore, when ANDing true/false
                            evaluations, the result will be true if any bits in the result are true.
                        </p>

                        <p class="example">Examples of Using AND with True/False Evaluations:</p>
                        <blockquote>
                            <code>
                                50 IF X=7 AND W=3 THEN GOTO 10: REM ONLY TRUE IF BOTH X=7 AND W=3 ARE TRUE
                                <br>60 IF A AND Q=7 THEN GOTO 10: REM TRUE IF A IS NON-ZERO AND Q=7 IS TRUE
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="ASC">ASC</h5>

                        <p>
                            <strong>TYPE:</strong> Function, Numeric</p>
                        <p>
                            <strong>FORMAT:</strong> ASC(&lt;string&gt;)</p>
                        <p>
                            <strong>ACTION:</strong> ASC will return a number from 0 to 255 which corresponds to the
                            Commodore ASCII value of the first character in the string. The table of Commodore ASCII
                            values is shown in Appendix C.
                        </p>

                        <p class="example">Examples of ASC Function</p>
                        <blockquote>
                            <code>
                                10 PRINT ASC("Z")
                                <br>20 X=ASC("ZEBRA")
                                <br>30 J=ASC(J$)
                            </code>
                        </blockquote>

                        <p>If there are no characters in the string, an
                            <code>?ILLEGAL QUANTITY</code> error results. In the third example above, if J$="", the ASC
                            function will not work. The GET and GET# statement read a CHR$(0) as a null string. To
                            eliminate this problem, you should add a CHR$(0)
                            to the end of the string as shown below.
                        </p>

                        <p class="example">Example of ASC Function Avoiding ILLEGAL QUANTITY Error</p>
                        <blockquote>
                            <code>
                                30 J=ASC(J$+CHR$(0))
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="ATN">ATN</h5>

                        <p>
                            <strong>TYPE:</strong> Function, Numeric</p>
                        <p>
                            <strong>FORMAT:</strong> ATN(&lt;number&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> This mathematical function returns the arctangent of the number.
                            The result is the angle (in radians) whose tangent is the number given. The result is always
                            in the range of -pi/2 to +pi/2.
                        </p>

                        <p class="example">Examples of ATN Function</p>
                        <blockquote>
                            <code>
                                10 PRINT ATN(0)
                                <br>20 X=ATN(J)*180/{pi}: REM CONVERT TO DEGREES
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="CHR$">CHR$</h5>

                        <p>
                            <strong>TYPE:</strong> Function, String</p>
                        <p>
                            <strong>FORMAT:</strong> CHR$(&lt;number&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> This function converts a Commodore ASCII code to its character
                            equivalent. See Appendix C for a list of characters and their codes. The number must have a
                            value between 0 and 255, or an
                            <code>?ILLEGAL QUANTITY</code> error message results.</p>

                        <p class="example">Examples of CHR$ Function</p>
                        <blockquote>
                            <code>
                                10 PRINT CHR$(65) : REM 65 = UPPER CASE A
                                <br>20 A$=CHR$(13) : REM 13 = RETURN KEY
                                <br>50 A=ASC(A$) : A$ = CHR$(A) : REM CONVERTS TO C64 ASCII CODE AND BACK
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="CLOSE">CLOSE</h5>

                        <p>
                            <strong>TYPE:</strong> I/O Statement</p>
                        <p>
                            <strong>FORMAT:</strong> CLOSE&lt;file number&gt;</p>

                        <p>
                            <strong>ACTION:</strong> This statement shuts off any data file or channel to a device. The
                            file number is the same as when the file or device was OPENed (see OPEN statement and the
                            section on INPUT/OUTPUT programming).
                        </p>
                        <p>When working with storage devices like cassette tape and disks, the CLOSE operation stores
                            any incomplete buffers to the device. When this is not performed, the file will be
                            incomplete on the tape and unreadable on the disk. The
                            CLOSE operation isn't as necessary with other devices, but it does free up memory for other
                            files. See your external device manual for more details.</p>

                        <p class="example">Examples of CLOSE Statement</p>
                        <blockquote>
                            <code>
                                10 CLOSE 1
                                <br>20 CLOSE X
                                <br> 30 CLOSE 9*(1+J)
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="CLR">CLR</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> CLR</p>

                        <p>
                            <strong>ACTION:</strong> This statement makes available RAM memory that had been used but is
                            no longer needed. Any BASIC program in memory is untouched, but all variables, arrays, GOSUB
                            addresses, FOR...NEXT loops, user-defined
                            functions, and files are erased from memory, and their space is made available to new
                            variables, etc.</p>

                        <p>In the case of files to the disk and cassette tape, they are not properly CLOSED by the CLR
                            statement. The information about the files is lost to the computer, including any incomplete
                            buffers. The disk drive will still think the
                            file is OPEN. See the CLOSE statement for more information on this.
                        </p>

                        <p class="example">Example of CLR Statement</p>
                        <blockquote>
                            <code>
                                10 X=25
                                <br>20 CLR
                                <br>PRINT X
                                <br>
                                <br>RUN
                                <br>0
                                <br>
                                <br>READY
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="CMD">CMD</h5>

                        <p>
                            <strong>TYPE:</strong> I/O Statement</p>
                        <p>
                            <strong>FORMAT:</strong> &lt;file number&gt; [,string]</p>

                        <p>
                            <strong>ACTION:</strong> This statement switches the primary output device from the TV
                            screen to the file specified. This file could be on disk, tape, printer, or an I/O device
                            like the modem. The file number must be specified
                            in a prior OPEN statement. The string, when specified, is sent to the file. This is handy
                            for titling printouts, etc.</p>

                        <p> When this command is in effect, any PRINT statements and LIST commands will not display on
                            the screen, but will send the text in the same format to the file.</p>

                        <p>To re-direct the output back to the screen, the PRINT# command should send a blank line to
                            the CMD device before CLOSEing, so it will stop expecting data (called "un-listening" the
                            device).
                        </p>

                        <p>Any system error (like
                            <code>?SYNTAX ERROR</code>) will cause output to return to the screen. Devices aren't
                            un-listened by this, so you should send a blank line after an error condition. (See your
                            printer or disk manual for more details.)</p>

                        <p class="example">Examples of CMD Statement</p>
                        <blockquote>
                            <code>
                                OPEN 4,4: CMD 4,"TITLE" : LIST: REM LISTS PROGRAM ON PRINTER
                                <br>PRINT#4: CLOSE 4: REM UN-LISTENS AND CLOSES PRINTER
                                <br>
                                <br>10 OPEN 1,1,1,"TEST" : REM CREATE SEQ FILE
                                <br>20 CMD 1 : REM OUTPUT TO TAPE FILE, NOT SCREEN
                                <br>30 FOR L = 1 TO 100
                                <br>40 PRINT L: REM PUTS NUMBER IN TAPE BUFFER
                                <br>50 NEXT
                                <br>60 PRINT#1 : REM UNLISTEN
                                <br>70 CLOSE 1 : REM WRITE UNFINISHED BUFFER, PROPERLY FINISH
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="CONT">CONT</h5>

                        <p>
                            <strong>TYPE:</strong> Command</p>
                        <p>
                            <strong>FORMAT:</strong> CONT</p>

                        <p>
                            <strong>ACTION:</strong> This command re-starts the execution of a program which was halted
                            by a STOP or END statement or the &lt;RUN/STOP&gt; key being pressed. The program will
                            re-start at the exact place from which it left
                            off.</p>

                        <p>While the program is stopped, the user can inspect or change any variables or look at the
                            program. When debugging or examining a program, STOP statements can be placed at strategic
                            locations to allow examination of variables and
                            to check the flow of the program.</p>

                        <p>The error message CAN'T CONTINUE will result from editing the program (even just hitting
                            &lt;RETURN&gt; with the cursor on an unchanged line), or if the program halted due to an
                            error, or if you caused an error before typing CONT
                            to re-start the program.</p>

                        <p class="example">Example of CONT Command</p>
                        <blockquote>
                            <code>
                                10 PI=0:C=1
                                <br>20 PI=PI+4/C-4/(C+2)
                                <br>30 PRINT PI
                                <br>40 C=C+4:GOTO 20
                            </code>
                        </blockquote>

                        <p>This program calculates the value of PI. RUN this program, and after a short while hit the
                            &lt;RUN/STOP&gt; key. You will see the display:</p>

                        <blockquote>
                            <code>
                                BREAK IN 20
                            </code>
                        </blockquote>

                        <p>Type the command PRINT C to see how far the Commodore 64 has gotten. Then use CONT to resume
                            from where the Commodore 64 left off.</p>

                        <hr>

                        <h5 id="COS">COS</h5>

                        <p>
                            <strong>TYPE:</strong> Function</p>
                        <p>
                            <strong>FORMAT</strong> COS(&lt;number&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> This mathematical function calculates the cosine of the number,
                            where the number is an angle in radians.</p>

                        <p class="example">Examples of COS Function</p>
                        <blockquote>
                            <code>
                                10 PRINT COS(0)
                                <br>20 X=COS(Y*{pi}/180):REM CONVERT DEGREES TO RADIANS
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="DATA">DATA</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT</strong> DATA &lt;list of constants&gt;</p>

                        <p>
                            <strong>ACTION:</strong> DATA statements store information within a program. The program
                            uses the information by means of the READ statement, which pulls successive constants from
                            the DATA statements.
                        </p>
                        <p>The DATA statements don't have to be executed by the program, they only have to be present.
                            Therefore, they are usually placed at the end of the program.</p>
                        <p>All data statements in a program are treated as a continuous list. Data is READ from left to
                            right, from the lowest numbered line to the highest. If the READ statement encounters data
                            that doesn't fit the type requested (if it
                            needs a number and finds a string) an error message occurs.
                        </p>

                        <p class="example">Examples of DATA Statement</p>
                        <blockquote>
                            <code>
                                10 DATA 1,10,5,8
                                <br>20 DATA JOHN,PAUL,GEORGE,RINGO
                                <br>30 DATA "DEAR MARY, HOW ARE YOU, LOVE, BILL"
                                <br>40 DATA -1.7E-9, 3.33
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="DEF">DEF FN</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> DEF FN &lt;name&gt; (&lt;variable&gt;)=&lt;expression&gt;</p>

                        <p>
                            <strong>ACTION:</strong> This sets up a user-defined function that can be used later in the
                            program. The function can consist of any mathematical formula. User-defined functions save
                            space in programs where a long formula is
                            used in several places. The formula need only be specified once, in the definition
                            statement, and then it is abbreviated as a function name. It must be executed once, but any
                            subsequent executions are ignored.</p>
                        <p>The function name is the letters FN followed by any variable name. This can be 1 or 2
                            characters, the first being a letter and the second a letter or digit.</p>

                        <p class="example">Examples of DEF FN Statement</p>
                        <blockquote>
                            <code>
                                10 DEF FN A(X)=X+7
                                <br>20 DEF FN AA(X)=Y*Z
                                <br>30 DEF FN A9(Q) = INT(RND(1)*Q+1)
                            </code>
                        </blockquote>

                        <p>The function is called later in the program by using the function name with a variable in
                            parentheses. This function name is used like any other variable, and its value is
                            automatically calculated.
                        </p>

                        <p class="example">Examples of FN Use</p>
                        <blockquote>
                            <code>
                                40 PRINT FN A(9)
                                <br>50 R=FN AA(9)
                                <br>60 G=G+FN A9(10)
                            </code>
                        </blockquote>

                        <p>In line 50 above, the number 9 inside the parentheses does not affect the outcome of the
                            function, because the function definition in line 20 doesn't use the variable in the
                            parentheses. The result is Y times Z, regardless of the
                            value of X. In the other two functions, the value in parentheses does affect the result.</p>

                        <hr>

                        <h5 id="DIM">DIM</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> DIM &lt;variable&gt; (&lt;subscripts&gt;)
                            [&lt;variable&gt;(&lt;subscripts&gt;)]
                        </p>

                        <p>
                            <strong>ACTION:</strong> This statement defines an array or matrix of variables. This allows
                            you to use the variable name with a subscript. The subscript points to the element being
                            used. The lowest element number in an array
                            is zero, and the highest is the number given in the DIM statement, which has a maximum of
                            32767.</p>
                        <p>The DIM statement must be executed once and only once for each array. A
                            <code>REDIM'D ARRAY</code> error occurs if this line is re-executed. Therefore, most
                            programs perform all DIM operations at the very beginning.</p>
                        <p>There may be any number of dimensions and 255 subscripts in an array, limited only by the
                            amount of RAM memory which is available to hold the variables. The array may be made up of
                            normal numeric variables, as shown above, or of
                            strings or integer numbers. If the variables are other than normal numeric, use the $ or %
                            signs after the variable name to indicate string or integer variables.
                        </p>
                        <p>If an array referenced in a program was never DIMensioned, it is automatically dimensioned to
                            11 elements in each dimension used in the first reference.</p>

                        <p class="example">Examples of DIM Statement</p>
                        <blockquote>
                            <code>
                                10 DIM A(100)
                                <br>20 DIM Z (5,7), Y(3,4,5)
                                <br>30 DIM Y7%(Q)
                                <br>40 DIM PH$(1000)
                                <br>50 F(4)=9 : REM AUTOMATICALLY PERFORMS DIM F(10)
                            </code>
                        </blockquote>

                        <p class="example">Example of Football Score-Keeping Using DIM</p>
                        <blockquote>
                            <code>
                                10 DIM S(1,5), T$(1)
                                <br>20 INPUT"TEAM NAMES"; T$(0), T$(1)
                                <br>30 FOR Q=1 TO 5: FOR T=0 TO 1
                                <br>40 PRINT T$(T),"SCORE IN QUARTER" Q
                                <br>50 INPUT S(T,Q): S(T,0)= S(T,0)+ S(T,Q)
                                <br>60 NEXT T,Q
                                <br>70 PRINT CHR$(147) "SCOREBOARD"
                                <br>80 PRINT "QUARTER"
                                <br>90 FOR Q= 1 TO 5
                                <br>100 PRINT TAB(Q*2+9) Q;
                                <br>110 NEXT: PRINT TAB(15) "TOTAL"
                                <br>120 FOR T=0 TO 1: PRINT T$(T);
                                <br>130 FOR Q= 1 TO 5
                                <br>140 PRINT TAB(Q*2+9) S(T,Q);
                                <br>150 NEXT: PRINT TAB(15) S(T,0)
                                <br>160 NEXT
                            </code>
                        </blockquote>

                        <p class="example">Calculating Memory Used by DIM:</p>
                        <ul>
                            <li>5 bytes for the array name</li>
                            <li>2 bytes for each dimension</li>
                            <li>2 bytes/element for integer variables</li>
                            <li>5 bytes/element for normal numeric variables</li>
                            <li>3 bytes/element for string variables</li>
                            <li>1 byte for each character in each string element</li>
                        </ul>

                        <hr>

                        <h5 id="END">END</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> END</p>

                        <p>
                            <strong>ACTION:</strong> This finishes a program's execution and displays the READY message,
                            returning control to the person operating the computer. There may be any number of END
                            statements within a program. While it is not
                            necessary to include any END statements at all, it is recommended that a program does
                            conclude with one, rather than just running out of lines.
                        </p>
                        <p>The END statement is similar to the STOP statement. The only difference is that STOP causes
                            the computer to display the message BREAK IN LINE XX and END just displays READY. Both
                            statements allow the computer to resume execution
                            by typing the CONT command.</p>

                        <p class="example">Examples of END Statement</p>
                        <blockquote>
                            <code>
                                10 PRINT"DO YOU REALLY WANT TO RUN THIS PROGRAM"
                                <br>20 INPUT A$
                                <br>30 IF A$ = "NO" THEN END
                                <br>40 REM REST OF PROGRAM . . .
                                <br>999 END
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="EXP">EXP</h5>

                        <p>
                            <strong>TYPE:</strong> Function, Numeric</p>
                        <p>
                            <strong>FORMAT</strong> EXP(&lt;number&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> Action: This mathematical function calculates the constant e
                            (2.71828183) raised to the power of the number given. A value greater than 88.0296919 causes
                            an
                            <code>?OVERFLOW ERROR</code> to occur.</p>

                        <p class="example">Examples of EXP Function:</p>
                        <blockquote>
                            <code>
                                10 PRINT EXP (1)
                                <br>20 X = Y*EXP (Z*Q)
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="FN">FN</h5>

                        <p>
                            <strong>TYPE:</strong> Function, Numeric</p>
                        <p>
                            <strong>FORMAT:</strong> FN &lt;name&gt;(&lt;number&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> This function references the previously DEFined formula specified
                            by name. The number is substituted into its place (if any) and the formula is calculated.
                            The result will be a numeric value.</p>

                        <p>This function can be used in direct mode, as long as the statement DEFining it has been
                            executed.
                        </p>
                        <p>If an FN is executed before the DEF statement which defines it, an
                            <code>UNDEF'D FUNCTION</code> error occurs.</p>

                        <p class="example">Examples of FN (User-Defined) Function</p>
                        <blockquote>
                            <code>
                                PRINT FN A(Q)
                                <br>1100 J = FN J(7)+ FN J(9)
                                <br>9990 IF FN B7 (1+1)= 6 THEN END
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="FOR">FOR... TO... [STEP...]</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong>
                            FOR&lt;variable&gt;=&lt;start&gt;TO&lt;limit&gt;[STEP&lt;increment&gt;]
                        </p>

                        <p>
                            <strong>ACTION:</strong> This is a special BASIC statement that lets you easily use a
                            variable as a counter. You must specify certain parameters: the floating-point variable
                            name, its starting value, the limit of the count,
                            and how much to add during each cycle.</p>
                        <p>Here is a simple BASIC program that counts from 1 to 10, PRINTing each number and ENDing when
                            complete, and using no FOR statements:</p>

                        <blockquote>
                            <code>
                                100 L = 1
                                <br>110 PRINT L
                                <br>120 L = 1 + 1
                                <br>130 IF L=1 0 THEN 110
                                <br>140 END
                            </code>
                        </blockquote>

                        <p>Using the FOR statement, here is the same program:</p>

                        <blockquote>
                            <code>
                                100 FOR L = 1 TO 10
                                <br>110 PRINT L
                                <br>120 NEXT L
                                <br>130 END
                            </code>
                        </blockquote>

                        <p>As you can see, the program is shorter and easier to understand using the FOR statement.</p>
                        <p>When the FOR statement is executed, several operations take place. The &lt;start&gt; value is
                            placed in the &lt;variable&gt; being used in the counter. In the example above, a 1 is
                            placed in L.
                        </p>
                        <p>When the NEXT statement is reached, the &lt;increment&gt; value is added to the
                            &lt;variable&gt;. If a STEP was not included, the &lt;increment&gt; is set to + 1. The first
                            time the program above hits line 120, 1 is added to L,
                            so the new value of L is 2.</p>
                        <p>Now the value in the &lt;variable&gt; is compared to the &lt;limit&gt;. If the &lt;limit&gt;
                            has not been reached yet, the program G0es TO the line after the original FOR statement. In
                            this case, the value of 2 in L is less than
                            the limit of 10, so it GOes TO line 110.</p>
                        <p>Eventually, the value of &lt;limit&gt; is exceeded by the &lt;variable&gt;. At that time, the
                            loop is concluded and the program continues with the line following the NEXT statement. In
                            our example, the value of L reaches 11, which
                            exceeds the limit of 10, and the program goes on with line 130.
                        </p>
                        <p>When the value of &lt;increment&gt; is positive, the &lt;variable&gt; must exceed the
                            &lt;limit&gt;, and when it is negative it must become less than the &lt;limit&gt;.</p>
                        <p>
                            <strong>NOTE:</strong> A loop always executes at least once.</p>

                        <p class="example"> Examples of FOR... TO... STEP... Statement</p>
                        <blockquote>
                            <code>
                                100 FOR L = 100 TO 0 STEP -1
                                <br>100 FOR L = PI TO 6* {pi} STEP .01
                                <br>100 FOR AA = 3 TO 3
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="FRE">FRE</h5>

                        <p>
                            <strong>TYPE:</strong> Function</p>
                        <p>
                            <strong>FORMAT:</strong> FRE(&lt;variable&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> This function tells you how much RAM is available for your program
                            and its variables. If a program tries to use more space than is available, the
                            <code>OUT OF MEMORY</code> error results.</p>

                        <p>The number in parentheses can have any value, and it is not used in the calculation.</p>

                        <p>
                            <strong>NOTE:</strong> If the result of FRE is negative, add 65536 to the FRE number to get
                            the number of bytes available in memory.</p>

                        <p class="example">Examples of FRE Function</p>

                        <blockquote>
                            <code>
                                PRINT FRE(0)
                                <br>10 X = (FRE(K)-1000)/7
                                <br>950 IF FRE(0)
                                <br>100 THEN PRINT "NOT ENOUGH ROOM"
                            </code>
                        </blockquote>

                        <p>
                            <strong>NOTE:</strong> The following always tells you the current available RAM:</p>

                        <blockquote>
                            <code>
                                PRINT FRE(0)-(FRE(0)&lt;0)*65536
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="GET">GET</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> GET &lt;variable list&gt;</p>

                        <p>
                            <strong>ACTION:</strong> This statement reads each key typed by the user. As the user is
                            typing, the characters are stored in the Commodore 64's keyboard buffer. Up to 10 characters
                            are stored here, and any keys struck after
                            the 10th are lost. Reading one of the characters with the GET statement makes room for
                            another character.</p>
                        <p>If the GET statement specifies numeric data, and the user types a key other than a number,
                            the message
                            <code>?SYNTAX ERROR</code> appears. To be safe, read the keys as strings and convert them to
                            numbers later.
                        </p>
                        <p>The GET statement can be used to avoid some of the limitations of the INPUT statement. For
                            more on this, see the section on Using the GET Statement in the Programming Techniques
                            section.
                        </p>

                        <p class="example">Examples of GET Statement</p>
                        <blockquote>
                            <code>
                                10 GET A$: IF A$ ="" THEN 10: REM LOOPS IN 10 UNTIL ANY KEY HIT
                                <br>20 GET A$, B$, C$, D$, E$: REM READS 5 KEYS
                                <br>30 GET A, A$
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="GET_Hash">GET#</h5>

                        <p>
                            <strong>TYPE:</strong> I/O Statement</p>
                        <p>
                            <strong>FORMAT:</strong> GET# &lt;file number&gt;,&lt;variable list&gt;</p>

                        <p>
                            <strong>ACTION:</strong> This statement reads characters one-at-a-time from the device or
                            file specified. It works the same as the GET statement, except that the data comes from a
                            different place than the keyboard. If no character
                            is received, the variable is set to an empty string (equal to "") or to 0 for numeric
                            variables. Characters used to separate data in files, like the comma (,) or &lt;RETURN&gt;
                            key code (ASC code of 13), are received like any
                            other character.</p>
                        <p> When used with device #3 (TV screen), this statement will read characters one by one from
                            the screen. Each use of GET# moves the cursor 1 position to the right. The character at the
                            end of the logical line is changed to a CHR$
                            (13), the &lt;RETURN&gt; key code.</p>

                        <p class="example">Examples of GET Statement</p>
                        <blockquote>
                            <code>
                                5 GET#1, A$
                                <br>10 OPEN 1,3: GET#1, Z7$
                                <br>20 GET#1, A, B, C$, D$
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="GOSUB">GOSUB</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT</strong> GOSUB &lt;line number&gt;</p>

                        <p>
                            <strong>ACTION:</strong> his is a specialized form of the GOTO statement, with one important
                            difference: GOSUB remembers where it came from. When the RETURN statement (different from
                            the &lt;RETURN&gt; key on the keyboard)
                            is reached in the program, the program jumps back to the statement immediately following the
                            original GOSUB statement.</p>
                        <p>The major use of a subroutine (GOSUB really means GO to a SUBroutine) is when a small section
                            of program is used by different sections of the program. By using subroutines rather than
                            repeating the same lines over and over at different
                            places in the program, you can save lots of program space. In this way, GOSUB is similar to
                            DEF FN. DEF FN lets you save space when using a formula, while GOSUB saves space when using
                            a several-line routine. Here is an inefficient
                            program that doesn't use GOSUB:</p>

                        <blockquote>
                            <code>
                                100 PRINT "THIS PROGRAM PRINTS"
                                <br>110 FOR L = 1 TO 500:NEXT
                                <br>120 PRINT "SLOWLY ON THE SCREEN"
                                <br>130 FOR L = 1 TO 500:NEXT
                                <br>140 PRINT "USING A SIMPLE LOOP"
                                <br>150 FOR L = 1 TO 500:NEXT
                                <br>160 PRINT "AS A TIME DELAY."
                                <br>170 FOR L = 1 TO 500:NEXT
                            </code>
                        </blockquote>

                        <p>Here is the same program using GOSUB:</p>

                        <blockquote>
                            <code>
                                100 PRINT "THIS PROGRAM PRINTS"
                                <br>110 GOSUB 200
                                <br>120 PRINT "SLOWLY ON THE SCREEN"
                                <br>130 GOSUB 200
                                <br>140 PRINT "USING A SIMPLE LOOP"
                                <br>150 GOSUB 200
                                <br>160 PRINT "AS A TIME DELAY."
                                <br>170 GOSUB 200
                                <br>180 END
                                <br>200 FOR L = 1 TO 500 NEXT
                                <br>210 RETURN
                            </code>
                        </blockquote>

                        <p>Each time the program executes a GOSUB, the line number and position in the program line are
                            saved in a special area called the "stack," which takes up 256 bytes of your memory. This
                            limits the amount of data that can be stored
                            in the stack. Therefore, the number of subroutine return addresses that can be stored is
                            limited, and care should be taken to make sure every GOSUB hits the corresponding RETURN, or
                            else you'll run out of memory even though
                            you have plenty of bytes free.</p>

                        <hr>

                        <h5 id="GOTO">GOTO</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> GOTO &lt;line number&gt; or GO TO &lt;line number&gt;</p>

                        <p>
                            <strong>ACTION:</strong> This statement allows the BASIC program to execute lines out of
                            numerical order. The word GOTO followed by a number will make the program jump to the line
                            with that number. GOTO NOT followed by a number
                            equals GOTO 0. It must have the line number after the word GOTO.
                        </p>
                        <p>It is possible to create loops with GOTO that will never end. The simplest example of this is
                            a line that GOes TO itself, like 10 GOTO 10. These loops can be stopped using the
                            &lt;RUN/STOP&gt; key on the keyboard.</p>

                        <p class="example">Examples of GOTO Statement</p>
                        <blockquote>
                            <code>
                                GOTO 100
                                <br>10 GO TO 50
                                <br>20 GOTO 999
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="IF">IF...THEN...</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> IF &lt;expression&gt; THEN &lt;line number&gt;
                            <br>IF &lt;expression&gt; GOTO &lt;line number&gt;
                            <br>IF &lt;expression&gt; THEN &lt;statements&gt;</p>

                        <p>
                            <strong>ACTION:</strong> This is the statement that gives BASIC most of its "intelligence,"
                            the ability to evaluate conditions and take different actions depending on the outcome.</p>
                        <p>The word IF is followed by an expression, which can include variables, strings, numbers,
                            comparisons, and logical operators. The word THEN appears on the same line and is followed
                            by either a line number or one or more BASIC statements.
                            When the expression is false, everything after the word THEN on that line is ignored, and
                            execution continues with the next line number in the program. A true result makes the
                            program either branch to the line number after
                            the word THEN or execute whatever other BASIC statements are found on that line.
                        </p>

                        <p class="example">Example of IF...GOTO... Statement</p>
                        <blockquote>
                            <code>
                                100 INPUT "TYPE A NUMBER"; N
                                <br>110 IF N &lt;= 0 GOTO 200
                                <br>120 PRINT "SQUARE ROOT=" SQR(N)
                                <br>130 GOTO 100
                                <br>200 PRINT "NUMBER MUST BE &gt;0"
                                <br>210 GOTO 100
                            </code>
                        </blockquote>

                        <p>This program prints out the square root of any positive number. The IF statement here is used
                            to validate the result of the INPUT. When the result of N &lt;=0 is true, the program skips
                            to line 200, and when the result is false
                            the next line to be executed is 120. Note that THEN GOTO is not needed with IF...THEN, as in
                            line 110 where GOTO 200 actually means THEN GOTO 200.</p>

                        <p class="example">Example of IF...THEN... Statement</p>
                        <blockquote>
                            <code>
                                100 FOR L = 1 TO 100
                                <br>110 IF RND(1).5 THEN X=X+1: GOTO 130
                                <br>120 Y=Y+1
                                <br>130 NEXT L
                                <br>140 PRINT "HEADS=" X
                                <br>150 PRINT "TAILS= " Y
                            </code>
                        </blockquote>

                        <p>The IF in line 110 tests a random number to see if it is less than .5. When the result is
                            true, the whole series of statements following the word THEN are executed: first X is
                            incremented by 1, then the program skips to line 130.
                            When the result is false, the program drops to the next statement, line 120.</p>

                        <hr>

                        <h5 id="INPUT">INPUT</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> INPUT["&lt;prompt&gt;;"]&lt;variable list&gt;</p>

                        <p>
                            <strong>ACTION:</strong> This is a statement that lets the person RUNning the program "feed"
                            information into the computer. When executed, this statement PRINTs a question mark (?) on
                            the screen, and positions the cursor 1
                            space to the right of the question mark. Now the computer waits, cursor blinking, for the
                            operator to type in the answer and press the &lt;RETURN&gt; key.
                        </p>
                        <p>The word INPUT may be followed by any text contained in quote marks (""). This text is
                            PRINTed on the screen, followed by the question mark.</p>
                        <p>After the text comes a semicolon (;) and the name of one or more variables separated by
                            commas. This variable is where the computer stores the information that the operator types.
                            The variable can be any legal variable name, and
                            you can have several different variable names, each for a different input.
                        </p>

                        <p class="example">Examples of INPUT Statement</p>
                        <blockquote>
                            <code>
                                100 INPUT A
                                <br>110 INPUT B, C, D
                                <br>120 INPUT "PROMPT"; E
                            </code>
                        </blockquote>

                        <p>When this program RUNs, the question mark appears to prompt the operator that the Commodore
                            64 is expecting an input for line 100. Any number typed in goes into A, for later use in the
                            program. If the answer typed was not a number,
                            the
                            <code>?REDO FROM START</code> message appears, which means that a string was received when a
                            number was expected.</p>
                        <p>If the operator just hits &lt;RETURN&gt; without typing anything, the variable's value
                            doesn't change.
                        </p>
                        <p>Now the next question mark, for line 110, appears. If we type only one number and hit the
                            &lt;RETURN&gt;, Commodore 64 will now display 2 question marks (??), which means that more
                            input is required. You can just type as many inputs
                            as you need separated by commas, which prevents the double question mark from appearing. If
                            you type more data than the INPUT statement requested, the
                            <code>?EXTRA IGNORED</code> message appears, which means that the extra items you typed were
                            not put into any variables.</p>
                        <p>Line 120 displays the word PROMPT before the question mark appears. The semicolon is required
                            between the prompt and any list of variables.</p>
                        <p>The INPUT statement can never be used outside a program. The Commodore 64 needs space for a
                            buffer for the INPUT variables, the same space that is used for commands.</p>

                        <hr>

                        <h5 id="INPUT_Hash">INPUT#</h5>

                        <p>
                            <strong>TYPE:</strong> I/O Statement</p>
                        <p>
                            <strong>FORMAT:</strong> INPUT# &lt;file number&gt;,&lt;variable list&gt;</p>

                        <p>
                            <strong>ACTION:</strong> This is usually the fastest and easiest way to retrieve data stored
                            in a file on disk or tape. The data is in the form of whole vvariables of up to 80
                            characters in length, as opposed to the one-at-a-time
                            method of GET#. First, the file must have been OPENed, then INPUT# can fill the variables.
                        </p>
                        <p>The INPUT# command assumes a variable is finished when it reads a RETURN code (CHR$ (13)), a
                            comma (,), semicolon (;), or colon (:). Quote marks can be used to enclose these characters
                            when writing if they are needed (see PRINT#
                            statement).</p>
                        <p>If the variable type used is numeric, and non-numeric characters are received, a
                            <code>BAD DATA</code> error results. INPUT# can read strings up to 80 characters long,
                            beyond which a
                            <code>STRING TOO LONG</code> error results.</p>
                        <p>When used with device #3 (the screen), this statement will read an entire logical line and
                            move the cursor down to the next line.</p>

                        <p class="example">Examples of INPUT# Statement</p>
                        <blockquote>
                            <code>
                                10 INPUT#1,A
                                <br>20 INPUT#2,A$,B$
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="INT">INT</h5>

                        <p>
                            <strong>TYPE:</strong> Integer Function</p>
                        <p>
                            <strong>FORMAT:</strong> INT(&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> Returns the integer value of the expression. If the expression is
                            positive, the fractional part is left off. If the expressions is negative, any fraction
                            causes the next lower integer to be returned.</p>

                        <p class="example">Examples of INT Function</p>
                        <blockquote>
                            <code>
                                120 PRINT INT(99.4343), INT(-12.34)
                                <br>99 -13
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="LEFT$">LEFT$</h5>

                        <p>
                            <strong>TYPE:</strong> String Function</p>
                        <p>
                            <strong>FORMAT:</strong> LEFT$(&lt;string&gt;,&lt;integer&gt;</p>

                        <p>
                            <strong>ACTION:</strong> Returns a string comprised of the leftmost &lt;integer&gt;
                            characters of the &lt;string&gt;. The integer argument value must be in the range 0 to 255.
                            If the integer is greater than the length of the
                            string, the entire string will be returned. If an &lt;integer&gt; value of zero is used,
                            then a null string (of zero length) is returned.
                        </p>

                        <p class="example">Examples of LEFT$ Function</p>
                        <blockquote>
                            <code>
                                10 A$ = "COMMODORE COMPUTERS"
                                <br>20 B$ = LEFT$(A$,9): PRINT B$
                                <br>RUN
                                <br>
                                <br>COMMODORE
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="LEN">LEN</h5>

                        <p>
                            <strong>TYPE:</strong> Integer Function</p>
                        <p>
                            <strong>FORMAT:</strong> LEN(&lt;string&gt;)</p>

                        <p>
                            <strong>ACTION</strong> Returns the number of characters in the string expression.
                            Non-printed characters and blanks are counted.</p>

                        <p class="example">Example of LEN Function</p>
                        <blockquote>
                            <code>
                                CC$ = "COMMODORE COMPUTER": PRINT LEN(CC$)
                                <br>
                                <br>18
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="LET">LET</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> [LET] &lt;variable&gt; = &lt;expression&gt;</p>

                        <p>
                            <strong>ACTION:</strong> The LET statement can be used to assign a value to a variable. But
                            the word LET is optional and therefore most advanced programmers leave LET out because it's
                            always understood and wastes valuable memory.
                            The equal sign (=) alone is sufficient when assigning the value of an expression to a
                            variable name.</p>

                        <p class="example">Examples of LET Statement</p>
                        <blockquote>
                            <code>
                                10 LET D= 12
                                <br>20 LET E$ = "ABC"
                                <br>30 F$ = "WORDS"
                                <br>40 SUM$= E$ + F$
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="LIST">LIST</h5>

                        <p>
                            <strong>TYPE:</strong> Command</p>
                        <p>
                            <strong>FORMAT:</strong> LIST [[&lt;first line&gt;]-[&lt;last line&gt;]]</p>

                        <p>
                            <strong>ACTION:</strong> The LIST command allows you to look at lines of the BASIC program
                            currently in the memory of your Commodore 64. This lets you use your computer's powerful
                            screen editor, to edit programs which you've
                            LISTed both quickly and easily.</p>
                        <p>The LIST system command displays all or part of the program that is currently in memory on
                            the default output device. The LIST will normally be directed to the screen and the CMD
                            statement can be used to switch output to an external
                            device such as a printer or a disk. The LIST command can appear in a program, but BASIC
                            always returns to the system READY message after a LIST is executed.
                        </p>
                        <p> When you bring the program LIST onto the screen, the "scrolling" of the display from the
                            bottom of the screen to the top can be slowed by holding down the &lt;CTRL&gt; key. LIST is
                            aborted by typing the &lt;RUN/STOP&gt; key.</p>
                        <p>If no line-numbers are given the entire program is listed. If only the first-line number is
                            specified, and followed by a hyphen (-), that line and all higher-numbered lines are listed.
                            If only the last line-number is specified,
                            and it is preceded by a hyphen, then all lines from the beginning of the program through
                            that line are listed. If both numbers are specified, the entire range, including the
                            line-numbers LISTed, is displayed.
                        </p>

                        <p class="example">Examples of LIST Command</p>
                        <blockquote>
                            <pre>
    LIST            (Lists the program currently in memory.)
    LIST 500        (Lists line 500 only.)                      
    LIST 150-       (Lists all lines from 150 to the end.)
    LIST -1000      (Lists all lines from the lowest through 1000.)
    LIST 150-1000   (Lists lines 150 through 1000, inclusive.)

    10 PRINT "THIS  IS LINE 10"
    20 LIST                             (LIST used in Program Mode)
    30 PRINT "THIS  IS LINE 30"                               
                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="LOAD">LOAD</h5>

                        <p>
                            <strong>TYPE:</strong> Command</p>
                        <p>
                            <strong>FORMAT:</strong> LOAD[&lt;"file-name"&gt;],[&lt;device&gt;],[&lt;address&gt;]</p>

                        <p>
                            <strong>ACTION:</strong> The LOAD statement reads the contents of a program file from tape
                            or disk into memory. That way you can use the information LOADed or change the information
                            in some way. The device number is optional,
                            but when it is left out the computer will automatically default to 1, the cassette unit. The
                            disk unit is normally device number 8. The LOAD closes all open files and, if it is used in
                            direct mode, it performs a CLR (clear)
                            before reading the program. If LOAD is executed from within a program, the program is RUN.
                            This means that you can use LOAD to "chain" several programs together. None of the variables
                            are cleared during a chain operation.</p>
                        <p> If you are using file-name pattern matching, the first file which matches the pattern is
                            loaded. The asterisk in quotes by itself ("*") causes the first file-name in the disk
                            directory to be loaded. If the filename used does not
                            exist or if it is not a program file, the BASIC error message
                            <code>?FILE NOT FOUND</code> occurs.</p>
                        <p>When LOADing programs from tape, the &lt;file-name&gt; can be left out, and the next program
                            file on the tape will be read. The Commodore 64 will blank the screen to the border color
                            after the PLAY key is pressed. When the program
                            is found, the screen clears to the background color and the "FOUND" message is displayed.
                            When the &lt;CMDRE&gt; key, &lt;CTRL&gt; key, &lt;ARROW LEFT&gt; key, or &lt;SPACE BAR&gt;
                            is pressed, the file will be loaded. Programs
                            will LOAD starting at memory location 2048 unless a secondary &lt;address&gt; of 1 is used.
                            If you use the secondary address of 1 this will cause the program to LOAD to the memory
                            location from which it was saved.
                        </p>

                        <p class="example">Examples of LOAD Command</p>
                        <blockquote>
                            <code>
                                LOAD
                                <br>LOAD A$
                                <br>LOAD"*",8
                                <br>LOAD"",1,1
                                <br>
                                <br>LOAD"STAR TREK"
                                <br>PRESS PLAY ON TAPE
                                <br>FOUND STAR TREK
                                <br>LOADING
                                <br>READY.
                                <br>
                                <br>LOAD"FUN",8
                                <br>SEARCHING FOR FUN
                                <br>LOADING
                                <br>READY.
                                <br>
                                <br>LOAD"GAME ONE",8,1
                                <br>SEARCHING FOR GAME ONE
                                <br>LOADING
                                <br>READY.
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="LOG">LOG</h5>

                        <p>
                            <strong>TYPE:</strong> Floating-Point Function</p>
                        <p>
                            <strong>FORMAT:</strong> LOG(&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> Returns the natural logarithm (log to the base of e) of the
                            argument. If the value of the argument is zero or negative the BASIC error message
                            <code>?ILLEGAL QUANTITY</code> will occur.</p>

                        <p class="example">Examples of LOG Function</p>
                        <blockquote>
                            <code>
                                25 PRINT LOG(45/7)
                                <br>1.86075234
                                <br>
                                <br>10 NUM=LOG(ARG)/LOG(10) REM: CALCULATES LOG OF ARG TO BASE 10
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="MID$">MID$</h5>

                        <p>
                            <strong>TYPE:</strong> String Function</p>
                        <p>
                            <strong>FORMAT:</strong> MID$(&lt;string&gt;,&lt;numeric-1&gt;[,&lt;numeric-2&gt;])</p>

                        <p>
                            <strong>ACTION:</strong> The MID$ function returns a sub-string which is taken from within a
                            larger &lt;string&gt; argument. The starting position of the sub-string is defined by the
                            &gt;numeric-1&gt; argument and the length
                            of the sub-string by the &gt;numeric-2&gt; argument. Both of the numeric arguments can have
                            values ranging from 0 to 255.</p>
                        <p>If the &lt;numeric-1&gt; value is greater than the length of the &lt;string&gt;, or if the
                            &lt;numeric-2&gt; value is zero, then MID$ gives a null string value. If the
                            &lt;numeric-2&gt; argument is left out, then the computer will
                            assume that a length of the rest of the string is to be used. And if the source string has
                            fewer characters than &gt;numeric-2&lt;, from the starting position to the end of the string
                            argument, then the whole rest of the string
                            is used.
                        </p>

                        <p class="example">Example of MID$ Function</p>
                        <blockquote>
                            <code>
                                10 A$="GOOD"
                                <br>20 B$="MORNING EVENING AFTERNOON"
                                <br>30 PRINT A$ + MID$(B$,8,8)
                                <br>
                                <br>GOOD EVENING
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="NEW">NEW</h5>

                        <p>
                            <strong>TYPE:</strong> Command</p>
                        <p>
                            <strong>FORMAT:</strong> NEW</p>

                        <p>
                            <strong>ACTION:</strong> The NEW command is used to delete the program currently in memory
                            and clear all variables. Before typing in a new program, NEW should be used in direct mode
                            to clear memory. NEW can also be used in
                            a program, but you should be aware of the fact that it will erase everything that has gone
                            before and is still in the computer's memory. This can be particularly troublesome when
                            you're trying to debug your program.
                        </p>
                        <p>
                            <strong>BE CAREFUL!</strong> Not clearing out an old program before typing a new one can
                            result in a confusing mix of the two programs.</p>

                        <p class="example">Examples of NEW Command</p>
                        <blockquote>
                            <code>
                                NEW
                                <br>10 NEW
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="NEXT">NEXT</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> NEXT[&lt;counter&gt;] , [&lt;counter&gt;]</p>

                        <p>
                            <strong>ACTION:</strong> The NEXT statement is used with FOR to establish the end of a
                            FOR...NEXT loop. The NEXT need not be physically the last statement in the loop, but it is
                            always the last statement executed in a loop.
                            The &lt;counter&gt; is the loop index's variable name used with FOR to start the loop. A
                            single NEXT can stop several nested loops when it is followed by each FOR's &lt;counter&gt;
                            variable name(s). To do this each name must
                            appear in the order of inner-most nested loop first, to outer-most nested loop last. When
                            using a single NEXT to increment and stop several variable names, each variable name must be
                            separated by commas. Loops can be nested
                            to 9 levels. If the counter variable(s) are omitted, the counter associated with the FOR of
                            the current level (of the nested loops) is incremented.
                        </p>
                        <p>When the NEXT is reached, the counter value is incremented by 1 or by an optional STEP value.
                            It is then tested against an end-value to see if it's time to stop the loop. A loop will be
                            stopped when a NEXT is found which has its
                            counter value greater than the end-value.</p>

                        <p class="example">Examples of NEXT Statement</p>
                        <blockquote>
                            <pre>

                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="NOT">NOT</h5>

                        <p>
                            <strong>TYPE:</strong> Logical Operator</p>
                        <p>
                            <strong>FORMAT:</strong> NOT &lt;expression&gt;</p>

                        <p>
                            <strong>ACTION:</strong> The NOT logical operator "complements" the value of each bit in its
                            single operand, producing an integer "twos-complement" result. In other words, the NOT is
                            really saying, "if it isn't. When working
                            with a floating-point number, the operands are converted to integers and any fractions are
                            lost. The NOT operator can also be used in a comparison to reverse the true/false value
                            which was the result of a relationship test
                            and therefore it will reverse the meaning of the comparison. In the first example below, if
                            the "twos-complement" of "AA" is equal to "BB" and if "BB" is NOT equal to "CC" then the
                            expression is true.</p>

                        <p class="example">Examples of NOT Operator</p>
                        <blockquote>
                            <code>
                                10 IF NOT AA = BB AND NOT(BB = CC) THEN...
                                <br>
                                <br>NN% = NOT 96: PRINT NN%
                                <br>-97
                            </code>
                        </blockquote>

                        <p>
                            <strong>NOTE:</strong> To find the value of NOT, use the expression X=(-(X+1)). (The | two's
                            complement of any integer is the bit complement plus one.)</p>

                        <hr>

                        <h5 id="ON">ON</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> ON &lt;variable&gt; GOTO / GOSUB &lt;line-number&gt; ,
                            [&lt;line-number&gt;]...
                        </p>

                        <p>
                            <strong>ACTION:</strong> The ON statement is used to GOTO one of several given line-numbers,
                            depending upon the value of a variable. The value of the variables can range from zero
                            through the number of lines given. If the value
                            is a non-integer, the fractional portion is left off. For example, if the variable value is
                            3, ON will GOTO the third line-number in the list.
                        </p>
                        <p>If the value of the variable is negative, the BASIC error message
                            <code>?ILLEGAL QUANTITY</code> occurs. If the number is zero, or greater than the number of
                            items in the list, the program just "ignores" the statement and continues with the statement
                            following the ON statement.</p>
                        <p>ON is really an underused variant of the IF...THEN... statement. Instead of using a whole lot
                            of IF statements each of which sends the program to 1 specific line, 1 ON statement can
                            replace a list of IF statements. When you look
                            at the first example you should notice that the 1 ON statement replaces 4 IF...THEN...
                            statements.</p>

                        <p class="example">Examples of ON Statement</p>
                        <blockquote>
                            <code>
                                ON -(A=7)-2*(A=3)-3*(A&lt;3)-4*(A&gt;7)GOTO 400,900,1000,100
                                <br>ON X GOTO 100,130,180,220
                                <br>ON X+3 GOSUB 9000,20,9000
                                <br>100 ON NUM GOTO 150,300,320,390
                                <br>500 ON SUM/2 + 1 GOSUB 50,80,20
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="OPEN">OPEN</h5>

                        <p>
                            <strong>TYPE:</strong> I/O Statement</p>
                        <p>
                            <strong>FORMAT:</strong> OPEN &lt;file-num&gt;,[&lt;device&gt;][,&lt;address&gt;] ,
                            ["&lt;file-name&gt; [,&lt;type>] , [&lt;mode&gt;]"]</p>

                        <p>
                            <strong>ACTION:</strong> This statement OPENs a channel for input and/or output to a
                            peripheral device. However, you may NOT need all those parts for every OPEN statement. Some
                            OPEN statements require only 2 codes:</p>
                        <ol>
                            <li>Logical file number</li>
                            <li>Device number</li>
                        </ol>

                        <p>The &lt;file-num&gt; is the logical file number, which relates the OPEN, CLOSE, CMD, GET#,
                            INPUT#, and PRINT# statements to each other and associates them with the file-name and the
                            piece of equipment being used. The logical file
                            number can range from 1 to 255 and you can assign it any number you want in that range.</p>
                        <p>
                            <strong>NOTE:</strong> File numbers over 128 were really designed for other uses so | | it's
                            good practice to use only numbers below 127 for file numbers.</p>
                        <p>Each peripheral device (printer, disk drive, cassette) in the system has its own number which
                            it answers to. The &lt;device&gt; number is used with OPEN to specify on which device the
                            data file exists. Peripherals like cassette
                            decks, disk drives or printers also answer to several secondary addresses. Think of these as
                            codes which tell each device what operation to perform. The device logical file number is
                            used with every GET#, INPUT#, and PRINT#.</p>
                        <p>If the &lt;device&gt; number is left out the computer will automatically assume that you want
                            your information to be sent to and received from the Datassette(TM), which is device number
                            1. The file-name can also be left out, but
                            later on in your program, you can NOT call the file by name if you have not already given it
                            one. When you are storing files on cassette tape, the computer will assume that the
                            secondary &lt;address&gt; is zero (0) if you omit
                            the secondary address (a READ operation).</p>
                        <p>A secondary address value of one (1) OPENs cassette tape files for writing. A secondary
                            address value of two (2) causes an end-of-tape marker to be written when the file is later
                            closed. The end-of-tape marker prevents accidentally
                            reading past the end of data which results in the BASIC error message
                            <code>?DEVICE NOT PRESENT</code>.</p>
                        <p>For disk files, the secondary addresses 2 thru 14 are available for data-files, but other
                            numbers have special meanings in DOS commands. You must use a secondary address when using
                            your disk drive(s). (See your disk drive manual
                            for DOS command details.)</p>
                        <p>The &lt;file-name&gt; is a string of 1-16 characters and is optional for cassette or printer
                            files. If the file &lt;type&gt; is left out the type of file will automatically default to
                            the Program file unless the &lt;mode&gt; is
                            given.
                        </p>
                        <p>Sequential files are OPENed for reading &lt;mode&gt;=R unless you specify that files should
                            be OPENed for writing &lt;mode&gt;=W is specified. A file &lt;type&gt; can be used to OPEN
                            an existing Relative file. Use REL for &lt;type&gt;
                            with Relative files. Relative and Sequential files are for disk only.</p>
                        <p>If you try to access a file before it is OPENed the BASIC error message
                            <code>?FILE NOT OPEN</code> will occur. If you try to OPEN a file for reading which does not
                            exist the BASIC error message
                            <code>?FILE NOT FOUND</code> will occur. If a file is OPENed to disk for writing and the
                            file-name already exists, the DOS error message
                            <code>FILE EXISTS</code> occurs. There is no check of this type available for tape files, so
                            be sure that the tape is properly positioned or you might accidentally write over some data
                            that had previously been SAVED. If a file
                            is OPENed that is already OPEN, the BASIC error message
                            <code>FILE OPEN</code> occurs. (See Printer Manual for further details.)</p>

                        <p class="example">Examples of OPEN Statement</p>
                        <blockquote>
                            <pre>
    10 OPEN 2,8,4,"DISK-OUTPUT,SEQ,W"  (Opens sequential file on disk)

    10 OPEN 1,1,2,"TAPE-WRITE"         (Write End-of-File on Close)

    10 OPEN 50,0                       (Keyboard input)

    10 OPEN 12,3                       (Screen output)

    10 OPEN 130,4                      (Printer output)

    10 OPEN 1,1,0,"NAME"               (Read from cassette)

    10 OPEN 1,1,1,"NAME"               (Write to cassette)

    10 OPEN 1,2,0,CHR$(10)             (open channel to RS-232 device)

    10 OPEN 1,4,0,"STRING"             (Send upper case/graphics to
                                        the printer)

    10 OPEN 1,4,7,"STRING"             (Send upper/lower case to
                                        printer)

    10 OPEN 1,5,7,"STRING"             (Send upper/lower case to
                                        printer with device # 5)

    10 OPEN 1,8,15,"COMMAND"           (Send a command to disk)
                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="OR">OR</h5>

                        <p>
                            <strong>TYPE:</strong> Logical Operator</p>
                        <p>
                            <strong>FORMAT:</strong> &lt;operand&gt; OR &lt;operand&gt;</p>

                        <p>
                            <strong>ACTION:</strong> Just as the relational operators can be used to make decisions
                            regarding program flow, logical operators can connect two or more relations and return a
                            true or false value which can then be used in
                            a decision. When used in calculations, the logical OR gives you a bit result of I if the
                            corresponding bit of either or both operands is 1. This will produce an integer as a result
                            depending on the values of the operands. When
                            used in comparisons the logical OR operator is also used to link two expressions into a
                            single compound expression. If either of the expressions are true, the combined expression
                            value is true (-1). In the first example below
                            if AA is equal to BB OR if XX is 20, the expression is true.</p>
                        <p>Logical operators work by converting their operands to 16-bit, signed, two's complement
                            integers in the range of -32768 to +32767. If the operands are not in the range an error
                            message results. Each bit of the result is determined
                            by the corresponding bits in the two operands.
                        </p>

                        <p class="example">Examples of OR Operator</p>
                        <blockquote>
                            <pre>
100 IF (AA=BB) OR (XX=20)
230 KK%=64 OR 32: PRINT KK%         (You typed this with a bit
                                     value of 1000000 for 64
                                     and 100000 for 32)

96                                  (The computer responded with
                                     bit value 1100000.
                                     1100000=96.)
                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="PEEK">PEEK</h5>

                        <p>
                            <strong>TYPE:</strong> Integer Function</p>
                        <p>
                            <strong>FORMAT:</strong> PEEK(&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> Returns an integer in the range of 0 to 255, which is read from a
                            memory location. The &lt;numeric&gt; expression is a memory location which must be in the
                            range of 0 to 65535. If it isn't then the
                            BASIC error message
                            <code>?ILLEGAL QUANTITY</code> occurs.</p>

                        <p class="example">Examples of PEEK Function</p>
                        <blockquote>
                            <pre>
10 PRINT PEEK(53280) AND 15   (Returns value of screen border color)

5 A%=PEEK(45)+PEEK(46)*256    (Returns address of BASIC variable table)
                            </pre>
                        </blockquote>

                        <h5 id="POKE">POKE</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> POKE &lt;location&gt;,&lt;value&gt;</p>

                        <p>
                            <strong>ACTION:</strong> The POKE statement is used to write a one-byte (8-bits) binary
                            value into a given memory location or input/output register. The &lt;location&gt; is an
                            arithmetic expression which must equal a value
                            in the range of 0 to 65535. The &lt;value&gt; is an expression which can be reduced to an
                            integer value of 0 to 255. If either value is out of its respective range, the BASIC error
                            message
                            <code>?ILLEGAL QUANTITY</code> occurs.</p>
                        <p>The POKE statement and PEEK statement (which is a built-in function that looks at a memory
                            location) are useful for data storage, controlling graphics displays or sound generation,
                            loading assembly language subroutines, and passing
                            arguments and results to and from assembly language subroutines. In addition, Operating
                            System parameters can be examined using PEEK statements or changed and manipulated using
                            POKE statements. A complete memory map of useful
                            locations is given in Appendix G.
                        </p>

                        <p class="example">Examples of POKE Statement</p>
                        <pre>
POKE 1024, 1         (Puts an "A" at position 1 on the screen)
POKE 2040, PTR       (Updates Sprite #0 data pointer)
                        </pre>
                        <code>
                            10 POKE RED,32
                            <br>20 POKE 36879,8
                            <br>2050 POKE A,B
                        </code>

                        <hr>

                        <h5 id="POS">POS</h5>

                        <p>
                            <strong>TYPE:</strong> Integer Function</p>
                        <p>
                            <strong>FORMAT:</strong> POS(&lt;dummy&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> Tells you the current cursor position which, of course, is in the
                            range of 0 (leftmost character) though position 79 on an 80-character logical screen line.
                            Since the Commodore 64 has a 40-column screen,
                            any position from 40 through 79 will refer to the second screen line. The dummy argument is
                            ignored.</p>

                        <p class="example">Example of POS Function</p>
                        <blockquote>
                            <code>
                                1000 IF POS(0)&gt;38 THEN PRINT CHR$(13)
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="PRINT">PRINT</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> PRINT[&lt;variable&gt;][&lt;,/;&gt;&lt;variable&gt;]...</p>

                        <p>
                            <strong>ACTION:</strong> The PRINT statement is normally used to write data items to the
                            screen. However, the CMD statement may be used to re-direct that output to any other device
                            in the system. The &lt;variable(s)&gt; in
                            the output-list are expressions of any type. If no output-list is present, a blank line is
                            printed. The position of each printed item is determined by the punctuation used to separate
                            items in the output-list.</p>
                        <p>The punctuation characters that you can use are blanks, commas, or semicolons. The
                            80-character logical screen line is divided into 8 print zones of 10 spaces each. In the
                            list of expressions, a comma causes the next value to be
                            printed at the beginning of the next zone. A semicolon causes the next value to be printed
                            immediately following the previous value. However, there are two exceptions to this rule:
                        </p>

                        <ol>
                            <li>Numeric items are followed by an added space.</li>
                            <li>Positive numbers have a space preceding them.</li>
                        </ol>

                        <p>When you use blanks or no punctuation between string constants or variable names it has the
                            same effect as a semicolon. However, blanks between a string and a numeric item or between
                            two numeric items will stop output without printing
                            the second item.</p>
                        <p>If a comma or a semicolon is at the end of the output-list, the next PRINT statement begins
                            printing on the same line, and spaced accordingly. If no punctuation finishes the list, a
                            carriage-return and a line-feed are printed at
                            the end of the data. The next PRINT statement will begin on the next line. If your output is
                            directed to the screen and the data printed is longer than 40 columns, the output is
                            continued on the next screen line.</p>
                        <p>There is no statement in BASIC with more variety than the PRINT statement. There are so many
                            symbols, functions, and parameters associated with this statement that it might almost be
                            considered as a language of its own within BASIC;
                            a language specially designed for writing on the screen.
                        </p>

                        <p class="example">Examples of PRINT Statement</p>
                        <ol>
                            <li>
                                <code>
                                    5 X = 5
                                    <br>10 PRINT -5*X,X-5,X+5,X^5
                                    <br>
                                    <br>-25 0 10 3125
                                </code>
                            </li>
                            <li>
                                <code>
                                    5 X=9
                                    <br>10 PRINT X;"SQUARED IS";X*X;"AND";
                                    <br>20 PRINT X "CUBED IS" X^3
                                    <br>
                                    <br>9 SQUARED IS 81 AND 9 CUBED IS 729
                                </code>
                            </li>
                            <li>
                                <code>
                                    90 AA$="ALPHA":BB$="BAKER":CC$="CHARLIE":DD$="DOG":EE$="ECHO"
                                    <br>100 PRINT AA$BB$;CC$ DD$,EE$
                                    <br>
                                    <br>ALPHABAKERCHARLIEDOG ECHO
                                </code>
                            </li>
                        </ol>

                        <h5>Quote Mode</h5>

                        <p>Once the quote mark &lt;SHIFT+2&gt; is typed, the cursor controls stop operating and start
                            displaying reversed characters which actually stand for the cursor control you are hitting.
                            This allows you to program these cursor controls,
                            because once the text inside the quotes is PRINTed they perform their functions. The
                            &lt;INST/DEL&gt; key is the only cursor control not affected by "quote mode."</p>
                        <p>
                            <strong>1. Cursor Movement</strong>
                        </p>
                        <p>The cursor controls which can be "programmed" in quote mode are:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Key</th>
                                    <th>Appears As</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>&lt;CLR/HOME&gt;</td>
                                    <td class="screen">S</td>
                                </tr>
                                <tr>
                                    <td>&lt;SHIFT+CLR/HOME&gt;</td>
                                    <td class="screen">&hearts;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CRSR UP/DOWN&gt;</td>
                                    <td class="screen">Q</td>
                                </tr>
                                <tr>
                                    <td>&lt;SHIFT+CRSR UP/DOWN&gt;</td>
                                    <td class="screen">&#9679;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CRSR LEFT/RIGHT&gt;</td>
                                    <td class="screen">]</td>
                                </tr>
                                <tr>
                                    <td>&lt;SHIFT+CRSR LEFT/RIGHT&gt;</td>
                                    <td class="screen">|</td>
                                </tr>
                            </tbody>
                        </table>
                        <p>
                            <strong>NOTE:</strong> All characters listed above will be reverse characters.</p>

                        <p>If you wanted the word HELLO to PRINT diagonally from the upper left corner of the screen,
                            you would type:
                        </p>

                        <blockquote>
                            <code>PRINT"&lt;HOME&gt;H&lt;DOWN&gt;E&lt;DOWN&gt;L&lt;DOWN&gt;L&lt;DOWN&gt;O"</code>
                        </blockquote>

                        <p>
                            <strong>2. Reverse Characters</strong>
                        </p>

                        <p>Holding down the &lt;CTRL&gt; key and hitting &lt;9&gt; will cause &lt;R&gt; to appear inside
                            the quotes. This will make all characters start printing in reverse video (like a negative
                            of a picture). To end the reverse printing
                            hit &lt;CTRL+0&gt;, or else PRINT a &lt;RETURN&gt; (CHR$(13)). (Just ending the PRINT
                            statement without a semicolon or comma will take care of this.)</p>

                        <p>
                            <strong>3. Color Controls</strong>
                        </p>

                        <p>Holding down the &lt;CTRL&gt; key or &lt;CMDRE&gt; key with any of the 8 color keys will make
                            a special reversed character appear in the quotes. When the character is PRINTed, then the
                            color change will occur.</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Key</th>
                                    <th>Color</th>
                                    <th>Displays As</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>&lt;CTRL+1&gt;</td>
                                    <td>Black</td>
                                    <td class="screen">&#9488;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CTRL+2&gt;</td>
                                    <td>White</td>
                                    <td class="screen">E</td>
                                </tr>
                                <tr>
                                    <td>&lt;CTRL+3&gt;</td>
                                    <td>Red</td>
                                    <td class="screen">&pound;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CTRL+4&gt;</td>
                                    <td>Cyan</td>
                                    <td class="screen">&#9699;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CTRL+5&gt;</td>
                                    <td>Purple</td>
                                    <td class="screen">&#9617;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CTRL+6&gt;</td>
                                    <td>Green</td>
                                    <td class="screen">&uarr;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CTRL+7&gt;</td>
                                    <td>Blue</td>
                                    <td class="screen">&larr;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CTRL+8&gt;</td>
                                    <td>Yellow</td>
                                    <td class="screen">&pi;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CMDRE+1&gt;</td>
                                    <td>Orange</td>
                                    <td class="screen">&spades; </td>
                                </tr>
                                <tr>
                                    <td>&lt;CMDRE+2&gt;</td>
                                    <td>Brown</td>
                                    <td class="screen">&#9581;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CMDRE+3&gt;</td>
                                    <td>Light Red</td>
                                    <td class="screen">&#9587;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CMDRE+4&gt;</td>
                                    <td>Grey 1</td>
                                    <td class="screen">&#9711;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CMDRE+5&gt;</td>
                                    <td>Grey 2</td>
                                    <td class="screen">&clubs;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CMDRE+6&gt;</td>
                                    <td>Light Green</td>
                                    <td class="screen">&#9474;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CMDRE+7&gt;</td>
                                    <td>Light Blue</td>
                                    <td class="screen">&diamondsuit;</td>
                                </tr>
                                <tr>
                                    <td>&lt;CMDRE+8&gt;</td>
                                    <td>Grey 3</td>
                                    <td class="screen">&#9547;</td>
                                </tr>
                            </tbody>
                        </table>
                        <p class="table-note">
                            <strong>NOTE:</strong> Some graphics characters shown above may not look exactly like
                            characters shown on real C64 hardware or in emulation.</p>

                        <p>If you wanted to PRINT the word HELLO in cyan and the word THERE in white, type:</p>

                        <blockquote>
                            <code>PRINT "&lt;CTRL+4&gt;HELLO &lt;CTRL+2&gt;THERE"</code>
                        </blockquote>

                        <p>
                            <strong>4. Insert Mode</strong>
                        </p>

                        <p>The spaces created by using the &lt;INST/DEL&gt; key have some of the same characteristics as
                            quote mode. The cursor controls and color controls show up as reversed characters. The only
                            difference is in the &lt;INST&gt; and &lt;DEL&gt;,
                            which performs its normal function even in quote mode, now creates the &lt;T&gt;. And
                            &lt;INST&gt;, which created a special character in quote mode, inserts spaces normally.</p>
                        <p>Because of this, it is possible to create a PRINT statement containing DELetes, which cannot
                            be PRINTed in quote mode. Here is an example of how this is done:</p>

                        <blockquote>
                            <code>10 PRINT"HELLO"&lt;DEL&gt;&lt;INST&gt;&lt;INST&gt;&lt;DEL&gt;&lt;DEL&gt;P"</code>
                        </blockquote>

                        <p>When the above line is RUN, the word displayed will be HELP, because the last two letters are
                            deleted and the P is put in their place.</p>

                        <p>
                            <strong>WARNING:</strong> The DELetes will work when LISTing as well as PRINTing, so editing
                            a line with these characters will be difficult.</p>

                        <p>The "insert mode" condition is ended when the &lt;RETURN&gt; (or &lt;SHIFT+RETURN&gt;) key is
                            hit, or when as many characters have been typed as spaces were inserted.</p>

                        <p>
                            <strong>5. Other Special Characters</strong>
                        </p>
                        <p>There are some other characters that can be PRINTed for special functions, although they are
                            not easily available from the keyboard. In order to get these into quotes, you must leave
                            empty spaces for them in the line, hit &lt;RETURN&gt;
                            or &lt;SHIFT+RETURN&gt;, and go back to the spaces with the cursor controls. Now you must
                            hit &lt;RVS ON&gt;, to start typing reversed characters, and type the keys shown below:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Function</th>
                                    <th>Type</th>
                                    <th>Appears As</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>&lt;SHIFT+RETURN&gt;</td>
                                    <td>&lt;SHIFT+M&gt;</td>
                                    <td class="screen">&#9586;</td>
                                </tr>
                                <tr>
                                    <td>switch to lower case</td>
                                    <td>&lt;N&gt;</td>
                                    <td class="screen">N</td>
                                </tr>
                                <tr>
                                    <td>switch to upper case</td>
                                    <td>&lt;SHIFT+N&gt;</td>
                                    <td class="screen">&#9585;</td>
                                </tr>
                                <tr>
                                    <td>disable case-switching keys</td>
                                    <td>&lt;H&gt;</td>
                                    <td class="screen">H</td>
                                </tr>
                                <tr>
                                    <td>enable case-switching keys</td>
                                    <td>&lt;I&gt;</td>
                                    <td class="screen">I</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>The &lt;SHIFT+RETURN&gt; will work in the LISTing as well as PRINTing, so editing will be
                            almost impossible if this character is used. The LISTing will also look very strange.</p>

                        <hr>

                        <h5 id="PRINT_Hash">PRINT#</h5>

                        <p>
                            <strong>TYPE:</strong> I/O Statement</p>
                        <p>
                            <strong>FORMAT:</strong>
                            PRINT#&lt;file-number&gt;[&lt;variable&gt;][&lt;,/;&gt;&lt;variable&gt;]...
                        </p>

                        <p>
                            <strong>ACTION:</strong> The PRINT# statement is used to write data items to a logical file.
                            It must use the same number used to OPEN the file. Output goes to the device-number used in
                            the OPEN statement. The &lt;variable&gt;
                            expressions in the output-list can be of any type. The punctuation characters between items
                            are the same as with the PRINT statement and they can be used in the same ways. The effects
                            of punctuation are different in two significant
                            respects.
                        </p>
                        <p>When PRINT# is used with tape files, the comma, instead of spacing by print zones, has the
                            same effect as a semicolon. Therefore, whether blanks, commas, semicolons or no punctuation
                            characters are used between data items, the
                            effect on spacing is the same. The data items are written as a continuous stream of
                            characters. Numeric items are followed by a space and, if positive, are preceded by a space.
                        </p>
                        <p>If no punctuation finishes the list, a carriage-return and a line-feed are written at the end
                            of the data. If a comma or semicolon terminates the output-list, the carriage-return and
                            line-feed are suppressed. Regardless of the
                            punctuation, the next PRINT# statement begins output in the next available character
                            position. The line-feed will act as a stop when using the INPUT# statement, leaving an empty
                            variable when the next INPUT# is executed. The
                            line-feed can be suppressed or compensated for as shown in the examples below.</p>
                        <p>The easiest way to write more than one variable to a file on tape or disk is to set a string
                            variable to CHR$(13), and use that string in between all the other variables when writing
                            the file.
                        </p>

                        <p class="example">Examples of PRINT# Statement</p>
                        <blockquote>
                            <pre>
10 OPEN 1,1,1,"TAPE FILE"
20 R$=CHR$(13)                      (By Changing the CHR$(13) to
30 PRINT#1,1;R$;2;R$;3;R$;4;R$;5     CHR$(44) you put a "," between
40 PRINT#1,6                         each variable. CHR$(59) would
50 PRINT# 1,7                        put a ";" between each variable.)

10 CO$=CHR$(44):CR$=CHR$(13)
20 PRINT#1,"AAA"CO$"BBB",           AAA,BBB     CCCDDDEEE
    "CCC";"DDD";"EEE"CR$            (carriage return)
    "FFF"CR$;                       FFF(carriage return)
30 INPUT#1,A$,BCDE$,F$

5 CR$=CHR$(13)
10 PRINT#2,"AAA";CR$;"BBB"          (10 blanks) AAA
20 PRINT#2,"CCC";                   BBB
                                    (10 blanks)CCC
30 INPUT#2,A$,B$,DUMMY$,C$
                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="READ">READ</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> READ &lt;variable&gt;[,&lt;variable&gt;]...</p>

                        <p>
                            <strong>ACTION:</strong> The READ statement is used to fill variable names from constants in
                            DATA statements. The data actually read must agree with the variable types specified or the
                            BASIC error message
                            <code>?SYNTAX ERROR</code> will result.(*) Variables in the DATA input-list must be
                            separated by commas.</p>
                        <p>A single READ statement can access one or more DATA statements, which will be accessed in
                            order (see DATA), or several READ statements can access the same DATA statement. If more
                            READ statements are executed than the number of
                            elements in DATA statements(s) in the program, the BASIC error message
                            <code>?OUT OF DATA</code> is printed. If the number of variables specified is fewer than the
                            number of elements in the DATA statement(s), subsequent READ statements will continue
                            reading at the next data element. (See RESTORE.)</p>

                        <p>
                            <strong>*NOTE:</strong> The
                            <code>?SYNTAX ERROR</code> will appear with the line number from the | | DATA statement, NOT
                            the READ statement.
                        </p>

                        <p class="example">EXAMPLES of READ Statement:</p>
                        <blockquote>
                            <code>
                                110 READ A,B,C$
                                <br>120 DATA 1,2,HELLO
                                <br>
                                <br>100 FOR X=1 TO 10: READ A(X):NEXT
                                <br>
                                <br>200 DATA 3.08, 5.19, 3.12, 3.98, 4.24
                                <br>210 DATA 5.08, 5.55, 4.00, 3.16, 3.37
                                <br>
                                <br>(Fills array items (line 1) in order of constants shown (line 5))
                                <br>
                                <br>1 READ CITY$,STATE$,ZIP
                                <br>5 DATA DENVER,COLORADO, 80211
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="REM">REM</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> REM [&lt;remark&gt;]</p>

                        <p>
                            <strong>ACTION:</strong> The REM statement makes your programs more easily understood when
                            LISTed. It's a reminder to yourself to tell you what you had in mind when you were writing
                            each section of the program. For instance,
                            you might want to remember what a variable is used for, or some other useful information.
                            The REMark can be any text, word, or character including the colon (:) or BASIC keywords.
                        </p>
                        <p>The REM statement and anything following it on the same line-number are ignored by BASIC, but
                            REMarks are printed exactly as entered when the program is listed. A REM statement can be
                            referred to by a GOTO or GOSUB statement, and
                            the execution of the program will continue with the next higher program line having
                            executable statements.</p>

                        <p class="example">Examples of REM Statement</p>
                        <blockquote>
                            <code>
                                10 REM CALCULATE AVERAGE VELOCITY
                                <br>20 FOR X= 1 TO 20 :REM LOOP FOR TWENTY VALUES
                                <br>30 SUM=SUM + VEL(X): NEXT
                                <br>40 AVG=SUM/20
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="RESTORE">RESTORE</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> RESTORE</p>

                        <p>
                            <strong>ACTION:</strong> BASIC maintains an internal pointer to the next DATA constant to be
                            READ. This pointer can be reset to the first DATA constant in a program using the RESTORE
                            statement. The RESTORE statement can be
                            used anywhere in the program to begin re-READing DATA.
                        </p>

                        <p class="example">Examples of RESTORE Statement</p>
                        <blockquote>
                            <code>
                                100 FOR X=1 TO 10: READ A(X): NEXT
                                <br>200 RESTORE
                                <br>300 FOR Y=1 TO 10: READ B(Y): NEXT
                                <br>
                                <br>4000 DATA 3.08, 5.19, 3.12, 3.98, 4.24
                                <br>4100 DATA 5.08, 5.55, 4.00, 3.16, 3.37
                                <br>
                                <br>(Fills the two arrays with identical data)
                                <br>
                                <br>10 DATA 1,2,3,4
                                <br>20 DATA 5,6,7,8
                                <br>30 FOR L= 1 TO 8
                                <br>40 READ A: PRINT A
                                <br>50 NEXT
                                <br>60 RESTORE
                                <br>70 FOR L= 1 TO 8
                                <br>80 READ A: PRINT A
                                <br>90 NEXT
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="RETURN">RETURN</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> RETURN</p>

                        <p>
                            <strong>ACTION:</strong> The RETURN statement is used to exit from a subroutine called for
                            by a GOSUB statement. RETURN restarts the rest of your program at the next executable
                            statement following the GOSUB. If you are nesting
                            subroutines, each GOSUB must be paired with at least one RETURN statement. A subroutine can
                            contain any number of RETURN statements, but the first one encountered will exit the
                            subroutine.</p>

                        <p class="example">Examples of RETURN Statement</p>
                        <blockquote>
                            <code>
                                10 PRINT"THIS IS THE PROGRAM"
                                <br>20 GOSUB 1000
                                <br>30 PRINT"PROGRAM CONTINUES"
                                <br>40 GOSUB 1000
                                <br>50 PRINT"MORE PROGRAM"
                                <br>60 END
                                <br>1000 PRINT"THIS IS THE GOSUB":RETURN
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="RIGHT$">RIGHT$</h5>

                        <p>
                            <strong>TYPE:</strong> String Function</p>
                        <p>
                            <strong>FORMAT:</strong> RIGHT$ (&lt;string&gt;,&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> The RIGHT$ function returns a sub-string taken from the right-most
                            end of the &lt;string&gt; argument. The length of the sub-string is defined by the
                            &lt;numeric&gt; argument which can be any integer
                            in the range of 0 to 255. If the value of the numeric expression is zero, then a null string
                            ("") is returned. If the value you give in the &lt;numeric&gt; argument is greater than the
                            length of the &lt;string&gt; then the
                            entire string is returned.
                        </p>

                        <p class="example">Examples of RIGHT$ Function</p>
                        <blockquote>
                            <code>
                                10 MSG$="COMMODORE COMPUTERS"
                                <br>20 PRINT RIGHT$(MSG$,9)
                                <br>RUN
                                <br>
                                <br>COMPUTERS
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="RND">RND</h5>

                        <p>
                            <strong>TYPE:</strong> Floating-Point Function</p>
                        <p>
                            <strong>FORMAT:</strong> RND (&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> RND creates a floating-point random from 0.0 to 1.0. The computer
                            generates a sequence of random numbers by performing calculations on a starting number,
                            which in computer jargon is called a seed. The
                            RND function is seeded on system power-up. The &lt;numeric&gt; argument is a dummy, except
                            for its sign (positive, zero, or negative).
                        </p>
                        <p>If the &lt;numeric&gt; argument is positive, the same "pseudorandom" sequence of numbers is
                            returned, starting from a given seed value. Different number sequences will result from
                            different seeds, but any sequence is repeatable
                            by starting from the same seed number. Having a known sequence of "random" numbers is useful
                            in testing programs.</p>
                        <p>If you choose a &lt;numeric&gt; argument of zero, then RND generates a number directly from a
                            free-running hardware clock (the system "jiffy clock"). Negative arguments cause the RND
                            function to be re-seeded with each function
                            call.</p>

                        <p class="example">Examples of RND Function</p>
                        <blockquote>
                            <pre>
220 PRINT INT(RND(0)*50)               (Return random integers 0-49)

100 X=INT(RND(1)*6)+INT(RND(1)*6)+2    (Simulates 2 dice)

100 X=INT(RND(1)*1000)+1               (Random integers from 1-1000)

100 X=INT(RND(1)*150)+100              (Random numbers from 100-249)

100 X=RND(1)*(U-L)+L                   (Random numbers between
                                        upper (U) and lower (L) limits)
                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="RUN">RUN</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> RUN [&lt;line-number&gt;]</p>

                        <p>
                            <strong>ACTION:</strong> The system command RUN is used to start the program currently in
                            memory. The RUN command causes an implied CLR operation to be performed before starting the
                            program. You can avoid the CLeaRing operation
                            by using CONT or GOTO to restart a program instead of RUN. If a &lt;line-number&gt; is
                            specified, your program will start on that line. Otherwise, the RUN command starts at first
                            line of the program. The RUN command can also
                            be used within a program. If the &lt;line-number&gt; you specify doesn't exist, the BASIC
                            error message
                            <code>UNDEF'D STATEMENT</code> occurs.</p>
                        <p>A RUNning program stops and BASIC returns to direct mode when an END or STOP statement is
                            reached, when the last line of the program is finished, or when a BASIC error occurs during
                            execution.
                        </p>

                        <p class="example">Examples of RUN Command</p>
                        <blockquote>
                            <pre>
RUN           (Starts at first line of program)

RUN 500       (Starts at line-number 500)
RUN X         (Starts at line X, or UNDEF'D STATEMENT ERROR
               if there is no line X)                                
                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="SAVE">SAVE</h5>

                        <p>
                            <strong>TYPE:</strong> Command</p>
                        <p>
                            <strong>FORMAT:</strong> SAVE
                            ["&lt;file-name&gt;"][,&lt;device-number&gt;][,&lt;address&gt;]
                        </p>

                        <p>
                            <strong>ACTION:</strong> The SAVE command is used to store the program that is currently in
                            memory onto a tape or diskette file. The program being SAVED is only affected by the command
                            while the SAVE is happening. The program
                            remains in the current computer memory even after the SAVE operation is completed until you
                            put something else there by using another command. The file type will be "prg" (program). If
                            the &lt;device-number&gt; is left out,
                            then the C64 will automatically assume that you want the program saved on cassette, device
                            number 1. If the &lt;device-number&gt; is an &lt;8&gt;, then the program is written onto
                            disk. The SAVE statement can be used in your
                            programs and execution will continue with the next statement after the SAVE is completed.
                        </p>
                        <p>Programs on tape are automatically stored twice, so that your Commodore 64 can check for
                            errors when LOADing the program back in. When saving programs to tape, the &lt;file-name&gt;
                            and secondary &lt;address&gt; are optional. But
                            following a SAVE with a program name in quotes ("") or by a string variable (---$) helps
                            your Commodore 64 find each program more easily. If the file-name is left out it can NOT be
                            LOADed by name later on.</p>
                        <p>A secondary address of 1 will tell the KERNAL to LOAD the tape at a later time, with the
                            program currently in memory instead of the normal 2048 location. A secondary address of 2
                            will cause an end-of-tape marker to follow the program.
                            A secondary address of 3 combines both functions.
                        </p>
                        <p>When saving programs onto a disk, the &lt;file-name&gt; must be present.</p>

                        <p class="example">Examples of SAVE Command</p>
                        <blockquote>
                            <pre>
SAVE               (Write to tape without a name)

SAVE"ALPHA",1      (Store on tape as file-name "alpha")

SAVE"ALPHA",1,2    (Store "alpha" with end-of-tape marker)

SAVE"FUN.DISK",8   (SAVES on disk (device 8 is the disk))

SAVE A$            (Store on tape with the name A$)

10 SAVE"HI"        (SAVEs program and then move to next program line)

SAVE"ME",1,3       (Stores at same memory location and puts an
                    end-of-tape marker on)

                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="SGN">SGN</h5>

                        <p>
                            <strong>TYPE:</strong> Integer Function</p>
                        <p>
                            <strong>FORMAT:</strong> SGN (&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> SGN gives you an integer value depending upon the sign of the
                            &lt;numeric&gt; argument. If the argument is positive the result is 1, if zero the result is
                            0, if negative the result is -1.</p>

                        <p class="example">Example of SGN Function</p>
                        <blockquote>
                            <code>
                                90 ON SGN(DV)+2 GOTO 100, 200, 300
                                <br>(jump to 100 if DV=negative, 200 if DV=0, 300 if DV=positive)
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="SIN">SIN</h5>

                        <p>
                            <strong>TYPE:</strong> Floating-Point Function</p>
                        <p>
                            <strong>FORMAT:</strong> SIN (&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> SIN gives you the sine of the &lt;numeric&gt; argument in radians.
                            The value of COS(X) is equal to SIN(x+3.14159265/2).</p>

                        <p class="example">Example of SIN Function</p>
                        <blockquote>
                            <code>
                                235 AA=SIN(1.5):PRINT AA
                                <br>.997494987
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="SPC">SPC</h5>

                        <p>
                            <strong>TYPE:</strong> String Function</p>
                        <p>
                            <strong>FORMAT:</strong> SPC (&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> The SPC function is used to control the formatting of data, as
                            either an output to the screen or into a logical file. The number of SPaCes given by the
                            &lt;numeric&gt; argument are printed, starting
                            at the first available position. For screen or tape files the value of the argument is in
                            the range of 0 to 255 and for disk files up to 254. For printer files, an automatic
                            carriage-return and line-feed will be performed by
                            the printer if a SPaCe is printed in the last character position of a line. No SPaCes are
                            printed on the following line.
                        </p>

                        <p class="example">Example of SPC Funtion</p>
                        <blockquote>
                            <code>
                                10 PRINT"RIGHT "; "HERE &amp;";
                                <br>20 PRINT SPC(5)"OVER" SPC(14)"THERE"
                                <br>RUN
                                <br>
                                <br>RIGHT HERE &amp; OVER THERE
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="SQR">SQR</h5>

                        <p>
                            <strong>TYPE:</strong> Floating-Point Function</p>
                        <p>
                            <strong>FORMAT:</strong> SQR (&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> SQR gives you the value of the SQuare Root of the &lt;numeric&gt;
                            argument. The value of the argument must not be negative, or the BASIC error message
                            <code>?ILLEGAL QUANTITY</code> will happen.</p>

                        <p class="example">Example of SPC Function</p>
                        <blockquote>
                            <code>
                                FOR J = 2 TO 5: PRINT J*S, SQR(J*5): NEXT
                                <br>
                                <br>10 3.16227766
                                <br>15 3.87298335
                                <br>20 4.47213595
                                <br>25 5
                                <br>
                                <br>READY
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="STATUS">STATUS</h5>

                        <p>
                            <strong>TYPE:</strong> Integer Function</p>
                        <p>
                            <strong>FORMAT:</strong> STATUS</p>

                        <p>
                            <strong>ACTION:</strong> Returns a completion STATUS for the last input/output operation
                            which was performed on an open file. The STATUS can be read from any peripheral device. The
                            STATUS (or simply ST) keyword is a system
                            defined variable-name into which the KERNAL puts the STATUS of I/O operations. A table of
                            STATUS code values for tape, printer, disk and RS-232 file operations is shown below:
                        </p>

                        <table>
                            <thead>
                                <tr>
                                    <th>ST Bit Position</th>
                                    <th>ST Numeric Value</th>
                                    <th>Cassette Read</th>
                                    <th>Serial Bus R/W</th>
                                    <th>Tape Verify + Load</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>0</td>
                                    <td>1</td>
                                    <td></td>
                                    <td>time out write</td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>1</td>
                                    <td>2</td>
                                    <td></td>
                                    <td>time out read</td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>2</td>
                                    <td>4</td>
                                    <td>short block</td>
                                    <td></td>
                                    <td>short block</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>8</td>
                                    <td>long block</td>
                                    <td></td>
                                    <td>long block</td>
                                </tr>
                                <tr>
                                    <td>4</td>
                                    <td>16</td>
                                    <td>unrecoverable read error</td>
                                    <td></td>
                                    <td>any mismatch</td>
                                </tr>
                                <tr>
                                    <td>5</td>
                                    <td>32</td>
                                    <td>checksum error</td>
                                    <td></td>
                                    <td>checksum error</td>
                                </tr>
                                <tr>
                                    <td>6</td>
                                    <td>64</td>
                                    <td>end of file</td>
                                    <td>EOI</td>
                                    <td></td>
                                </tr>
                                <tr>
                                    <td>7</td>
                                    <td>-128</td>
                                    <td>end of tape</td>
                                    <td>device not present</td>
                                    <td>end of tape</td>
                                </tr>
                            </tbody>
                        </table>

                        <p class="example">Examples of STATUS Function</p>
                        <blockquote>
                            <code>
                                10 OPEN 1,4:OPEN 2,8,4,"MASTER FILE,SEQ,W"
                                <br>20 GOSUB 100:REM CHECK STATUS
                                <br>30 INPUT#2,A$,B,C
                                <br>40 IF STATUS AND 64 THEN 80:REM HANDLE END-OF-FILE
                                <br>50 GOSUB 100:REM CHECK STATUS
                                <br>60 PRINT#1,A$,B;C
                                <br>70 GOTO 20
                                <br>80 CLOSE1:CLOSE2
                                <br>90 GOSUB 100:END
                                <br>100 IF ST > 0 THEN 9000:REM HANDLE FILE I/O ERROR
                                <br>110 RETURN
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="STEP">STEP</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> [STEP &lt;expression&gt;]</p>

                        <p>
                            <strong>ACTION:</strong> The optional STEP keyword follows the &lt;end-value&gt; expression
                            in a FOR statement. It defines an increment value for the loop counter variable. Any value
                            can be used as the STEP increment. Of course,
                            a STEP value of zero will loop forever. If the STEP keyword is left out, the increment value
                            will be + 1. When the NEXT statement in a FOR loop is reached, the STEP increment happens.
                            Then the counter is tested against the
                            end-value to see if the loop is finished. (See FOR statement for more information.)
                        </p>
                        <p>
                            <strong>NOTE: The STEP value can NOT be changed once it's in the loop.</strong>
                        </p>

                        <p class="example">Examples of STEP Statement</p>
                        <blockquote>
                            <pre>
25 FOR XX=2 TO 20 STEP 2             (Loop repeats 10 times)
35 FOR ZZ=0 TO -20 STEP -2           (Loop repeats 11 times)
                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="STOP">STOP</h5>

                        <p>
                            <strong>TYPE:</strong> STATEMENT</p>
                        <p>
                            <strong>FORMAT:</strong> STOP</p>

                        <p>
                            <strong>ACTION:</strong> The STOP statement is used to halt execution of the current program
                            and return to direct mode. Typing the &lt;RUN/STOP&gt; key on the keyboard has the same
                            effect as a STOP statement. The BASIC error
                            message ?BREAK IN LINE nnnnn is displayed on the screen, followed by READY. The "nnnnn" is
                            the line-number where the STOP occurs. Any open files remain open and all variables are
                            preserved and can be examined. The program can
                            be restarted by using CONT or GOTO statements.</p>

                        <p class="example">Examples of STOP Statement</p>
                        <blockquote>
                            <pre>
10 INPUT#1,AA,BB,CC
20 IF AA=BB AND BB=CC THEN STOP
30 STOP
                (If the variable AA is -1 and BB is equal to CC then:)
BREAK IN LINE 20
BREAK IN LINE 30        (For any other data values)
                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="STR$">STR$</h5>

                        <p>
                            <strong>TYPE:</strong> String Function</p>
                        <p>
                            <strong>FORMAT:</strong> STR$ (&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> STR$ gives you the STRing representation of the numeric value of
                            the argument. When the STR$ value is converted to each variable represented in the
                            &lt;numeric&gt; argument, any number shown is followed
                            by a space and, if it's positive, it is also preceded by a space.
                        </p>

                        <p class="example">Example of STR$ Function</p>
                        <blockquote>
                            <code>
                                100 FLT = 1.5E4: ALPHA$ = STR$(FLT)
                                <br>110 PRINT FLT, ALPHA$
                                <br>
                                <br>15000 15000
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="SYS">SYS</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> SYS &lt;memory-location&gt;</p>

                        <p>
                            <strong>ACTION:</strong> This is the most common way to mix a BASIC program with a machine
                            language program. The machine language program begins at the location given in the SYS
                            statement. The system command SYS is used in
                            either direct or program mode to transfer control of the microprocessor to an existing
                            machine language program in memory. The memory-location given is by numeric expression and
                            can be anywhere in memory, RAM or ROM.
                        </p>
                        <p> When you're using the SYS statement you must end that section of machine language code with
                            an RTS (ReTurn from Subroutine) instruction so that when the machine language program is
                            finished, the BASIC execution will resume with
                            the statement following the SYS command.</p>

                        <p class="example">Examples of SYS Statement</p>
                        <blockquote>
                            <pre>
SYS 64738                      (Jump to System Cold Start in ROM)

10 POKE 4400,96:SYS 4400       (Goes to machine code location 4400
                                and returns immediately)
                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="TAB(">TAB(</h5>

                        <p>
                            <strong>TYPE:</strong> String Function</p>
                        <p>
                            <strong>FORMAT:</strong> TAB (&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> The TAB function moves the cursor to a relative SPC move position
                            on the screen given by the &lt;numeric&gt; argument, starting with the left-most position of
                            the current line. The value of the argument
                            can range from 0 to 255. The TAB function should only be used with the PRINT statement,
                            since it has no effect if used with PRINT# to a logical file.
                        </p>

                        <p class="example">Example of TAB Function</p>
                        <blockquote>
                            <code>
                                100 PRINT"NAME" TAB(25) "AMOUNT": PRINT
                                <br>110 INPUT#1, NAM$, AMT$
                                <br>120 PRINT NAM$ TAB(25) AMT$
                                <br>
                                <br>NAME AMOUNT
                                <br>
                                <br>
                                <br>G.T. JONES 25.
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="TAN">TAN</h5>

                        <p>
                            <strong>TYPE:</strong> Floating-Point Function</p>
                        <p>
                            <strong>FORMAT:</strong> TAN (&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> Returns the tangent of the value of the &lt;numeric&gt; expression
                            in radians. If the TAN function overflows, the BASIC error message
                            <code>?DIVISION BY ZERO</code> is displayed.</p>

                        <p class="example">Example of TAN Function</p>
                        <blockquote>
                            <code>
                                10 XX=.785398163: YY=TAN(XX):PRINT YY
                                <br>
                                <br>1
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="TIME">TIME</h5>

                        <p>
                            <strong>TYPE:</strong> Numeric Function</p>\
                        <p>
                            <strong>FORMAT:</strong> TI</p>

                        <p>
                            <strong>ACTION:</strong> The TI function reads the interval Timer. This type of "clock" is
                            called a "jiffy clock." The "jiffy clock" value is set at zero (initialized) when you
                            power-up the system. This 1/60 second interval
                            timer is turned off during tape I/O.</p>

                        <p class="example">Example of TI Function</p>
                        <blockquote>
                            <code>10 PRINT TI/60 "SECONDS SINCE POWER UP"</code>
                        </blockquote>

                        <hr>

                        <h5 id="TIME$">TIME$</h5>

                        <p>
                            <strong>TYPE:</strong> String Function</p>
                        <p>
                            <strong>FORMAT:</strong> TI$</p>

                        <p>
                            <strong>ACTION:</strong> The TI$ timer looks and works like a real clock as long as your
                            system is powered-on. The hardware interval timer (or jiffy clock) is read and used to
                            update the value of TI$, which will give you a
                            TIme $tring of six characters in hours, minutes and seconds. The TI$ timer can also be
                            assigned an arbitrary starting point similar to the way you set your wristwatch. The value
                            of TI$ is not accurate after tape I/O.</p>

                        <p class="example">Example of TI$ Function</p>
                        <blockquote>
                            <code>
                                1 TI$ = "000000": FOR J=1 TO 10000: NEXT: PRINT TI$
                                <br>
                                <br>000011
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="USR">USR</h5>

                        <p>
                            <strong>TYPE:</strong> Floating-Point Function</p>
                        <p>
                            <strong>FORMAT:</strong> USR (&lt;numeric&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> The USR function jumps to a User callable machine language
                            SubRoutine which has its starting address pointed to by the contents of memory locations
                            785-786. The starting address is established before
                            calling the USR function by using POKE statements to set up locations 785-786. Unless POKE
                            statements are used, locations 785-786 will give you an
                            <code>?ILLEGAL QUANTITY</code> error message.</p>
                        <p>The value of the &lt;numeric&gt; argument is stored in the floating-point accumulator
                            starting at location 97, for access by the Assembler code, and the result of the USR
                            function is the value which ends up there when the subroutine
                            returns to BASIC.</p>

                        <p class="example">Examples of USR Function</p>
                        <blockquote>
                            <code>
                                10 B=T*SIN(Y)
                                <br>20 C=USR(B/2)
                                <br>30 D=USR(B/3)
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="VAL">VAL</h5>

                        <p>
                            <strong>TYPE:</strong> Numeric Function</p>
                        <p>
                            <strong>FORMAT:</strong> VAL (&lt;string&gt;)</p>

                        <p>
                            <strong>ACTION:</strong> Returns a numeric VALue representing the data in the &lt;string&gt;
                            argument. If the first non-blank character of the string is not a plus sign (+), minus sign
                            (-), or a digit the VALue returned is
                            zero. String conversion is finished when the end of the string or any non-digit character is
                            found (except decimal point or exponential e).</p>

                        <p class="example">Example of VAL Function</p>
                        <blockquote>
                            <code>
                                10 INPUT#1, NAM$, ZIP$
                                <br>20 IF VAL(ZIP$) &lt; 19400 OR VAL(ZIP$) &gt; 96699
                                <br>THEN PRINT NAM$ TAB(25) "GREATER PHILADELPHIA"
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="VERIFY">VERIFY</h5>

                        <p>
                            <strong>TYPE:</strong> Command</p>
                        <p>
                            <strong>FORMAT:</strong> VERIFY ["&lt;file-name&gt;"][,&lt;device&gt;]</p>

                        <p>
                            <strong>ACTION:</strong> The VERIFY command is used, in direct or program mode, to compare
                            the contents of a BASIC program file on tape or disk with the program currently in memory.
                            VERIFY is normally used right after a SAVE,
                            to make sure that the program was stored correctly on tape or disk.
                        </p>
                        <p> If the &lt;device&gt; number is left out, the program is assumed to be on the Datassette(TM)
                            which is device number 1. For tape files, if the &lt;file-name&gt; is left out, the next
                            program found on the tape will be compared. For
                            disk files (device number 8), the file-name must be present. If any differences in program
                            text are found, the BASIC error message
                            <code>?VERIFY ERROR</code> is displayed.</p>
                        <p>A program name can be given either in quotes or as a string variable. VERIFY is also used to
                            position a tape just past the last program, so that a new program can be added to the tape
                            without accidentally writing over another program.</p>

                        <p class="example">Examples of VERIFY Command</p>
                        <blockquote>
                            <pre>
    VERIFY                      (Checks 1st program on tape)
    PRESS PLAY ON TAPE
    OK
    SEARCHING
    FOUND &lt;FILENAME&gt;
    VERIFYING

    9000 SAVE "ME",8:
    9010 VERIFY "ME",8          (Looks at device 8 for the program)
                            </pre>
                        </blockquote>

                        <hr>

                        <h5 id="WAIT">WAIT</h5>

                        <p>
                            <strong>TYPE:</strong> Statement</p>
                        <p>
                            <strong>FORMAT:</strong> WAIT &lt;location&gt;,&lt;mask-1&gt;[,&lt;mask-2&gt;]</p>

                        <p>
                            <strong>ACTION:</strong> The WAIT statement causes program execution to be suspended until a
                            given memory address recognizes a specified bit pattern. In other words WAIT can be used to
                            halt the program until some external event
                            has occurred. This is done by monitoring the status of bits in the input/ output registers,
                            The data items used with WAIT can be any numeric expressions, but they will be converted to
                            integer values. For most programmers, this
                            statement should never be used. It causes the program to halt until a specific memory
                            location's bits change in a specific way. This is used for certain I/O operations and almost
                            nothing else.</p>
                        <p>The WAIT statement takes the value in the memory location and performs a logical AND
                            operation with the value in mask-1. If there is a mask-2 in the statement, the result of the
                            first operation is exclusive-ORed with mask-2. In
                            other words mask-1 "filters out" any bits that you don't want to test. Where the bit is 0 in
                            mask-1, the corresponding bit in the result will always be 0. The mask-2 value flips any
                            bits, so that you can test for an off condition
                            as well as an on condition, Any bits being tested for a 0 should have a I in the
                            corresponding position in mask-2.</p>
                        <p>If corresponding bits of the &lt;mask-1&gt; and &lt;mask-2&gt; operands differ, the
                            exclusive-OR operation gives a bit result of 1. If corresponding bits get the same result
                            the bit is 0. It is possible to enter an infinite pause
                            with the WAIT statement, in which case the &lt;RUN/STOP&gt; and &lt;RESTORE&gt; keys can be
                            used to recover. Hold down the &lt;RUN/STOP&gt; key and then press &lt;RESTORE&gt;. The
                            first example below WAITs until a key is pressed
                            on the tape unit to continue with the program. The second example will WAIT until a sprite
                            collides with the screen background.
                        </p>

                        <p class="example">Examples of WAIT Statement</p>
                        <blockquote>
                            <pre>
WAIT 1,32,32
WAIT 53273,6,6
WAIT 36868,144,16         (144 & 16 are masks. 144=10010000 in binary
                           and 16=10000 in binary. The WAIT statement
                           will halt the program until the 128 bit is
                           on or until the 16 bit is off)
                            </pre>
                        </blockquote>
                    </section>

                    <hr>

                    <section class="main-section" id="Keyboard_and_Features">
                        <header>
                            <h4>The Commodore 64 Keyboard and Features</h4>
                        </header>

                        <p> The Operating System has a ton-character keyboard "buffer" that is used to hold incoming
                            keystrokes until they can be processed. This buffer, or queue, holds keystrokes in the order
                            in which they occur so that the first one put
                            into the queue is the first one processed. For example, if a second keystroke occurs before
                            the first can be processed, the second character Is stored in the buffer, while processing
                            of the first character continues. After
                            the program has finished with the first character, the keyboard buffer is examined for more
                            data, and the second keystroke processed. Without this buffer, rapid keyboard input would
                            occasionally drop characters.</p>
                        <p>In other words, the keyboard buffer allows you to "type-ahead" of the system, which means it
                            can anticipate responses to INPUT prompts or GET statements. As you type on the keys their
                            character values are lined up, single-file
                            (queued) into the buffer to wait for processing in the order the keys were struck. This
                            type-ahead feature can give you an occasional problem where an accidental keystroke causes a
                            program to fetch an incorrect character from
                            the buffer.</p>
                        <p>Normally, incorrect keystrokes present no problem, since they can be corrected by the
                            CuRSoR-Left &lt;CRSR LEFT&gt; or DELete &lt;INST/DEL&gt; keys and then retyping the
                            character, and the corrections will be processed before a
                            following carriage-return. However, if you press the &lt;RETURN&gt; key, no corrective
                            action is possible, since all characters in the buffer up to and including the
                            carriage-return will be processed before any corrections.
                            This situation can be avoided by using a loop to empty the keyboard buffer before reading an
                            intended response:</p>

                        <blockquote>
                            <code>10 GET JUNK$: IF JUNK$ &lt;&gt;"" THEN 10: REM EMPTY THE KEYBOARD BUFFER</code>
                        </blockquote>

                        <p>In addition to GET and INPUT, the keyboard can also be read using PEEK to fetch from memory
                            location 197 ($00C5) the integer value of the key currently being pressed. If no key Is
                            being held when the PEEK is executed, a value of
                            64 is returned, The numeric keyboard values, keyboard symbols and character equivalents
                            (CHR$) are shown in Appendix C. The following example loops until a key is pressed then
                            converts the integer to a character value.
                        </p>

                        <blockquote>
                            <code>
                                10 AA=PEEK(197): IF AA=64 THEN 10
                                <br>20 BB$=CHR$(AA)
                            </code>
                        </blockquote>

                        <p>The keyboard is treated as a set of switches organized into a matrix of 8 columns by 8 rows.
                            The keyboard matrix is scanned for key switch closures by the KERNAL using the CIA #l 1/0
                            chip (MOS 6526 Complex Interface Adapter). Two
                            CIA registers are used to perform the scan: register #0 at location 56320 ($DC00) for
                            keyboard columns and register #l at location 56321 ($DC01) for keyboard rows.</p>
                        <p>Bits 0-7 of memory location 56320 correspond to the columns 0-7. Bits 0-7 of memory location
                            56321 correspond to rows 0-7. By writing column values in sequence, then reading row values,
                            the KERNAL decodes the switch closures into
                            the CHR$ (N) value of the key pressed.</p>
                        <p>Eight columns by eight rows yields 64 possible values. However, if you first strike the
                            &lt;RVS ON&gt;, &lt;CTRL&gt; or &lt;CMDRE&gt; keys or hold down the &lt;SHIFT&gt; key and
                            type a second character, additional values are generated.
                            This is because the KERNAL decodes these keys separately and "remembers" when one of the
                            control keys was pressed. The result of the keyboard scan is then placed in location 197.
                        </p>
                        <p>Characters can also be written directly to the keyboard buffer at locations 631-640 using a
                            POKE statement. These characters will be processed when the POKE is used to set a character
                            count into location 198. These facts can be
                            used to cause a series of direct-mode commands to be executed automatically by printing the
                            statements onto the screen, putting carriage-returns into the buffer, and then setting the
                            character count. In the example below, the
                            program will LIST itself to the printer and then resume execution.</p>

                        <blockquote>
                            <code>
                                10 PRINT CHR$(147)"PRINT#1: CLOSE 1: GOTO 50"
                                <br>20 POKE 631119: POKE 632,13: POKE 633,13: POKE 198,3
                                <br>30 OPEN 114: CMD1: LIST
                                <br>40 END
                                <br>50 REM PROGRAM RE-STARTS HERE
                            </code>
                        </blockquote>

                    </section>

                    <hr>

                    <section class="main-section" id="Screen_Editor">
                        <header>
                            <h4>The Screen Editor</h4>
                        </header>

                        <p>The SCREEN EDITOR provides you with powerful and convenient facilities for editing program
                            text. Once a section of a program is listed to the screen, the cursor keys and other special
                            keys are used to move around the screen so
                            that you can make any appropriate changes. After making all the changes you want to a
                            specific line-number of text, hitting the &lt;RETURN&gt; key anywhere on the line, causes
                            the SCREEN EDITOR to read the entire 80-character
                            logical screen line.
                        </p>
                        <p>The text is then passed to the Interpreter to be tokenized and stored in the program. The
                            edited line replaces the old version of that line in memory. An additional copy of any line
                            of text can be created simply by changing the
                            line-number and pressing &lt;RETURN&gt;.</p>
                        <p>If you use keyword abbreviations which cause a program line to exceed 80 characters, the
                            excess characters will be lost when that line is edited, because the EDITOR will read only
                            two physical screen lines. This is also why using
                            INPUT for more than a total of 80 characters is not possible. Thus, for all practical
                            purposes, the length of a line of BASIC text is limited to 80 characters as displayed on the
                            screen.</p>
                        <p>Under certain conditions the SCREEN EDITOR treats the cursor control keys differently from
                            their normal mode of handling. If the CuRSoR is positioned to the right of an odd number of
                            double-quote marks (") the EDITOR operates in
                            what is known as the QUOTE-MODE.</p>
                        <p>In quote mode data characters are entered normally but the cursor controls no longer move the
                            CuRSoR, instead reversed characters are displayed which actually stand for the cursor
                            control being entered. The same is true of the
                            color control keys. This allows you to include cursor and color controls inside string data
                            items in programs. You will find that this is a very important and powerful feature. That's
                            because when the text inside the quotes
                            is printed to the screen it performs the cursor positioning and color control functions
                            automatically as part of the string. An example of using cursor controls in strings is:</p>

                        <blockquote>
                            <pre>
You type -->            10 PRINT"A(R)(R)B(L)(L)(L)C(R)(R)D": REM(R)=CRSR
                        RIGHT, (L)=CRSR LEFT

Computer prints -->     AC BD
                            </pre>
                        </blockquote>

                        <p>The &lt;DEL&gt; key is the only cursor control NOT affected by quote mode. Therefore, if an
                            error is made while keying in quote mode, the &lt;CRSR LEFT&gt; key can't be used to back up
                            and strike over the error &mdash; even the
                            &lt;INST&gt; key produces a reverse video character. Instead, finish entering the line, and
                            then, after hitting the &lt;RETURN&gt; key, you can edit the line normally. Another
                            alternative, if no further cursor-controls are
                            needed in the string, is to press the &lt;RUN/STOP&gt; and &lt;RESTORE&gt; keys which will
                            cancel QUOTE MODE. The cursor control keys that you can use in strings are shown in Table
                            2-2.
                        </p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Control Key</th>
                                    <th>Appearance</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>CRSR Up</td>
                                    <td class="screen">&#9679;</td>
                                </tr>
                                <tr>
                                    <td>CRSR Down</td>
                                    <td class="screen">Q</td>
                                </tr>
                                <tr>
                                    <td>CRSR Left</td>
                                    <td class="screen">|</td>
                                </tr>
                                <tr>
                                    <td>CRSR Right</td>
                                    <td class="screen">]</td>
                                </tr>
                                <tr>
                                    <td>CLR</td>
                                    <td class="screen">&hearts;</td>
                                </tr>
                                <tr>
                                    <td>HOME</td>
                                    <td class="screen">S</td>
                                </tr>
                                <tr>
                                    <td>INST</td>
                                    <td class="screen">|</td>
                                </tr>
                            </tbody>
                        </table>
                        <p class="table-note">
                            <strong>NOTE:</strong> Characters shown above may not look exactly like characters on real
                            hardware or in emulation.</p>

                        <p> When you are NOT in quote mode, holding down the &lt;SHIFT&gt; key and then pressing the
                            INSerT &lt;INST&gt; key shifts data to the right of the cursor to open up space between two
                            characters for entering data between them. The
                            Editor then begins operating in INSERT MODE until all of the space opened up is filled.</p>

                        <p>The cursor controls and color controls again show as reversed characters in insert mode. The
                            only difference occurs on the DELete and INSerT &lt;INST/DEL&gt; key. The &lt;DEL&gt;
                            instead of operating normally as in the quote mode,
                            now creates the reversed &lt;T&gt;. The &lt;INST&gt; key, which created a reverse character
                            in quote mode, inserts spaces normally.
                        </p>

                        <p>This means that a PRINT statement can be created, containing DELetes, which can't be done in
                            quote mode. The insert mode is cancelled by pressing the &lt;RETURN&gt;, &lt;SHIFT&gt; and
                            &lt;RETURN&gt;, or &lt;RUN/STOP&gt; and &lt;RESTORE&gt;
                            keys. Or you can cancel the insert mode by filling all the inserted spaces. An example of
                            using DEL characters in strings is:
                        </p>

                        <blockquote>
                            <code>
                                10 PRINT"HELLO"&lt;DEL&gt;&lt;INST&gt;&lt;INST&gt;&lt;DEL&gt;&lt;DEL&gt;P"
                                <br>(Keystroke sequence shown above, appearance when listed below)
                                <br>10 PRINT"HELP"
                            </code>
                        </blockquote>

                        <p>When the example is RUN, the word displayed will be HELP, because the letters LO are deleted
                            before the P is printed. The DELete character in strings will work with LIST as well as
                            PRINT. You can use this to "hide" part or all
                            of a line of text using this technique. However, trying to edit a line with these characters
                            will be difficult if not impossible.
                        </p>
                        <p>There are some other characters that can be printed for special functions, although they are
                            not easily available from the keyboard. In order to get these into quotes, you must leave
                            empty spaces for them in the line, press &lt;RETURN&gt;,
                            and go back to edit the line. Now you hold down the &lt;CTRL&gt; (ConTRoL) key and type
                            &lt;RVS ON&gt; (ReVerSe-ON) to start typing reversed characters. Type the keys as shown
                            below:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Key Function</th>
                                    <th>Key Entered</th>
                                    <th>Appearance</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Shifted RETURN</td>
                                    <td>&lt;SHIFT+M&gt;</td>
                                    <td class="screen">\</td>
                                </tr>
                                <tr>
                                    <td>Switch to upper/lower case</td>
                                    <td>&lt;N&gt;</td>
                                    <td class="screen">N</td>
                                </tr>
                                <tr>
                                    <td>Switch to upper/graphics</td>
                                    <td>&lt;SHIFT+N&gt;</td>
                                    <td class="screen">/</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>Holding down the &lt;SHIFT&gt; key and hitting &lt;RETURN&gt; causes a carriage-return and
                            line-feed on the screen but does not end the string. This works with LIST as well as PRINT,
                            so editing will be almost impossible if this
                            character is used. When output is switched to the printer via the CMD statement, the reverse
                            "N" character shifts the printer into its upper-lower case character set and the
                            &lt;SHIFT&gt; "N" shifts the printer into the upper-case/graphics
                            character set.
                        </p>
                        <p>Reverse video characters can be included in strings by holding down the ConTRoL &lt;CTRL&gt;
                            key and pressing ReVerSe &lt;RVS&gt;, causing a reversed R to appear inside the quotes. This
                            will make all characters print in reverse
                            video (like a negative of a photograph). To end the reverse printing, press &lt;CTRL&gt; and
                            &lt;RVS OFF&gt; (ReVerSe OFF) by holding down the &lt;CTRL&gt; key and typing the &lt;RVS
                            OFF&gt; key, which prints a reverse R. Numeric
                            data can be printed in reverse video by first printing a CHR$(18). Printing a CHR$(146) or a
                            carriage-return will cancel reverse video output.</p>
                    </section>

                    <h3>Programming Graphics</h3>

                    <section class="main-section">
                        <header>
                            <h4 id="Graphics_Overview">Graphics Overview</h4>
                        </header>
                        <p>All of the graphics abilities of the Commodore 64 come from the 6567 Video Interface Chip
                            (also known as the VIC-II chip). This chip gives a variety of graphics modes, including a 40
                            column by 25 line text display, a 320 by 200
                            dot high resolution display, and SPRITES, small movable objects which make writing games
                            simple. And if this weren't enough, many of the graphics modes can be mixed on the same
                            screen. It is possible, for example, to define
                            the top half of the screen to be in high resolution mode, while the bottom half is in text
                            mode. And SPRITES will combine with anything! More on sprites later. First the other
                            graphics modes.
                        </p>
                        <p>The VIC-II chip has the following display modes:</p>

                        <ul>
                            <li>
                                <strong>Character Display Modes</strong>
                            </li>
                            <li>
                                <ol>
                                    <li>Standard Character Mode</li>
                                    <li class="none">
                                        <ol class="sub-list">
                                            <li>ROM Characters</li>
                                            <li>RAM Programmable Characters</li>
                                        </ol>
                                    </li>
                                    <li value="2">Multi-Color Character Mode</li>
                                    <li class="none">
                                        <ol class="sub-list">
                                            <li>ROM Characters</li>
                                            <li>RAM Programmable Characters</li>
                                        </ol>
                                    </li>
                                    <li value="3">Extended Background Color Mode</li>
                                    <li class="none">
                                        <ol class="sub-list">
                                            <li>ROM Characters</li>
                                            <li>RAM Programmable Characters</li>
                                        </ol>
                                    </li>
                                </ol>
                            </li>
                            <li>
                                <strong>Bitmap Modes</strong>
                            </li>
                            <li>
                                <ol>
                                    <li>Standard Bitmap Mode</li>
                                    <li>Multi-Color Bitmap Mode</li>
                                </ol>
                            </li>
                            <li>
                                <strong>Sprites</strong>
                            </li>
                            <li>
                                <ol>
                                    <li>Standard Sprites</li>
                                    <li>Multi-Color Sprites</li>
                                </ol>
                            </li>
                        </ul>

                        <hr>

                        <h4 id="Graphics_Locations">Graphics Locations</h4>

                        <p>Some general information first. There are 1000 possible locations on the Commodore 64 screen.
                            Normally, the screen starts at location 1024 ($0400 in HEXadecimal notation) and goes to
                            location 2023. Each of these locations is 8
                            bits wide. This means that it can hold any integer number from 0 to 255. Connected with
                            screen memory is a group of 1000 locations called COLOR MEMORY or COLOR RAM. These start at
                            location 55296 ($D800 in HEX) and go up to
                            56295. Each of the color RAM locations is 4 bits wide, which means that it can hold any
                            integer number from 0 to 15. Since there are 16 possible colors that the Commodore 64 can
                            use, this works out well.</p>
                        <p>In addition, there are 256 different characters that can be displayed at any time. For normal
                            screen display, each of the 1000 locations in screen memory contains a code number which
                            tells the VIC-II chip which character to display
                            at that screen location.</p>
                        <p>The various graphics modes are selected by the 47 CONTROL registers in the VIC-II chip. Many
                            of the graphics functions can be controlled by POKEing the correct value into one of the
                            registers. The VIC-II chip is located starting
                            at 53248 ($D000 in HEX) through 53294 ($D02E in HEX).
                        </p>

                        <h5>Video Bank Selection</h5>

                        <p>The VIC-II chip can access ("see") 16K of memory at a time. Since there is 64K of memory in
                            the Commodore 64, you want to be able to have the VIC-II chip see all of it. There is a way.
                            There are 4 possible BANKS (or sections) of
                            16K of memory. All that is needed is some means of controlling which 16K bank the VIC-II
                            chip looks at. In that way, the chip can "see" the entire 64K of memory. The BANK SELECT
                            bits that allow you access to all the different
                            sections of memory are located in the 6526 COMPLEX INTERFACE ADAPTER CHIP #2 (CIA #2). The
                            POKE and PEEK BASIC statements (or their machine language versions) are used to select a
                            bank, by controlling bits 0 and 1 of PORT A
                            of CIA#2 (location 56576 (or $DD00 HEX)). These 2 bits must be set to outputs by setting
                            bits 0 and 1 of location 56578 ($DD02,HEX) to change banks. The following example shows
                            this:</p>

                        <blockquote>
                            <code>
                                POKE 56578,PEEK(56578)OR 3: REM MAKE SURE BITS 0 AND 1 ARE OUTPUTS
                                <br>POKE 56576,(PEEK(56576)AND 252)OR A: REM CHANGE BANKS
                            </code>
                        </blockquote>

                        <p> "A" should have one of the following values:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Value of A</th>
                                    <th>Bits</th>
                                    <th>Bank</th>
                                    <th>Starting Location</th>
                                    <th>VIC-II Chip Range</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>0</td>
                                    <td>00</td>
                                    <td>3</td>
                                    <td>49152</td>
                                    <td>($C000-$FFFF)*</td>
                                </tr>
                                <tr>
                                    <td>1</td>
                                    <td>01</td>
                                    <td>2</td>
                                    <td>32768</td>
                                    <td>($8000-$BFFF)</td>
                                </tr>
                                <tr>
                                    <td>2</td>
                                    <td>10</td>
                                    <td>1</td>
                                    <td>16384</td>
                                    <td>($4000-$7FFF)*</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>11</td>
                                    <td>0</td>
                                    <td>0</td>
                                    <td>($0000-$3FFF) (DEFAULT VALUE)</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>This 16K bank concept is part of everything that the VIC-II chip does. You should always be
                            aware of which bank the VIC-II chip is pointing at, since this will affect where character
                            data patterns come from, where the screen is,
                            where sprites come from, etc. When you turn on the power of your Commodore 64, bits 0 and 1
                            of location 56576 are automatically set to BANK 0 ($0000-$3FFF) for all display information.
                        </p>
                        <p>
                            <strong>NOTE:</strong> The Commodore 64 character set is not available to the VIC-II chip in
                            BANKS 1 and 3. (See character memory section.) </p>

                        <h5>Screen Memory</h5>

                        <p>The location of screen memory can be changed easily by a POKE to control register 53272
                            ($D018 HEX). However, this register is also used to control which character set is used, so
                            be careful to avoid disturbing that part of the
                            control register. The UPPER 4 bits control the location of screen memory. To move the
                            screen, the following statement should be used:
                        </p>

                        <blockquote>
                            <code>POKE53272,(PEEK(53272)AND15)OR A</code>
                        </blockquote>

                        <p>Where "A" has one of the following values:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th rowspan="2">A</th>
                                    <th rowspan="2">Bits</th>
                                    <th colspan="2">Location</th>
                                </tr>
                                <tr>
                                    <th>Decimal</th>
                                    <th>Hex</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>0</td>
                                    <td>0000XXXX</td>
                                    <td>0</td>
                                    <td>$0000</td>
                                </tr>
                                <tr>
                                    <td>16</td>
                                    <td>0001XXXX</td>
                                    <td>1024</td>
                                    <td>$0400 (DEFAULT)</td>
                                </tr>
                                <tr>
                                    <td>32</td>
                                    <td>0010XXXX</td>
                                    <td>2048</td>
                                    <td>$0800</td>
                                </tr>
                                <tr>
                                    <td>48</td>
                                    <td>0011XXXX</td>
                                    <td>3072</td>
                                    <td>$0C00</td>
                                </tr>
                                <tr>
                                    <td>64</td>
                                    <td>0100XXXX</td>
                                    <td>4096</td>
                                    <td>$1000</td>
                                </tr>
                                <tr>
                                    <td>80</td>
                                    <td>0101XXXX</td>
                                    <td>5120</td>
                                    <td>$1400</td>
                                </tr>
                                <tr>
                                    <td>96</td>
                                    <td>0110XXXX</td>
                                    <td>6144</td>
                                    <td>$1800</td>
                                </tr>
                                <tr>
                                    <td>112</td>
                                    <td>0111XXXX</td>
                                    <td>6178</td>
                                    <td>$1C00</td>
                                </tr>
                                <tr>
                                    <td>128</td>
                                    <td>1000XXXX</td>
                                    <td>8192</td>
                                    <td>$2000</td>
                                </tr>
                                <tr>
                                    <td>144</td>
                                    <td>1001XXXX</td>
                                    <td>9216</td>
                                    <td>$2400</td>
                                </tr>
                                <tr>
                                    <td>160</td>
                                    <td>1010XXXX</td>
                                    <td>10240</td>
                                    <td>$2800</td>
                                </tr>
                                <tr>
                                    <td>176</td>
                                    <td>1011XXXX</td>
                                    <td>11264</td>
                                    <td>$2C00</td>
                                </tr>
                                <tr>
                                    <td>192</td>
                                    <td>1100XXXX</td>
                                    <td>12288</td>
                                    <td>$3000</td>
                                </tr>
                                <tr>
                                    <td>208</td>
                                    <td>1101XXXX</td>
                                    <td>13312</td>
                                    <td>$3400</td>
                                </tr>
                                <tr>
                                    <td>224</td>
                                    <td>1110XXXX</td>
                                    <td>14336</td>
                                    <td>$3800</td>
                                </tr>
                                <tr>
                                    <td>240</td>
                                    <td>1111XXXX</td>
                                    <td>15360</td>
                                    <td>$3C00</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>
                            <strong>NOTE:</strong> Remember that the bank address of the VIC-II chip must be added in.
                            You must also tell the KERNAL's screen editor where the screen is as follows:</p>

                        <blockquote>
                            <code>POKE 648, page (where page = address/256, e.g. 1024/256 = 4, so POKE 648,4)</code>
                        </blockquote>

                        <h5>Color Memory</h5>

                        <p>Color memory can NOT move. It is always located at locations 55296 ($D800) through 56295
                            ($DBE7). Screen memory (the 1000 locations starting at 1024) and color memory are used
                            differently in the different graphics modes. A picture
                            created in one mode will often look completely different when displayed in another graphics
                            mode.</p>

                        <h5>Character Memory</h5>

                        <p> Exactly where the VIC-II gets it character information is important to graphic programming.
                            Normally, the chip gets the shapes of the characters you want to be displayed from the
                            CHARACTER GENERATOR ROM. In this chip are stored
                            the patterns which make up the various letters, numbers, punctuation symbols, and the other
                            things that you see on the keyboard. One of the features of the Commodore 64 is the ability
                            to use patterns located in RAM memory.
                            These RAM patterns are created by you, and that means that you can have an almost infinite
                            set of symbols for games, business applications, etc.
                        </p>
                        <p>A normal character set contains 256 characters in which each character is defined by 8 bytes
                            of data. Since each character takes up 8 bytes this means that a full character set is
                            256*8=2K bytes of memory. Since the VIC-II chip
                            looks at 16K of memory at a time, there are 8 possible locations for a complete character
                            set. Naturally, you are free to use less than a full character set. However, it must still
                            start at one of the 8 possible starting locations.
                        </p>
                        <p>The location of character memory is controlled by 3 bits of the VIC-II control register
                            located at 53272 ($D018 in HEX notation). Bits 3,2, and 1 control where the characters' set
                            is located in 2K blocks. Bit 0 is ignored. Remember
                            that this is the same register that determines where screen memory is located so avoid
                            disturbing the screen memory bits. To change the location of character memory, the following
                            BASIC statement can be used:</p>

                        <blockquote>
                            <code>POKE 53272,(PEEK(53272)AND240)OR A</code>
                        </blockquote>

                        <p>Where A is one of the following values:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th rowspan="2">Value of A</th>
                                    <th rowspan="2">Bits</th>
                                    <th colspan="2">Location of Character Memory</th>
                                </tr>
                                <tr>
                                    <th>Decimal</th>
                                    <th>Hex</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>0</td>
                                    <td>XXXX000X</td>
                                    <td>0</td>
                                    <td>$0000-$07FF</td>
                                </tr>
                                <tr>
                                    <td>2</td>
                                    <td>XXXX001X</td>
                                    <td>2048</td>
                                    <td>$0800-$0FFF</td>
                                </tr>
                                <tr>
                                    <td>4</td>
                                    <td>XXXX010X</td>
                                    <td>4096</td>
                                    <td>$1000-$17FF ROM IMAGE in BANK 0 &amp; 2 (default)</td>
                                </tr>
                                <tr>
                                    <td>6</td>
                                    <td>XXXX011X</td>
                                    <td>6144</td>
                                    <td>$1800-$1FFF (ROM IMAGE in BANK 0 &amp; 2)</td>
                                </tr>
                                <tr>
                                    <td>8</td>
                                    <td>XXXX100X</td>
                                    <td>8192</td>
                                    <td>$2000-$27FF</td>
                                </tr>
                                <tr>
                                    <td>10</td>
                                    <td>XXXX101X</td>
                                    <td>10240</td>
                                    <td>$2800-$2FFF</td>
                                </tr>
                                <tr>
                                    <td>12</td>
                                    <td>XXXX110X</td>
                                    <td>12288</td>
                                    <td>$3000-$37FF</td>
                                </tr>
                                <tr>
                                    <td>14</td>
                                    <td>XXXX111X</td>
                                    <td>14336</td>
                                    <td>$3800-$3FFF</td>
                                </tr>
                            </tbody>
                        </table>

                        <p> The ROM IMAGE in the above table refers to the character generator ROM. It appears in place
                            of RAM at the above locations in bank 0. it also appears in the corresponding RAM at
                            locations 36864-40959 ($9000-$9FFF) in bank 2. Since
                            the VIC-II chip can only access 16K of memory at a time, the ROM character patterns appear
                            in the 16K block of memory the VIC-II chip looks at. Therefore, the system was designed to
                            make the VIC-II chip think that the ROM characters
                            are at 4096-8191 ($1000-$1FFF) when your data is in bank 0, and 36864-40959 ($9000-$9FFF)
                            when your data is in bank 2, even though the character ROM is actually at location
                            53248-57343 ($D000-$DFFF). This imaging only applies
                            to character data as seen by the VIC-II chip. It can be used for programs, other data, etc.,
                            just like any other RAM memory.
                        </p>

                        <p>
                            <strong>NOTE:</strong> If these ROM images got in the way of your own graphics, then set the
                            BANK SELECT BITS to one of the BANKS without the images (BANKS 1 or 3). The ROM patterns
                            won't be there.
                        </p>

                        <p>The location and contents of the character set in ROM are as follows:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th rowspan="2">Block</th>
                                    <th colspan="2">Address</th>
                                    <th rowspan="2">VIC-II Image</th>
                                    <th rowspan="2">Contents</th>
                                </tr>
                                <tr>
                                    <th>Decimal</th>
                                    <th>Hex</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td rowspan="4">0</td>
                                    <td>53248</td>
                                    <td>D000-D1FF</td>
                                    <td>1000-11FF</td>
                                    <td>Upper case characters</td>
                                </tr>
                                <tr>
                                    <td>53760</td>
                                    <td>D200-D3FF</td>
                                    <td>1200-13FF</td>
                                    <td>Graphics characters</td>
                                </tr>
                                <tr>
                                    <td>54272</td>
                                    <td>D400-D5FF</td>
                                    <td>1400-15FF</td>
                                    <td>Reversed upper case characters</td>
                                </tr>
                                <tr>
                                    <td>54784</td>
                                    <td>D600-D7FF</td>
                                    <td>1600-17FF</td>
                                    <td>Reversed graphics characters</td>
                                </tr>
                                <tr>
                                    <td rowspan="4">1</td>
                                    <td>55296</td>
                                    <td>D800-D9FF</td>
                                    <td>1800-19FF</td>
                                    <td>Lower case characters</td>
                                </tr>
                                <tr>
                                    <td>55808</td>
                                    <td>DA00-DBFF</td>
                                    <td>1A00-1BFF</td>
                                    <td>Upper case &amp; graphics characters</td>
                                </tr>
                                <tr>
                                    <td>56320</td>
                                    <td>DC00-DDFF</td>
                                    <td>1C00-1DFF</td>
                                    <td>Reversed lower case characters</td>
                                </tr>
                                <tr>
                                    <td>56832</td>
                                    <td>DE00-DFFF</td>
                                    <td>1E00-1FFF</td>
                                    <td>Reversed upper case &amp; graphics characters</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>Sharp-eyed readers will have just noticed something. The locations occupied by the character
                            ROM are the same as the ones occupied by the VIC-II chip control registers. This is possible
                            because they don't occupy the same locations
                            at the same time. When the VIC-II chip needs to access character data the ROM is switched
                            in. It becomes an image in the 16K bank of memory that the VIC-II chip is looking at.
                            Otherwise, the area is occupied by the I/O control
                            registers, and the character ROM is only available to the VIC-II chip.</p>
                        <p>However, you may need to get to the character ROM if you are going to use programmable
                            characters and want to copy some of the character ROM for some of your character
                            definitions. In this case you must switch out the I/O register,
                            switch in the character ROM, and do your copying. When you're finished, you must switch the
                            1/0 registers back in again. During the copying process (when I/O is switched out) no
                            interrupts can be allowed to take place. This
                            is because the I/O registers are needed to service the interrupts. If you forget and perform
                            an interrupt, really strange things happen. The keyboard should not be read during the
                            copying process. To turn off the keyboard and
                            other normal interrupts that occur with your Commodore 64, the following POKE should be
                            used:</p>

                        <blockquote>
                            <code>POKE 56334,PEEK(56334)AND254 (TURNS INTERRUPTS OFF)</code>
                        </blockquote>

                        <p> After you are finished getting characters from the character ROM, and are ready to continue
                            with your program, you must turn the keyboard scan back on by the following POKE:</p>

                        <blockquote>
                            <code>POKE 56334,PEEK(56334)OR1 (TURNS INTERRUPTS ON)</code>
                        </blockquote>

                        <p>The following POKE will switch out 1/0 and switch the CHARACTER ROM in:</p>

                        <blockquote>
                            <code>POKE 1,PEEK(1)AND251</code>
                        </blockquote>

                        <p>The character ROM is now in the locations from 53248-57343 ($D000 - $DFFF).</p>

                        <p>To switch I/O back into $D000 for normal operation use the following POKE:</p>

                        <blockquote>
                            <code>POKE 1,PEEK(1)OR 4</code>
                        </blockquote>

                    </section>

                    <hr>

                    <section class="main-section" id="Standard_Character_Mode">
                        <header>
                            <h4>Standard Character Mode</h4>
                        </header>
                        <p> Standard character mode is the mode the Commodore 64 is in when you first turn it on. It is
                            the mode you will generally program in.</p>
                        <p>Characters can be taken from ROM or from RAM, but normally they are taken from ROM. When you
                            want special graphics characters for a program, all you have to do is define the new
                            character shapes in RAM, and tell the VIC-II chip
                            to get its character information from there instead of the character ROM. This is covered in
                            more detail in the next section.</p>
                        <p>In order to display characters on the screen in color, the VIC-II chip accesses the screen
                            memory to determine the character code for that location on the screen. At the same time, it
                            accesses the color memory to determine what
                            color you want for the character displayed. The character code is translated by the VIC-II
                            into the starting address of the 8-byte block holding your character pattern. The 8-byte
                            block is located in character memory.</p>
                        <p>The translation isn't too complicated, but a number of items are combined to generate the
                            desired address. First the character code you use to POKE screen memory is multiplied by 8.
                            Next add the start of character memory (see CHARACTER
                            MEMORY section). Then the Bank Select Bits are taken into account by adding in the base
                            address (see VIDEO BANK SELECTION section). Below is a simple formula to illustrate what
                            happens:</p>

                        <blockquote>
                            <code>CHARACTER ADDRESS = SCREEN CODE*8+(CHARACTER SET*2048)+(BANK*16384)</code>
                        </blockquote>

                        <h5>Character Definitions</h5>

                        <p>Each character is formed in an 8 by 8 grid of dots, where each dot may be either on or off.
                            The Commodore 64 character images are stored in the Character Generator ROM chip. The
                            characters are stored as a set of 8 bytes for each
                            character, with each byte representing the dot pattern of a row in the character, and each
                            bit representing a dot. A zero bit means that dot is off, and a one bit means the dot is on.
                        </p>
                        <p>The character memory in ROM begins at location 53248 (when the I/O is switched off). The
                            first 8 bytes from location 53248 ($D000) to 53255 ($D007) contain the pattern for the @
                            sign, which has a character code value of zero in
                            the screen memory. The next 8 bytes, from location 53256 ($D008) to 53263 ($D00F), contain
                            the information for forming the letter A.
                        </p>

                        <blockquote>
                            <pre>
       IMAGE     BINARY       PEEK

        **      00011000       24
       ****     00111100       60
      **  **    01100110      102
      ******    01111110      126
      **  **    01100110      102
      **  **    01100110      102
      **  **    01100110      102
		00000000	0
                            </pre>
                        </blockquote>

                        <p>Each complete character set takes up 2K (2048 bits) of memory, 8 bytes per character and 256
                            characters. Since there are two character sets, one for upper case and graphics and the
                            other with upper and lower case, the character
                            generator ROM takes up a total of 4K locations.
                        </p>
                    </section>

                    <hr>

                    <section class="main-section" id="Programmable_Characters">
                        <header>
                            <h4>Programmable Characters</h4>
                        </header>
                        <p>Since the characters are stored in ROM, it would seem that there is no way to change them for
                            customizing characters. However, the memory location that tells the VIC-II chip where to
                            find the characters is a programmable register
                            which can be changed to point to many sections of memory. By changing the character memory
                            pointer to point to RAM, the character set may be programmed for any need.
                        </p>
                        <p>If you want your character set to be located in RAM, there are a few VERY IMPORTANT things to
                            take into account when you decide to actually program your own character sets. In addition,
                            there are two other important points you
                            must know to create your own special characters:
                        </p>
                        <ol>
                            <li>It is an all or nothing process. Generally, if you use your own character set by telling
                                the VIC-II chip to get the character information from the area you have prepared in RAM,
                                the standard Commodore 64 characters are unavailable
                                to you. To solve this, you must copy any letters, numbers, or standard Commodore 64
                                graphics you intend to use into your own character memory in RAM. You can pick and
                                choose, take only the ones you want, and don't even
                                have to keep them in order!
                            </li>
                            <li>Your character set takes memory space away from your BASIC program. Of course, with 38K
                                available for a BASIC program, most applications won't have problems.</li>
                        </ol>

                        <p>
                            <strong>WARNING:</strong> You must be careful to protect the character set from being
                            overwritten by your BASIC program, which also uses the RAM.</p>

                        <p>There are two locations in the Commodore 64 to start your character set that should NOT be
                            used with BASIC: location 0 and location 2048. The first should not be used because the
                            system stores important data on page 0. The second
                            can't be used because that is where your BASIC program starts! However, there are 6 other
                            starting positions for your custom character set.</p>
                        <p>The best place to put your character set for use with BASIC while experimenting is beginning
                            at 12288 ($3000 in HEX). This is done by POKEing the low 4 bits of location 53272 with 12.
                            Try the POKE now, like this:
                        </p>

                        <blockquote>
                            <code>POKE 53272,(PEEK(53272)AND240)+12</code>
                        </blockquote>

                        <p>Immediately, all the letters on the screen turn to garbage, This is because there are no
                            characters set up at location 12288 right now... only random bytes. Set the Commodore 64
                            back to normal by hitting the &lt;RUN/STOP&gt; key
                            and then the &lt;RESTORE&gt; key.</p>
                        <p>Now let's begin creating graphics characters. To protect your character set from BASIC, you
                            should reduce the amount of memory BASIC thinks it has. The amount of memory in your
                            computer stays the same... it's just that you've told
                            BASIC not to use some of it. Type:</p>

                        <blockquote>
                            <code>PRINT FRE(0)-(SGN(FRE(0)) &lt;0)*65535
                            </code>
                        </blockquote>

                        <p>The number displayed is the amount of memory space left unused. Now type the following:</p>

                        <blockquote>
                            <code> POKE 52148:POKE56,48:CLR</code>
                        </blockquote>

                        <p>Now type:</p>

                        <blockquote>
                            <code>PRINT FRE(0)-(SGN(FRE(0)) &lt;)*65535
                            </code>
                        </blockquote>

                        <p>See the change? BASIC now thinks it has less memory to work with. The memory you just claimed
                            from BASIC is where you are going to put your character set, safe from actions of BASIC.</p>

                        <p>The next step is to put your characters into RAM. When you begin, there is random data
                            beginning at 12288 ($3000 HEX). You must put character patterns in RAM (in the same style as
                            the ones in ROM) for the VIC-II chip to use.</p>
                        <p>The following program moves 64 characters from ROM to your character set RAM:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE110.PRG
                                <br>5 PRINTCHR$(142) :REM SWITCH TO UPPER CASE
                                <br>10 POKE52,48:POKE 56,48:CLR :REM RESERVE MEMORY FOR CHARACTERS
                                <br>20 POKE56334,PEEK(56334)AND254 :REM TURN OFF KEYSCAN INTERRUPT TIMER
                                <br>30 POKE1,PEEK(1)AND251 :REM SWITCH IN CHARACTER
                                <br>40 FORI=0TO511:POKEI+12288,PEEK(I+53248):NEXT
                                <br>50 POKE1,PEEK(1)OR4 :REM SWITCH IN I/O
                                <br>60 POKE56334,PEEK(56334)OR1 :REM RESTART KEYSCAN INTERRUPT TIMER
                                <br>70 END
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>Now POKE location 53272 with (PEEK(53272)AND240)+12. Nothing happens, right? Well, almost
                            nothing. The Commodore 64 is now getting it's character information from your RAM, instead
                            of from ROM. But since we copied the characters
                            from ROM exactly, no difference can be seen... yet.</p>
                        <p>You can easily change the characters now. Clear the screen and type an @ sign. Move the
                            cursor down a couple of lines, then type:</p>

                        <blockquote>
                            <code>FOR I=12288 TO 12288+7:POKE 1,255-PEEK(I):NEXT</code>
                        </blockquote>

                        <p>You just created a reversed @ sign!</p>

                        <p>
                            <strong>TIP:</strong> Reversed characters are just characters with their bit patterns in
                            character memory reversed.
                        </p>

                        <p> Now move the cursor up to the program again and hit &lt;RETURN&gt; again to re-reverse the
                            character (bring it back to normal). By looking at the table of screen display codes, you
                            can figure out where in RAM each character is.
                            Just remember that each character takes eight memory locations to store. Here's a few
                            examples just to get you started:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Character</th>
                                    <th>Display Code</th>
                                    <th>Character Starting Location in RAM</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="screen">@</td>
                                    <td>0</td>
                                    <td>1228</td>
                                </tr>
                                <tr>
                                    <td class="screen">A</td>
                                    <td>1</td>
                                    <td>12296</td>
                                </tr>
                                <tr>
                                    <td class="screen">!</td>
                                    <td>33</td>
                                    <td>12552</td>
                                </tr>
                                <tr>
                                    <td class="screen">&gt;</td>
                                    <td>62</td>
                                    <td>12784</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>Remember that we only took the first 64 characters. Something else will have to be done if
                            you want one of the other characters.</p>
                        <p>What if you wanted character number 154, a reversed Z? Well, you could make it yourself, by
                            reversing a Z, or you could copy the set of reversed characters from the ROM, or just take
                            the one character you want from ROM and replace
                            one of the characters you have in RAM that you don't need.</p>
                        <p>Suppose you decide that you won't need the &gt; sign. Let's replace the &gt; sign with the
                            reversed Z. Type this:</p>

                        <blockquote>
                            <code>FOR I=0 TO 7:POKE 12784+I,255-PEEK(I+12496):NEXT</code>
                        </blockquote>

                        <p>Now type a > sign. It comes up as a reversed Z. No matter how many times you type the &gt;,
                            it comes out as a reversed Z. (This change is really an illusion. Though the &gt; sign looks
                            like a reversed Z, it still acts like a &gt;
                            in a program. Try something that needs a &gt; sign. It will still work fine, only it will
                            look strange.)</p>
                        <p>A quick review: You can now copy characters from ROM into RAM. You can even pick and choose
                            only the ones you want. There's only one step left in programmable characters (the best
                            step!)... making your own characters.</p>
                        <p>Remember how characters are stored in ROM? Each character is stored as a group of eight
                            bytes. The bit patterns of the bytes directly control the character. If you arrange 8 bytes,
                            one on top of another, and write out each byte
                            as eight binary digits, it forms an eight by eight matrix, looking like the characters. When
                            a bit is a one, there is a dot at that location. When a bit is a zero, there is a space at
                            that location. When creating your own characters,
                            you set up the same kind of table in memory. Type NEW and then type this program:
                        </p>

                        <blockquote>
                            <code>
                                10 FOR I=12448 TO 12455: READ A:POKE I,A:NEXT
                                <br>20 DATA 60, 66, 165, 129, 165, 153, 66, 60
                            </code>
                        </blockquote>

                        <p>Now type RUN. The program will replace the letter T with a smile face character. Type a few
                            T's to see the face. Each of the numbers in the DATA statement in line 20 is a row in the
                            smile face character. The matrix for the face
                            looks like this:</p>

                        <img src="https://s33.postimg.cc/82rd355en/c64_prg_3-1.png"
                            alt="Programmable Character Worksheet">

                        <p>The Programmable Character Worksheet (Figure 3-1) will help you design your own characters.
                            There is an 8 by 8 matrix on the sheet, with row numbers, and numbers at the top of each
                            column. (if you view each row as a binary word,
                            the numbers are the value of that bit position. Each is a power of 2. The leftmost bit is
                            equal to 128 or 2 to the 7th power, the next is equal to 64 or 2 to the 6th, and so on,
                            until you reach the rightmost bit (bit 0) which
                            is equal to 1 or 2 to the 0 power.)</p>
                        <p>Place an X on the matrix at every location where you want a dot to be in your character. When
                            your character is ready you can create the DATA statement for your character.</p>
                        <p>Begin with the first row. Wherever you placed an X, take the number at the top of the column
                            (the power-of-2 number, as explained above) and write it down. When you have the numbers for
                            every column of the first row, add them together.
                            \Mite this number down, next to the row. This is the number that you will put into the DATA
                            statement to draw this row.</p>
                        <p>Do the same thing with all of the other rows (1-7). When you are finished you should have 8
                            numbers between 0 and 255. If any of your numbers are not within range, recheck your
                            addition. The numbers must be in this range to be
                            correct! If you have less than 8 numbers, you missed a row. It's OK if some are 0. The 0
                            rows are just as important as the other numbers.
                        </p>
                        <p>If you don't like the way the character turned out, just change the numbers in the DATA
                            statement and re-RUN the program until you are happy with your character.</p>
                        <p>That's all there is to it!</p>

                        <p>
                            <strong>HINT:</strong> For best results, always make any vertical lines in your characters
                            at least 2 dots (bits) wide. This helps prevent CHROMA noise (color distortion) on your
                            characters when they are displayed on a TV screen.</p>

                        <p>Here is an example of a program using standard programmable characters:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE114.PRG
                                <br>10 REM * EXAMPLE 1 *
                                <br>20 REM CREATING PROGRAMMABLE CHARACTERS
                                <br>31 POKE 56334,PEEK(56334)AND254: REM TURN OFF KB
                                <br>32 POKE 1,PEEK(1)AND251: REM TURN OFF I/O
                                <br>35 FOR I=0TO63: REM CHARACTER RANGE TO BE COPIED
                                <br>36 FOR J=0TO7: REM COPY ALL 8 BYTES PER CHARACTER
                                <br>37 POKE 12288+I*8+J,PEEK(53248+I*8+J): REM COPY A BYTE
                                <br>38 NEXT J:NEXT I: REM GOTO NEXT BYTE OR CHARACTER
                                <br>39 POKE 1,PEEK(1)OR4:POKE 56334,PEEK(56334)OR1: REM TURN ON I/O AND KB
                                <br>40 POKE 53272,(PEEK(53272)AND240)+12: REM SET CHAR POINTER TO MEM. 12288
                                <br>60 FOR CHAR=60TO63: REM PROGRAM CHARACTERS 60 THRU 63
                                <br>80 FOR BYTE=0TO7: REM DO ALL 8 BYTES OF A CHARACTER
                                <br>100 READ NUMBER: REM READ IN 1/8TH OF CHARACTER DATA
                                <br>120 POKE 12288+(8*CHAR)+BYTE,NUMBER: REM STORE THE DATA IN MEMORY
                                <br>140 NEXT BYTE:NEXT CHAR: REM ALSO COULD BE NEXT BYTE, CHAR
                                <br>150 PRINT CHR$(147)TAB(255)CHR$(60);
                                <br>155 PRINT CHR$(61)TAB(55)CHR$(62)CHR$(63)
                                <br>160 REM LINE 150 PUTS THE NEWLY DEFINED CHARACTERS ON THE SCREEN
                                <br>170 GET A$: REM WAIT FOR USER TO PRESS A KEY
                                <br>180 IF A$=""THEN GOTO170: REM IF NO KEYS WERE PRESSED, TRY AGAIN!
                                <br>190 POKE 53272,21: REM RETURN TO NORMAL CHARACTERS
                                <br>200 DATA 4,6,7,5,7,7,3,3: REM DATA FOR CHARACTER 60
                                <br>210 DATA 32,96,224,160,224,224,192,192: REM DATA FOR CHARACTER 61
                                <br>220 DATA 7,7,7,31,31,95,143,127: REM DATA FOR CHARACTER 62
                                <br>230 DATA 224,224,224,248,248,248,240,224: REM DATA FOR CHARACTER 63
                                <br>240 END
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                    </section>

                    <hr>

                    <section class="main-section" id="Multi-Color_Mode_Graphics">
                        <header>
                            <h4>Multi-Color Mode Graphics</h4>
                        </header>

                        <p> Standard high-resolution graphics give you control of very small dots on the screen. Each
                            dot in character memory can have 2 possible values, 1 for on and 0 for off. When a dot is
                            off, the color of the screen is used in the space
                            reserved for that dot. If the dot is on, the dot is colored with the character color you
                            have chosen for that screen position. When you're using standard high-resolution graphics,
                            all the dots within each 8X8 character can
                            either have background color or foreground color. In some ways this limits the color
                            resolution within that space. For example, problems may occur when two different colored
                            lines cross.</p>
                        <p> Multi-color mode gives you a solution to this problem. Each dot in multi-color mode can be
                            one of 4 colors: screen color (background color register #0), the color in background
                            register #1, the color in background color register
                            #2, or character color. The only sacrifice is in the horizontal resolution, because each
                            multi-color mode dot is twice as wide as a high-resolution dot. This minimal loss of
                            resolution is more than compensated for by the extra
                            abilities of multi-color mode.
                        </p>

                        <h5>Multi-Color Mode Bit</h5>

                        <p>To turn on multi-color character mode, set bit 4 of the VIC-II control register at 53270
                            ($D016) to a 1 by using the following POKE:</p>

                        <blockquote>
                            <code>POKE 53270,PEEK(53270)OR 16</code>
                        </blockquote>

                        <p>To turn off multi-color character mode, set bit 4 of location 53270 to a 0 by the following
                            POKE:
                        </p>

                        <blockquote>
                            <code>POKE 53270,PEEK(53270)AND 239</code>
                        </blockquote>

                        <p>Multi-color mode is set on or off for each space on the screen, so that multi-color graphics
                            can be mixed with high-resolution (hi-res) graphics. This is controlled by bit 3 in color
                            memory. Color memory begins at location 55296
                            ($D800 in HEX). If the number in color memory is less than 8 (0-7) the corresponding space
                            on the video screen will be standard hi-res, in the color (0-7) you've chosen. If the number
                            located in color memory is greater or equal
                            to 8 (from 8 to 15), then that space will be displayed in multi-color mode.</p>
                        <p> By POKEing a number into color memory, you can change the color of the character in that
                            position on the screen. POKEing a number from 0 to 7 gives the normal character colors.
                            POKEing a number between 8 and 15 puts the space into
                            multi-color mode. In other words, turning BIT 3 ON in color memory, sets MULTI-COLOR MODE.
                            Turning BIT 3 OFF in color memory, sets the normal, HIGH-RESOLUTION mode.
                        </p>
                        <p>Once multi-color mode is set in a space, the bits in the character determine which colors are
                            displayed for the dots. For example, here is a picture of the letter A, and its bit pattern:
                        </p>

                        <blockquote>
                            <pre>
              IMAGE    BIT PATTERN

                **       00011000
               ****      00111100
              **  **     01100110
              ******     01111110
              **  **     01100110
              **  **     01100110
              **  **     01100110
                         00000000
                            </pre>
                        </blockquote>

                        <p>In normal or high-resolution mode, the screen color is displayed everywhere there is a 0 bit,
                            and the character color is displayed where the bit is a 1. Multi-color mode uses the bits in
                            pairs, like so:</p>

                        <blockquote>
                            <pre>
               IMAGE    BIT PATTERN

                AABB      00011000
                CCCC      00111100
              AABBAABB    01100110
              AACCCCBB    01111110
              AABBAABB    01100110
              AABBAABB    01100110
              AABBAABB    01100110
                          00000000
                            </pre>
                        </blockquote>

                        <p>In the image area above, the spaces marked AA are drawn in the background #1 color, the
                            spaces marked BB use the background #2 color, and the spaces marked CC use the character
                            color. The bit pairs determine this, according to
                            the following chart:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Bit Pair</th>
                                    <th>Color Register</th>
                                    <th>Location</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>00</td>
                                    <td>Background #0 color (screen color)</td>
                                    <td>53281 ($D021)</td>
                                </tr>
                                <tr>
                                    <td>01</td>
                                    <td>Background #1 color</td>
                                    <td>53282 ($D022)</td>
                                </tr>
                                <tr>
                                    <td>10</td>
                                    <td>Background #2 color</td>
                                    <td>52383 ($D023)</td>
                                </tr>
                                <tr>
                                    <td>11</td>
                                    <td>Color specified by the lower 3 bits in color memory</td>
                                    <td>Color RAM</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>Type NEW and then type this demonstration program:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE117.PRG
                                <br>100 POKE 53281,1: REM SET BACKGROUND COLOR #0 TO WHITE
                                <br>110 POKE 53282,3: REM SET BACKGROUND COLOR #1 TO CYAN
                                <br>120 POKE 53282,8: REM SET BACKGROUND COLOR #2 TO ORANGE
                                <br>130 POKE 53270,PEEK(53270)OR16: REM TURN ON MULTICOLOR MODE
                                <br>140 C=13*4096+8*256: REM SET C TO POINT TO COLOR MEMORY
                                <br>150 PRINTCHR$(147)"AAAAAAAAAA"
                                <br>160 FORL=0TO9
                                <br>170 POKEC+L,8: REM USE MULTI BLACK
                                <br>180 NEXT
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>The screen color is white, the character color is black, one color register is cyan (greenish
                            blue), the other is orange. You're not really putting color codes in the space for character
                            color, you're actually using references
                            to the registers associated with those colors. This conserves memory, since 2 bits can be
                            used to pick 16 colors (background) or 8 colors (character). This also makes some neat
                            tricks possible. Simply changing one of the indirect
                            registers will change every dot drawn in that color. Therefore everything drawn in the
                            screen and background colors can be changed on the whole screen instantly. Here is an
                            example of changing background color register #1:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE118.PRG
                                <br>100 POKE53270,PEEK(53270)OR16: REM TURN ON MULTICOLOR MODE
                                <br>110 PRINT CHR$(147)CHR$(18);
                                <br>120 PRINT"{ORANGE*2}";: REM TYPE C= & 1 FOR ORANGE OR MULTICOLOR BLACK BG
                                <br>130 FORL=1TO22:PRINTCHR$(65);:NEXT
                                <br>135 FORT=1TO500:NEXT
                                <br>140 PRINT"{BLUE*2}";: REM TYPE CTRL & 7 FOR BLUE COLOR CHANGE
                                <br>145 FORT=1TO500:NEXT
                                <br>150 PRINT"{BLACK}HIT A KEY"
                                <br>160 GET A$:IF A$=""THEN160
                                <br>170 X=INT(RND(1)*16)
                                <br>180 POKE 53282,X
                                <br>190 GOTO 160
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>By using the &lt;CMDRE&gt; key and the COLOR keys the characters can be changed to any color,
                            including multi-color characters. For example, type this command:
                        </p>

                        <blockquote>
                            <code>POKE 53270,PEEK(53270)OR 16:PRINT"&lt;CTRL+3&gt;";: REM LT.RED/ MULTI-COLOR RED</code>
                        </blockquote>

                        <p>The word READY and anything else you type will be displayed in multi-color mode. Another
                            color control can set you back to regular text.</p>

                        <p> Here is an example of a program using multi-color programmable characters:
                        </p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE119.PRG
                                <br>10 REM * EXAMPLE 2 *
                                <br>20 REM CREATING MULTI COLOR PROGRAMMABLE CHARACTERS
                                <br>31 POKE 56334,PEEK(56334)AND254:POKE1,PEEK(1)AND251
                                <br>35 FORI=0TO63:REM CHARACTER RANGE TO BE COPIED FROM ROM
                                <br>36 FORJ=0TO7:REM COPY ALL 8 BYTES PER CHARACTER
                                <br>37 POKE 12288+I*8+J,PEEK(53248+I*8+J):REM COPY A BYTE
                                <br>38 NEXT J,I:REM GOTO NEXT BYTE OR CHARACTER
                                <br>39 POKE 1,PEEK(1)OR4:POKE 56334,PEEK(56334)OR1:REM TURN ON I/O AND KB
                                <br>40 POKE 53272,(PEEK(53272)AND240)+12:REM SET CHAR POINTER TO MEM. 12288
                                <br>50 POKE 53270,PEEK(53270)OR16
                                <br>51 POKE 53281,0:REM SET BACKGROUND COLOR #0 TO BLACK
                                <br>52 POKE 53282,2:REM SET BACKGROUND COLOR #1 TO RED
                                <br>53 POKE 53283,7:REM SET BACKGROUND COLOR #2 TO YELLOW
                                <br>60 FOR CHAR=60TO63:REM PROGRAM CHARACTERS 60 THRU 63
                                <br>80 FOR BYTE=0TO7:REM DO ALL 8 BYTES OF A CHARACTER
                                <br>100 READ NUMBER:REM READ 1/8TH OF THE CHARACTER DATA
                                <br>120 POKE 12288+(8*CHAR)+BYTE,NUMBER:REM STORE THE DATA IN MEMORY
                                <br>140 NEXT BYTE,CHAR
                                <br>150 PRINT"{CLEAR}"TAB(255)CHR$(60)CHR$(61)TAB(55)CHR$(62)CHR$(63)
                                <br>160 REM LINE 150 PUTS THE NEWLY DEFINED CHARACTERS ON THE SCREEN
                                <br>170 GET A$:REM WAIT FOR USER TO PRESS A KEY
                                <br>180 IF A$=""THEN170:REM IF NO KEYS WERE PRESSED, TRY AGAIN
                                <br>190 POKE53272,21:POKE53270,PEEK(53270)AND239:REM RETURN TO NORMAL CHARS
                                <br>200 DATA129,37,21,29,93,85,85,85: REM DATA FOR CHARACTER 60
                                <br>210 DATA66,72,84,116,117,85,85,85: REM DATA FOR CHARACTER 61
                                <br>220 DATA87,87,85,21,8,8,40,0: REM DATA FOR CHARACTER 62
                                <br>230 DATA213,213,85,84,32,32,40,0: REM DATA FOR CHARACTER 63
                                <br>240 END
                                <br>STOP TOK64
                            </code>
                        </blockquote>
                    </section>

                    <hr>

                    <section class="main-section" id="Extended_Background_Color_Mode">
                        <header>
                            <h4>Extended Background Color Mode</h4>
                        </header>

                        <p> Extended background color mode gives you control over the background color of each
                            individual character, as well as over the foreground color. For example, in this mode you
                            could display a blue character with a yellow background
                            on a white screen.</p>
                        <p>There are 4 registers available for extended background color mode. Each of the registers can
                            be set to any of the 16 colors.</p>
                        <p>Color memory is used to hold the foreground color in extended background mode. It is used the
                            same as in standard character mode.</p>
                        <p>Extended character mode places a limit on the number of different characters you can display,
                            however. When extended color mode is on, only the first 64 characters in the character ROM
                            (or the first 64 characters in your programmable
                            character set) can be used. This is because two of the bits of the character code are used
                            to select the background color. It might work something like this:
                        </p>
                        <p>The character code (the number you would POKE to the screen) of the letter "A" is a 1. When
                            extended color mode is on, if you POKED a 1 to the screen, an "A" would appear. If you POKED
                            a 65 to the screen normally, you would expect
                            the character with character code (CHR$) 129 to appear, which is a reversed "A." This does
                            NOT happen in extended color mode. Instead you get the same unreversed "A" as before, but on
                            a different background color. The following
                            chart gives the codes:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th colspan="3">Character Code</th>
                                    <th colspan="2">Background Color Register</th>
                                </tr>
                                <tr>
                                    <th>Range</th>
                                    <th>Bit 7</th>
                                    <th>Bit 6</th>
                                    <th>Number</th>
                                    <th>Address</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>0 - 63</td>
                                    <td>0</td>
                                    <td>0</td>
                                    <td>0</td>
                                    <td>52381 ($D021)</td>
                                </tr>
                                <tr>
                                    <td>64 - 127</td>
                                    <td>0</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>53282 ($D022)</td>
                                </tr>
                                <tr>
                                    <td>128 - 191</td>
                                    <td>1</td>
                                    <td>0</td>
                                    <td>2</td>
                                    <td>53283 ($D023)</td>
                                </tr>
                                <tr>
                                    <td>192 - 255</td>
                                    <td>1</td>
                                    <td>1</td>
                                    <td>3</td>
                                    <td>52384 ($D024)</td>
                                </tr>
                            </tbody>
                        </table>

                        <p> Extended color mode is turned ON by setting bit 6 of the VIC-II register to a 1 at location
                            53265 ($D011 in HEX). The following POKE does it:</p>

                        <blockquote>
                            <code>POKE 53265,PEEK(53265)OR 64</code>
                        </blockquote>

                        <p>Extended color mode is turned OFF by setting bit 6 of the VIC-II register to a 0 at location
                            53265 ($D011). The following statement will do this:</p>

                        <blockquote>
                            <code>POKE 53265,PEEK(53265)AND 191</code>
                        </blockquote>
                    </section>

                    <hr>

                    <section class="main-section" id="Bitmapped_Graphics">
                        <header>
                            <h4>Bitmapped Graphics</h4>
                        </header>

                        <p> When writing games, plotting charts for business applications, or other types of programs,
                            sooner or later you get to the point where you want high-resolution displays.</p>
                        <p>The Commodore 64 has been designed to do just that: high resolution is available through bit
                            mapping of the screen. Bit mapping is the method in which each possible dot (pixel) of
                            resolution on the screen is assigned its own bit
                            (location) in memory. If that memory bit is a one, the dot it is assigned to is on. If the
                            bit is set to zero, the dot is off.</p>
                        <p> High-resolution graphic design has a couple of drawbacks, which is why it is not used all
                            the time. First of all, it takes lots of memory to bit map the entire screen. This is
                            because every pixel must have a memory bit to control
                            it. You are going to need one bit of memory for each pixel (or one byte for 8 pixels). Since
                            each character is 8 by 8, and there are 40 lines with 25 characters in each line, the
                            resolution is 320 pixels (dots) by 200 pixels
                            for the whole screen. That gives you 64000 separate dots, each of which requires a bit in
                            memory. In other words, 8000 bytes of memory are needed to map the whole screen.</p>
                        <p>Generally, high-resolution operations are made of many short, simple, repetitive routines.
                            Unfortunately, this kind of thing is usually rather slow if you are trying to write
                            high-resolution routines in BASIC. However, short, simple,
                            repetitive routines are exactly what machine language does best. The solution is to either
                            write your programs entirely in machine language, or call machine language, high-resolution
                            subroutines from your BASIC program using
                            the SYS command from BASIC. That way you get both the ease of writing in BASIC, and the
                            speed of machine language for graphics. The VSP cartridge is also available to add
                            high-resolution commands to COMMODORE 64 BASIC.
                        </p>
                        <p>All of the examples given in this section will be in BASIC to make them clear. Now to the
                            technical details.
                        </p>
                        <p>BIT MAPPING is one of the most popular graphics techniques in the computer world. It is used
                            to create highly detailed pictures. Basically, when the Commodore 64 goes into bit map mode,
                            it directly displays an 8K section of memory
                            on the TV screen. When in bit map mode, you can directly control whether an individual dot
                            on the screen is on or off.</p>
                        <p>There are two types of bit mapping available on the Commodore 64. They are:</p>

                        <ol>
                            <li>Standard (high-resolution) bit mapped mode (320-dot by 200-dot resolution)</li>
                            <li>Multi-color bit mapped mode (160-dot by 200-dot resolution)</li>
                        </ol>

                        <p>Each is very similar to the character type it is named for: standard has greater resolution,
                            but fewer color selections. On the other hand, multi-color bit mapping trades horizontal
                            resolution for a greater number of colors in
                            an 8-dot by 8-dot square.</p>

                        <h5>Standard High-Resolution Bitmap Mode</h5>

                        <p>Standard bit map mode gives you a 320 horizontal dot by 200 vertical dot resolution, with a
                            choice of 2 colors in each 8-dot by 8-dot section. Bit map mode is selected (turned ON) by
                            setting bit 5 of the VIC-II control register
                            to a 1 at location 53265 ($D011 in HEX). The following POKE will do this:</p>

                        <blockquote>
                            <code>POKE 53265,PEEK(53265)OR 32</code>
                        </blockquote>

                        <p>Bit map mode is turned OFF by setting bit 5 of the VIC-II control register to 0 at location
                            53265 ($D011), like this:</p>

                        <blockquote>
                            <code>POKE 53265,PEEK(53265)AND 223</code>
                        </blockquote>

                        <p>Before we get into the details of the bit map mode, there is one more issue to tackle, and
                            that is where to locate the bit map area.</p>

                        <h5>How It Works</h5>

                        <p>If you remember the PROGRAMMABLE CHARACTERS section you will recall that you were able to set
                            the bit pattern of a character stored in RAM to almost anything you wanted. If at the same
                            time you change the character that is displayed
                            on the screen, you would be able to change a single dot, and watch it happen. This is the
                            basis of bit-mapping. The entire screen is filled with programmable characters, and you make
                            your changes directly into the memory that
                            the programmable characters get their patterns from.</p>
                        <p>Each of the locations in screen memory that were used to control what character was
                            displayed, are now used for color information. For example, instead of POKEing a I in
                            location 1024 to make an "A" appear in the top left hand
                            corner of the screen, location 1024 now controls the colors of the bits in that top left
                            space.</p>
                        <p>Colors of squares in bit map mode do not come from color memory, as they do in the character
                            modes. Instead, colors are taken from screen memory. The upper 4 bits of screen memory
                            become the color of any bit that is set to 1 in
                            the 8 by 8 area controlled by that screen memory location. The lower 4 bits become the color
                            of any bit that is set to a 0.</p>

                        <p class="example">Example</p>

                        <p>Type the following:</p>

                        <blockquote>
                            <code>
                                5 BASE=2*4096:POKE53272,PEEK(53272)OR8:REM PUT BIT MAP AT 8192
                                <br>10 POKE53265,PEEK(53265)OR32:REM ENTER BIT MAP MODE
                            </code>
                        </blockquote>

                        <p>Now RUN the program.</p>
                        <p>Garbage appears on the screen, right? Just like the normal screen mode, you have to clear the
                            HIGH-RESOLUTION (HI-RES) screen before you use it. Unfortunately, printing a CLR won't work
                            in this case. Instead you have to clear out
                            the section of memory that you're using for your programmable characters. Hit the
                            &lt;RUN/STOP&gt; and &lt;RESTORE&gt; keys, then add the following lines to your program to
                            clear the HI-RES screen:</p>

                        <blockquote>
                            <code>
                                20 FORI=BASETOBASE+7999:POKEI,0:NEXT:REM CLEAR BIT
                                <br>30 FORI=1024TO2023:POKEI,3:NEXT:REM SET COLOR TO CYAN AND BLACK
                            </code>
                        </blockquote>

                        <p>Now RUN the program again. You should see the screen clearing, then the greenish blue color,
                            cyan, should cover the whole screen. What we want to do now is to turn the dots on and off
                            on the HI-RES screen.
                        </p>
                        <p>To SET a dot (turn a dot ON) or UNSET a dot (turn a dot OFF) you must know how to find the
                            correct bit in the character memory that you have to set to a 1. In other words, you have to
                            find the character you need to change, the
                            row of the character, and which bit of the row that you have to change. You need a formula
                            to calculate this.</p>
                        <p>We will use X and Y to stand for the horizontal and vertical positions of a dot, The dot
                            where X=0 and Y=0 is at the upper-left of the display. Dots to the right have higher X
                            values, and the dots toward the bottom have higher
                            Y values. The best way to use bit mapping is to arrange the bit map display something like
                            this:</p>

                        <img src="https://s15.postimg.cc/tipa8n00r/c64_bmp_grid.png" alt="Bitmap Grid">

                        <p>Each dot will have an X and a Y coordinate. With this format it is easy to control any dot on
                            the screen.
                        </p>
                        <p>However, what you actually have is something like this:</p>

                        <img src="https://s15.postimg.cc/6va12mpnf/c64_bmp_ex.png" alt="Bitmap Example">

                        <p>The programmable characters which make up the bit map are arranged in 25 rows of 40 columns
                            each. While this is a good method of organization for text, it makes bit mapping somewhat
                            difficult. (There is a good reason for this method.
                            See the section on MIXED MODES.)</p>
                        <p>The following formula will make it easier to control a dot on the bit map screen:</p>

                        <p>The start of the display memory area is known as the BASE, The row number (from 0 to 24) of
                            your dot is:</p>

                        <blockquote>
                            <code>ROW = INT(Y/8) (There are 320 bytes per line.)</code>
                        </blockquote>

                        <p>The character position on that line (from 0 to 39) is:</p>

                        <blockquote>
                            <code>CHAR = INT(X/8) (There are 8 bytes per character.)</code>
                        </blockquote>

                        <p>The line of that character position (from 0 to 7) is:</p>

                        <blockquote>
                            <code>LINE = Y AND 7</code>
                        </blockquote>

                        <p>The bit of that byte is:</p>

                        <blockquote>
                            <code>BIT = 7-(X AND 7)</code>
                        </blockquote>

                        <p>Now we put these formulas together. The byte in which character memory dot (X,Y) is located
                            is calculated by:
                        </p>

                        <blockquote>
                            <code>BYTE = BASE + ROW*320+ CHAR*8 + LINE</code>
                        </blockquote>

                        <p>To turn on any bit on the grid with coordinates (X,Y), use this line:</p>

                        <blockquote>
                            <code>POKE BYTE, PEEK(BYTE) OR 2^BIT</code>
                        </blockquote>

                        <p>Let's add these calculations to the program. In the following example, the COMMODORE 64 will
                            plot a sine curve:</p>

                        <blockquote>
                            <code>
                                50 FORX=0TO319STEP.5:REM WAVE WILL FILL THE SCREEN
                                <br>60 Y=INT(90+80*SIN(X/10))
                                <br>70 CH=INT(X/8)
                                <br>80 RO=INT(Y/8)
                                <br>85 LN=YAND7
                                <br>90 BY=BASE+RO*320+8*CH+LN
                                <br>100 BI=7-(XAND7)
                                <br>110 POKEBY,PEEK(BY)OR(2^BI)
                                <br>120 NEXTX
                                <br>125 POKE1024,16
                                <br>130 GOTO130
                            </code>
                        </blockquote>

                        <p>The calculation in line 60 will change the values for the sine function from a range of +1 to
                            -1 to a range of 10 to 170. Lines 70 to 100 calculate the character, row, byte, and bit
                            being affected, using the formulae as shown above.
                            Line 125 signals the program is finished by changing the color of the top left corner of the
                            screen. Line 130 freezes the program by putting it into an infinite loop. When you have
                            finished looking at the display, just hold
                            down &lt;RUN/STOP&gt; and hit &lt;RESTORE&gt;.
                        </p>
                        <p>As a further example, you can modify the sine curve program to display a semicircle. Here are
                            the lines to type to make the changes:</p>

                        <blockquote>
                            <code>
                                50 FORX=0TO160:REM DO HALF THE SCREEN
                                <br>55 Y1=100+SQR(160*X-X*X)
                                <br>56 Y2=100-SQR(160*X-X*X)
                                <br>60 FORY=Y1TOY2STEPY1-Y2
                                <br>70 CH=INT(X/()
                                <br>80 RO=INT(Y/X)
                                <br>85 LNYAND7
                                <br>90 BY=BASE+RO*320+8*CH+LN
                                <br>100 BI=7-(XAND7)
                                <br>110 POKEBY,PEEK(BY)OR(2^BI)
                                <br>114 NEXT
                            </code>
                        </blockquote>

                        <p>This will create a semicircle in the HI-RES area of the screen.</p>

                        <p>
                            <strong>WARNING:</strong> BASIC variables can overlay your high-resolution screen. If you
                            need more memory space you must move the bottom of BASIC above the high-resolution screen
                            area. Or, you must move your high-resolution
                            screen area. This problem will NOT occur in machine language. It ONLY happens when you're
                            writing programs in BASIC.</p>
                    </section>

                    <hr>

                    <section class="main-section" id="Multi-Color_Bitmap_Mode">
                        <header>
                            <h4>Multi-Color Bitmap Mode</h4>
                        </header>

                        <p> Like multi-color mode characters, multi-color bit map mode allows you to display up to four
                            different colors in each 8 by 8 section of bit map. And as in multi-character mode, there is
                            a sacrifice of horizontal resolution (from
                            320 dots to 160 dots).</p>
                        <p>Multi-color bit map mode uses an 8K section of memory for the bit map. You select your colors
                            for multi-color bit map mode from (1) the background color register 0, (the screen
                            background color), (2) the video matrix (the upper
                            4 bits give one possible color, the lower 4 bits another), and (3) color memory.</p>
                        <p>Multi-color bit mapped mode is turned ON by setting bit 5 of 53265 ($D011) and bit 4 at
                            location 53270 ($D016) to a 1. The following POKE does this:</p>

                        <blockquote>
                            <code>POKE 53265,PEEK(53625)OR 32: POKE 53270,PEEK(53270)OR 16</code>
                        </blockquote>

                        <p> Multi-color bit mapped mode is turned OFF by setting bit 5 of 53265 ($D011) and bit 4 at
                            location 53270 ($D016) to a 0. The following POKE does this:</p>

                        <blockquote>
                            <code>POKE 53265,PEEK(53265)AND 223: POKE 53270,PEEK(53270)AND 239</code>
                        </blockquote>

                        <p>As in standard (HI-RES) bit mapped mode, there is a one to one correspondence between the 8K
                            section of memory being used for the display, and what is shown on the screen. However, the
                            horizontal dots are two bits wide. Each 2
                            bits in the display memory area form a dot, which can have one of 4 colors.</p>

                        <blockquote>
                            <pre>
    BITS    COLOR INFORMATION COMES FROM

     00     Background color #0 (screen color)
     01     Upper 4 bits of screen memory
     10     Lower 4 bits of screen memory
     11     Color nybble (nybble = 1/2 byte = 4 bits)
                            </pre>
                        </blockquote>
                    </section>

                    <hr>

                    <section class="main-section" id="Smooth_Scrolling">
                        <header>
                            <h4>Smooth Scrolling</h4>
                        </header>

                        <p>The VIC-II chip supports smooth scrolling in both the horizontal and vertical directions.
                            Smooth scrolling is a one pixel movement of the entire screen in one direction. It can move
                            either UP, or down, or left, or right. It is
                            used to move new information smoothly onto the screen, while smoothly removing characters
                            from the other side.</p>
                        <p> While the VIC-II chip does much of the task for you, the actual scrolling must be done by a
                            machine language program. The VIC-II chip features the ability to place the video screen in
                            any of 8 horizontal positions, and 8 vertical
                            positions. Positioning is controlled by the VIC-II scrolling registers. The VIC-II chip also
                            has a 38 column mode, and a 24 row mode. the smaller screen sizes are used to give you a
                            place for your new data to scroll on from.
                        </p>
                        <p>The following are the steps for SMOOTH SCROLLING:</p>

                        <ol>
                            <li>Shrink the screen (the border will expand).</li>
                            <li>Set the scrolling register to maximum (or minimum value depending upon the direction of
                                your scroll).
                            </li>
                            <li>Place the new data on the proper (covered) portion of the screen.</li>
                            <li>Increment (or decrement) the scrolling register until it reaches the maximum (or
                                minimum) value.</li>
                            <li>At this point, use your machine language routine to shift the entire screen one entire
                                character in the direction of the scroll.</li>
                            <li>Go back to step 2.</li>
                        </ol>

                        <p>To go into 38 column mode, bit 3 of location 53270 ($D016) must be set to a 0. The following
                            POKE does this:</p>

                        <blockquote>
                            <code>POKE 53270,PEEK(53270)AND 247</code>
                        </blockquote>

                        <p>To return to 40 column mode, set bit 3 of location 53270 ($D016) to a 1.The following POKE
                            does this:</p>

                        <blockquote>
                            <code>POKE 53270,PEEK(53270)OR 8</code>
                        </blockquote>

                        <p>To go into 24 row mode, bit 3 of location 53265 ($D011) must be set to a 0. The following
                            POKE will do this:</p>

                        <blockquote>
                            <code>POKE 53265,PEEK(53265)AND 247</code>
                        </blockquote>

                        <p>To return to 25 row mode, set bit 3 of location 53265 ($D011) to a 1. The following POKE does
                            this:
                        </p>

                        <blockquote>
                            <code>POKE 53265,PEEK(53265)OR 8</code>
                        </blockquote>

                        <p>When scrolling in the X direction, it is necessary to place the VIC-II chip into 38 column
                            mode. This gives new data a place to scroll from. When scrolling LEFT, the new data should
                            be placed on the right. When scrolling RIGHT
                            the new data should be placed on the left. Please note that there are still 40 columns to
                            screen memory, but only 38 are visible.</p>
                        <p>When scrolling in the Y direction, it is necessary to place the VIC-II chip into 24 row mode.
                            When scrolling UP, place the new data in the LAST row. When scrolling DOWN, place the new
                            data on the FIRST row. Unlike X scrolling,
                            where there are covered areas on each side of the screen, there is only one covered area in
                            Y scrolling. When the Y scrolling register is set to 0, the first line is covered, ready for
                            new data. When the Y scrolling register
                            is set to 7 the last row is covered.</p>
                        <p>For scrolling in the X direction, the scroll register is located in bits 2 to 0 of the VIC-II
                            control register at location 53270 ($D016 in HEX). As always, it is important to affect only
                            those bits. The following POKE does this:</p>

                        <blockquote>
                            <code>POKE 53270,(PEEK(53270)AND 248)+X</code>
                        </blockquote>

                        <p>where X is the X position of the screen from 0 to 7.</p>
                        <p>For scrolling in the Y direction, the scroll register is located in bits 2 to 0 of the VIC-II
                            control register at location 53265 ($D011 in HEX). As always, it is important to affect only
                            those bits. The following POKE does this:</p>

                        <blockquote>
                            <code>POKE 53265,(PEEK(53265)AND 248)+Y</code>
                        </blockquote>

                        <p>where Y is the Y position of the screen from 0 to 7.</p>
                        <p>To scroll text onto the screen from the bottom, you would step the low-order 3 bits of
                            location 53265 from 0-7, put more data on the covered line at the bottom of the screen, and
                            then repeat the process. To scroll characters onto
                            the screen from left to right, you would step the low- order 3 bits of location 53270 from 0
                            to 7, print or POKE another column of new data into column 0 of the screen, then repeat the
                            process.</p>
                        <p>If you step the scroll bits by -1, your text will move in the opposite direction.
                        </p>

                        <p class="example">Example: Text scrolling onto the bottom of the screen</p>
                        <blockquote>
                            <code>
                                START TOK64 PAGE130.PRG
                                <br>10 POKE53265,PEEK(53265)AND247 :REM GO INTO 24 ROW MODE
                                <br>20 PRINTCHR$(147) :REM CLEAR THE SCREEN
                                <br>30 FORX=1TO24:PRINTCHR$(17);:NEXT :REM MOVE THE CURSOR TO THE BOTTOM
                                <br>40 POKE53265,(PEEK(53265)AND248)+7:PRINT :REM POSITION FOR 1ST SCROLL
                                <br>50 PRINT" HELLO";
                                <br>60 FORP=6TO0STEP-1
                                <br>70 POKE53265,(PEEK(53265)AND248)+P
                                <br>80 FORX=1TO50:NEXT :REM DELAY LOOP
                                <br>90 NEXT:GOTO40
                                <br>STOP TOK64
                            </code>
                        </blockquote>
                    </section>

                    <hr>

                    <section class="main-section" id="Sprites">
                        <header>
                            <h4>Sprites</h4>
                        </header>

                        <p> A SPRITE is a special type of user definable character which can be displayed anywhere on
                            the screen. Sprites are maintained directly by the VIC-II chip. And all you have to do is
                            tell a sprite "what to look like," "what color
                            to be," and "where to appear." The VIC-II chip will do the rest! Sprites can be any of the
                            16 colors available.</p>
                        <p>Sprites can be used with ANY of the other graphics modes, bit mapped, character, multi-color,
                            etc., and they'll keep their shape in all of them. The sprite carries its own color
                            definition, its own mode (HI-RES or multi-colored),
                            and its own shape.</p>
                        <p>Up to 8 sprites at a time can be maintained by the VIC-II chip automatically. More sprites
                            can be displayed using RASTER INTERRUPT techniques.
                        </p>
                        <p>The features of SPRITES include:</p>

                        <ol>
                            <li>24 horizontal dot by 21 vertical dot size.</li>
                            <li>Individual color control for each sprite.</li>
                            <li>Sprite multi-color mode.</li>
                            <li>Magnification (2x) in horizontal, vertical, or both directions.</li>
                            <li>Selectable sprite to background priority.</li>
                            <li>Fixed sprite to sprite priorities.</li>
                            <li>Sprite to sprite collision detection.</li>
                            <li>Sprite to background collision detection.</li>
                        </ol>

                        <p>These special sprite abilities make it simple to program many arcade style games. Because the
                            sprites are maintained by hardware, it is even possible to write a good quality game in
                            BASIC!
                        </p>
                        <p>There are 8 sprites supported directly by the VIC-II chip. They are numbered from 0 to 7.
                            Each of the sprites has it own definition location, position registers and color register,
                            and has its own bits for enable and collision
                            detection.</p>

                        <h5>Defining a Sprite</h5>

                        <p>Sprites are defined like programmable characters are defined. However, since the size of the
                            sprite is larger, more bytes are needed. A sprite is 24 by 21 dots, or 504 dots. This works
                            out to 63 bytes (504/8 bits) needed to define
                            a sprite. The 63 bytes are arranged in 21 rows of 3 bytes each. A sprite definition looks
                            like this.</p>
                        <blockquote>
                            <pre>
                    BYTE 0  BYTE 1  BYTE 2
                    BYTE 3  BYTE 4  BYTE 5
                    BYTE 6  BYTE 7  BYTE 8
                      ..      ..      ..
                      ..      ..      ..
                      ..      ..      ..
                    BYTE 60 BYTE 61 BYTE 62
                            </pre>
                        </blockquote>

                        <p>Another way to view how a sprite is created is to take a look at the sprite definition block
                            on the bit level. It would look something like Figure 3-2.</p>

                        <img src="https://s15.postimg.cc/4te52aotn/c64_sprite_def_blk.png"
                            alt="Sprite Definition Block">

                        <p>In a standard (HI-RES) sprite, each bit set to I is displayed in that sprite's foreground
                            color. Each bit set to 0 is transparent and will display whatever data is behind it. This is
                            similar to a standard character.
                        </p>
                        <p> Multi-color sprites are similar to multi-color characters. Horizontal resolution is traded
                            for extra color resolution. The resolution of the sprite becomes 12 horizontal dots by 21
                            vertical dots. Each dot in the sprite becomes
                            twice as wide, but the number of colors displayable in the sprite is increased to 4.</p>

                        <h5>Sprite Pointers</h5>

                        <p>Even though each sprite takes only 63 bytes to define, one more byte is needed as a place
                            holder at the end of each sprite. Each sprite, then, takes up 64 bytes. This makes it easy
                            to calculate where in memory your sprite definition
                            is, since 64 bytes is an even number and in binary it's an even power.</p>
                        <p>Each of the 8 sprites has a byte associated with it called the SPRITE POINTER. The sprite
                            pointers control where each sprite definition is located in memory. These 8 bytes are always
                            located as the lost 8 bytes of the 1K chunk
                            of screen memory. Normally, on the Commodore 64, this means they begin at location 2040
                            ($07F8 in HEX). However, if you move the screen, the location of your sprite pointers will
                            also move.</p>
                        <p>Each sprite pointer can hold a number from 0 to 255. This number points to the definition for
                            that sprite. Since each sprite definition takes 64 bytes, that means that the pointer can
                            "see" anywhere in the 16K block of memory that
                            the VIC-II chip can access (since 256*64=16K).
                        </p>
                        <p>If sprite pointer #0, at location 2040, contains the number 14, for example, this means that
                            sprite 0 will be displayed using the 64 bytes beginning at location 14*64 = 896 which is in
                            the cassette buffer. The following formula
                            makes this clear:</p>

                        <blockquote>
                            <code>LOCATION = (BANK * 16384) + (SPRITE POINTER VALUE * 64)</code>
                        </blockquote>

                        <p>Where BANK is the 16K segment of memory that the VIC-II chip is looking at and is from 0 to
                            3.
                        </p>

                        <p>The above formula gives the start of the 64 bytes of the sprite definition block.</p>
                        <p>When the VIC-II chip is looking at BANK 0 or BANK 2, there is a ROM IMAGE of the character
                            set present in certain locations, as mentioned before. Sprite definitions can NOT be placed
                            there. If for some reason you need more than
                            128 different sprite definitions, you should use one of the banks without the ROM IMAGE, 1
                            or 3.</p>

                        <h5>Turning Sprites On</h5>

                        <p>The VIC-II control register at location 53269 ($D015 in HEX) is known as the SPRITE ENABLE
                            register. Each of the sprites has a bit in this register which controls whether that sprite
                            is ON or OFF. The register looks like this:</p>

                        <blockquote>
                            <code>$D015 7 6 5 4 3 2 1 0</code>
                        </blockquote>

                        <p>To turn on sprite 1, for example, it is necessary to turn that bit to a 1. The following POKE
                            does this:
                        </p>

                        <blockquote>
                            <code>POKE 53269.PEEK(53269)OR 2</code>
                        </blockquote>

                        <p>A more general statement would be the following:</p>

                        <blockquote>
                            <code>POKE 53269,PEEK(53269)OR (2^SN)</code>
                        </blockquote>

                        <p>where SN is the sprite number, from 0 to 7.</p>

                        <p>
                            <strong>NOTE:</strong> A sprite must be turned ON before it can be seen.</p>

                        <h5>Turning Sprites Off</h5>

                        <p>A sprite is turned off by setting its bit in the VIC-II control register at 53269 ($D015 in
                            HEX) to a 0. The following POKE will do this:</p>

                        <blockquote>
                            <code>POKE 53269,PEEK(53269)AND(255-2^SN)</code>
                        </blockquote>

                        <p>where SN is the sprite number from 0 to 7.</p>

                        <h5>Colors</h5>

                        <table>
                            <thead>
                                <tr>
                                    <th>Address</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>53287 ($D027)</td>
                                    <td>SPRITE 0 COLOR REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53288 ($D028)</td>
                                    <td>SPRITE 1 COLOR REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53289 ($D029)</td>
                                    <td>SPRITE 2 COLOR REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53290 ($D02A)</td>
                                    <td>SPRITE 3 COLOR REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53291 ($D02B)</td>
                                    <td>SPRITE 4 COLOR REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53292 ($D02C)</td>
                                    <td>SPRITE 5 COLOR REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53293 ($D02D)</td>
                                    <td>SPRITE 6 COLOR REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53294 ($D02E)</td>
                                    <td>SPRITE 7 COLOR REGISTER</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>All dots in the sprite will be displayed in the color contained in the sprite color register.
                            The rest of the sprite will be transparent, and will show whatever is behind the sprite.</p>

                        <h5>Multi-Color Mode</h5>

                        <p>Multi-color mode allows you to have up to 4 different colors in each sprite. However, just
                            like other multi-color modes, horizontal resolution is cut in half. In other words, when
                            you're working with sprite multi-color mode (like
                            in multi-color character mode), instead of 24 dots across the sprite, there are 12 pairs of
                            dots. Each pair of dots is called a BIT PAIR. Think of each bit pair (pair of dots) as a
                            single dot in your overall sprite when it
                            comes to choosing colors for the dots in your sprites. The table below gives you the bit
                            pair values needed to turn ON each of the four colors you've chosen for your sprite:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Bit Pair</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>00</td>
                                    <td>TRANSPARENT, SCREEN COLOR</td>
                                </tr>
                                <tr>
                                    <td>01</td>
                                    <td>SPRITE MULTI-COLOR REGISTER #0 (53285) ($D025)</td>
                                </tr>
                                <tr>
                                    <td>10</td>
                                    <td>SPRITE COLOR REGISTER</td>
                                </tr>
                                <tr>
                                    <td>11</td>
                                    <td>SPRITE MULTI-COLOR REGISTER #I (53286) ($D026)</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>
                            <strong>NOTE:</strong> The sprite background color is a 10. The character foreground color
                            is a 11.</p>

                        <h5>Setting a Sprite to Multi-Color Mode</h5>

                        <p>To switch a sprite into multi-color mode you must turn ON the VIC-II control register at
                            location 53276 ($D01C). The following POKE does this:</p>

                        <blockquote>
                            <code>POKE 53276,PEEK(53276)OR(2^SN)</code>
                        </blockquote>

                        <p>where SN is the sprite number (0 to 7).</p>
                        <p>To switch a sprite out of multi-color mode you must turn OFF the VIC-II control register at
                            location 53276 ($D01C). The following POKE does this:</p>

                        <blockquote>
                            <code>POKE 53276,PEEK(53276)AND(255-2^SN)</code>
                        </blockquote>

                        <p>where SN is the sprite number (0 to 7).</p>

                        <h5>Expanded Sprites</h5>

                        <p>The VIC-II chip has the ability to expand a sprite in the vertical direction, the horizontal
                            direction, or both at once. When expanded, each dot in the sprite is twice as wide or twice
                            as tall. Resolution doesn't actually increase...
                            the sprite just gets bigger.</p>
                        <p>To expand a sprite in the horizontal direction, the corresponding bit in the VIC-II control
                            register at location 53277 ($D01D in HEX) must be turned ON (set to a 1). The following POKE
                            expands a sprite in the X direction:
                        </p>

                        <blockquote>
                            <code>POKE 53277,PEEK(53277)OR(2^SN)</code>
                        </blockquote>

                        <p>where SN is the sprite number from 0 to 7.</p>
                        <p>To unexpand a sprite in the horizontal direction, the corresponding bit in the VIC-II control
                            register at location 53277 ($D01D in HEX) must be turned OFF (set to a 0). The following
                            POKE "unexpands" a sprite in the X direction:</p>

                        <blockquote>
                            <code>POKE 53277,PEEK(53277)AND (255-2^SN)</code>
                        </blockquote>

                        <p>where SN is the sprite number from 0 to 7.</p>

                        <p>To expand a sprite in the vertical direction, the corresponding bit in the VIC-II control
                            register at location 53271 ($D017 in HEX) must be turned ON (set to a 1). The following POKE
                            expands a sprite in the Y direction:
                        </p>

                        <blockquote>
                            <code>POKE 53271,PEEK(53271)OR(2^SN)</code>
                        </blockquote>

                        <p>where SN is the sprite number from 0 to 7.</p>
                        <p>To unexpand a sprite in the vertical direction, the corresponding bit in the VIC-II control
                            register at location 53271 ($D017 in HEX) must be turned OFF (set to a 0). The following
                            POKE "unexpands" a sprite in the Y direction:</p>

                        <blockquote>
                            <code>POKE 53271,PEEK(53271)AND (255-2^SN)</code>
                        </blockquote>

                        <p>where SN is the sprite number from 0 to 7.</p>

                        <h5>Sprite Positioning</h5>

                        <p>Once you've made a sprite you want to be able to move it around the screen. To do this, your
                            Commodore 64 uses three positioning registers:</p>

                        <ol>
                            <li>SPRITE X POSITION REGISTER</li>
                            <li>SPRITE Y POSTIION REGISTER</li>
                            <li>MOST SIGNIFICANT BIT X POSITION REGISTER</li>
                        </ol>

                        <p>Each sprite has an X position register, a Y position register, and a bit in the X most
                            significant bit register. This lets you position your sprites very accurately. You can place
                            your sprite in 512 possible X positions and 256
                            possible Y positions.</p>
                        <p>The X and Y position registers work together, in pairs, as a team. The locations of the X and
                            Y registers appear in the memory map as follows: First is the X register for sprite 0, then
                            the Y register for sprite 0.</p>
                        <p>Next comes the X register for sprite 1, the Y register for sprite 1, and so on. After all 16
                            X and Y registers comes the most significant bit in the X position (X MSB) located in its
                            own register.
                        </p>
                        <p>The chart below lists the locations of each sprite position register. You use the locations
                            at their appropriate time through POKE statements:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th colspan="2">Location</th>
                                    <th rowspan="2">Description</th>
                                </tr>
                                <tr>
                                    <th>Decimal</th>
                                    <th>Hex</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>53248</td>
                                    <td>($D000)</td>
                                    <td>SPRITE 0 X POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53249</td>
                                    <td>($D001)</td>
                                    <td>SPRITE 0 Y POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53250</td>
                                    <td>($D002)</td>
                                    <td>SPRITE 1 X POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53251</td>
                                    <td>($D003)</td>
                                    <td>SPRITE 1 Y POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53252</td>
                                    <td>($D004)</td>
                                    <td>SPRITE 2 X POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53253</td>
                                    <td>($D005)</td>
                                    <td>SPRITE 2 Y POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53254</td>
                                    <td>($D006)</td>
                                    <td>SPRITE 3 X POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53255</td>
                                    <td>($D007)</td>
                                    <td>SPRITE 3 Y POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53256</td>
                                    <td>($D008)</td>
                                    <td>SPRITE 4 X POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53257</td>
                                    <td>($D009)</td>
                                    <td>SPRITE 4 Y POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53258</td>
                                    <td>($D00A)</td>
                                    <td>SPRITE 5 X POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53259</td>
                                    <td>($D00B)</td>
                                    <td>SPRITE 5 Y POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53260</td>
                                    <td>($D00C)</td>
                                    <td>SPRITE 6 X POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53261</td>
                                    <td>($D00D)</td>
                                    <td>SPRITE 6 Y POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53262</td>
                                    <td>($D00E)</td>
                                    <td>SPRITE 7 X POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53263</td>
                                    <td>($D00F)</td>
                                    <td>SPRITE 7 Y POSITION REGISTER</td>
                                </tr>
                                <tr>
                                    <td>53264</td>
                                    <td>($D010)</td>
                                    <td>SPRITE X MSB REGISTER</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>The position of a sprite is calculated from the TOP LEFT corner of the 24 dot by 21 dot area
                            that your sprite can be designed in. It does NOT matter how many or how few dots you use to
                            make up a sprite. Even if only one dot is
                            used as a sprite, and you happen to want it in the middle of the screen, you must still
                            calculate the exact positioning by starting at the top left corner location.
                        </p>

                        <h5>Vertical Positioning</h5>

                        <p>Setting up positions in the horizontal direction is a little more difficult than vertical
                            positioning, so we'll discuss vertical (Y) positioning first.</p>
                        <p>There are 200 different dot positions that can be individually programmed onto your TV screen
                            in the Y direction. The sprite Y position registers can handle numbers up to 255. This means
                            that you have more than enough register
                            locations to handle moving a sprite up and down. You also want to be able to smoothly move a
                            sprite on and off the screen. More than 200 values are needed for this.</p>
                        <p>The first on-screen value from the top of the screen, and in the Y direction for an
                            unexpanded sprite is 30. For a sprite expanded in the Y direction it would be 9. (Since each
                            dot is twice as tall, this makes a certain amount
                            of sense, as the initial position is STILL calculated from the top left corner of the
                            sprite.)</p>
                        <p>The first Y value in which a sprite (expanded or not) is fully on the screen (all 21 possible
                            lines displayed) is 50.</p>
                        <p>The last Y value in which an unexpanded sprite is fully on the screen is 229. The last Y
                            value in which an expanded sprite is fully on the screen is 208.</p>
                        <p>The first Y value in which a sprite is fully off the screen is 250.</p>

                        <p class="example">Example</p>
                        <blockquote>
                            <code>
                                START TOK64 PAGE139.PRG
                                <br>10 PRINT"{CLEAR}" :REM CLEAR SCREEN
                                <br>20 POKE 2040,13 :REM GET SPRITE 0 DATA FROM BLOCK 13
                                <br>30 FORI=0TO62:POKE832+I,129:NEXT :REM POKE SPRITE DATA INTO BLOCK 13
                                <br>40 V=53248 :REM SET BEGINNING OF VIDEO CHIP
                                <br>50 POKEV+21,1 :REM ENABLE SPRITE 0
                                <br>60 POKEV+39,1 :REM SET SPRITE 0 COLOR
                                <br>70 POKEV+1,100 :REM SET SPRITE 0 Y POSITION
                                <br>80 POKEV+16,0:POKEV,100 :REM SET SPRITE 0 X POSITION
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <h5>Horizontal Positioning</h5>

                        <p>Positioning in the horizontal direction is more complicated because there are more than, 256
                            positions. This means that an extra bit, or 9th bit is used to control the X position. By
                            adding the extra bit when necessary a sprite
                            now has 512 possible positions in the left/right, X, direction. This makes more possible
                            combinations than can be seen on the visible part of the screen. Each sprite can have a
                            position from 0 to 511. However, only those values
                            between 24 and 343 are visible on the screen. If the X position of a sprite is greater than
                            255 (on the right side of the screen), the bit in the X MOST SIGNIFICANT BIT POSITION
                            register must be set to a 1 (turned ON). If the
                            X position of a sprite is less than 256 (on the left side of the screen), then the X MSB of
                            that sprite must be 0 (turned OFF). Bits 0 to 7 of the X MSB register correspond to sprites
                            0 to 7, respectively.
                        </p>

                        <img src="https://s5.postimg.cc/qvpyeikdj/c64_fig3-3a.png" alt="Figure 3-3a">
                        <br>
                        <img src="https://s5.postimg.cc/5ytq9v1s7/c64_fig3-3b.png" alt="Figure 3-3b">

                        <p>The following is a program to move a sprite across the screen:</p>

                        <p class="example">Example</p>

                        <blockquote>
                            <code>
                                START TOK64 P142_1.PRG
                                <br>10 PRINT"{CLEAR}"
                                <br>20 POKE2040,13
                                <br>30 FORI=0TO62:POKE832+I,129:NEXT
                                <br>40 V=53248
                                <br>50 POKEV+21,1
                                <br>60 POKEV+39,1
                                <br>70 POKEV+1,100
                                <br>80 FORJ=0TO347
                                <br>90 HX=INT(J/256):LX=J-256*HX
                                <br>100 POKEV,LX:POKEV+16,HX:NEXT
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>When moving expanded sprites onto the left side of the screen in the X direction, you have to
                            start the sprite OFF SCREEN on the RIGHT SIDE. This is because an expanded sprite is larger
                            than the amount of space available on the
                            left side of the screen.</p>

                        <p class="example">Example</p>

                        <blockquote>
                            <code>
                                START TOK64 P142_2.PRG
                                <br>10 PRINT"{CLEAR}"
                                <br>20 POKE2040,13
                                <br>30 FORI=0TO62:POKE832+I,129:NEXT
                                <br>40 V=53248
                                <br>50 POKEV+21,1
                                <br>60 POKEV+39,1:POKEV+23,1:POKEV+29,1
                                <br>70 POKEV+1,100
                                <br>80 J=488
                                <br>90 HX=INT(J/256):LX=J-256*HX
                                <br>100 POKEV,LX:POKEV+16,HX
                                <br>110 J=J+1:IFJ&gt;511THENJ=0
                                <br>120 IFJ&gt;488ORJ&lt;348GOTO90
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>The charts in Figure 3-3 explain sprite positioning.</p>
                        <p>By using these values, you can position each sprite anywhere. By moving the sprite a single
                            dot position at a time, very smooth movement is easy to achieve.</p>

                        <h5>Sprite Positioning Summary</h5>

                        <p>Unexpanded sprites are at least partially visible in the 40 column, by 25 row mode within the
                            following parameters:
                        </p>

                        <blockquote>
                            <code>
                                1 &lt; X &lt; 343
                                <br>
                                <br>30 &lt; Y &lt; 249
                            </code>
                        </blockquote>

                        <p>In the 38 column mode, the X parameters change to she following:</p>

                        <blockquote>
                            <code>8 &lt;= X &lt;= 334</code>
                        </blockquote>

                        <p>In the 24 row mode, the Y parameters change to the following:</p>

                        <blockquote>
                            <code>34 &lt;= Y &lt;= 245</code>
                        </blockquote>

                        <p>Expanded sprites are at least partially visible in the 40 column, by 25 row mode within the
                            following parameters:
                        </p>

                        <blockquote>
                            <code>
                                489 &gt;= X &lt;= 343
                                <br>9 &gt;= Y &lt;= 249
                            </code>
                        </blockquote>

                        <p>In the 38 column mode, the X parameters change to the following:</p>

                        <blockquote>
                            <code>496 &gt;= X &lt;= 334</code>
                        </blockquote>

                        <p>In the 24 row mode, the Y parameters change to the following:</p>

                        <blockquote>
                            <code>13 &lt;= Y &lt;= 245</code>
                        </blockquote>

                        <h5>Sprite Display Priorities</h5>

                        <p>Sprites have the ability to cross each other's paths, as well as cross in front of, or behind
                            other objects on the screen. This can give you a truly three dimensional effect for games.
                        </p>
                        <p>Sprite to sprite priority is fixed. That means that sprite 0 has the highest priority, sprite
                            1 has the next priority, and so on, until we get to sprite 7, which has the lowest priority.
                            In other words, if sprite 1 and sprite 6
                            are positioned so that they cross each other, sprite 1 will be in front of sprite 6.</p>
                        <p>So when you're planning which sprites will appear to be in the foreground of the picture,
                            they must be assigned lower sprite numbers than those sprites you want to put towards the
                            back of the scene. Those sprites will be given
                            higher sprite numbers.</p>
                        <p>
                            <strong>NOTE:</strong> A "window" effect is possible. If a sprite with higher priority has
                            "holes" in it (areas where the dots are not set to 1 and thus turned ON), the sprite with
                            the lower priority will show through. This
                            also happens with sprite and background data.</p>
                        <p>Sprite to background priority is controllable by the SPRITE-BACKGROUND priority register
                            located at 53275 ($D01B). Each sprite has a bit in this register. If that bit is 0, that
                            sprite has a higher priority than the background
                            on the screen. In other words, the sprite appears in front of background data. If that bit
                            is a 1, that sprite has a lower priority than the background. Then the sprite appears behind
                            the background data.</p>

                        <h5>Collision Detects</h5>

                        <p>One of the more interesting aspects of the VIC-II chip is its collision detection abilities.
                            Collisions can be detected between sprites, or between sprites and background data. A
                            collision occurs when a non-zero part of a sprite
                            overlaps a non-zero portion of another sprite or characters on the screen.
                        </p>

                        <h5>Sprite to Sprite Collisions</h5>

                        <p>Sprite to sprite collisions are recognized by the computer, or flagged, in the sprite to
                            sprite collision register at location 53278 ($D01E in HEX) in the VIC-II chip control
                            register. Each sprite has a bit in this register. If
                            that bit is a 1, then that sprite is involved in a collision. The bits in this register will
                            remain set until read (PEEKed). Once read, the register is automatically cleared, so it is a
                            good idea to save the value in a variable
                            until you are finished with it.
                        </p>
                        <p>
                            <strong>NOTE:</strong> Collisions can take place even when the sprites are off screen.</p>

                        <h5>Sprite to Data Collisions</h5>

                        <p>Sprite to data collisions are detected in the sprite to data collision register at location
                            53279 ($D01F in HEX) of the VIC-II chip control register.
                        </p>
                        <p>Each sprite has a bit in this register. If that bit is a 1 , then that sprite is involved in
                            a collision. The bits in this register remain set until read (PEEKed). Once read, the
                            register is automatically cleared, so it is a good
                            idea to save the value in a variable until you are finished with it.
                        </p>
                        <p>
                            <strong>NOTE:</strong> MULTI-COLOR data 01 is considered transparent for collisions, even
                            though it shows up on the screen. When setting up a background screen, it is a good idea to
                            make everything that should not cause a collision
                            01 in multi-color mode.</p>

                        <p class="example">Sprite Example 1</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE146.PRG
                                <br>10 REM SPRITE EXAMPLE 1... THE HOT AIR BALLOON
                                <br>30 VIC=13*4096:REM THIS IS WHERE THE VIC REGISTERS BEGIN
                                <br>35 POKEVIC+21,1:REM ENABLE SPRITE 0
                                <br>36 POKEVIC+33,14:REM SET BACKGROUND COLOR TO LIGHT BLUE
                                <br>37 POKEVIC+23,1:REM EXPAND SPRITE 0 IN Y
                                <br>38 POKEVIC+29,1:REM EXPAND SPRITE 0 IN X
                                <br>40 POKE2040,192:REM SET SPRITE 0'S POINTER
                                <br>180 POKEVIC+0,100:REM SET SPRITE 0'S X POSITION
                                <br>190 POKEVIC+1,100:REM SET SPRITE 0'S Y POSITION
                                <br>220 POKEVIC+39,1:REM SET SPRITE 0'S COLOR
                                <br>250 FORY=0TO63:REM BYTE COUNTER WITH SPRITE LOOP
                                <br>300 READA:REM READ IN A BYTE
                                <br>310 POKE192*64+Y,A:REM STORE THE DATA IN SPRITE AREA
                                <br>320 NEXTY:REM CLOSE LOOP
                                <br>330 DX=1:DY=1
                                <br>340 X=PEEK(VIC):REM LOOK AT SPRITE 0'S X POSITION
                                <br>350 Y=PEEK(VIC+1):REM LOOK AT SPRITE 0'S Y POSITION
                                <br>360 IFY=50ORY=208THENDY=-DY:REM IF Y IS ON THE EDGE OF THE...
                                <br>370 REM SCREEN, THEN REVERSE DELTA Y
                                <br>380 IFX=24AND(PEEK(VIC+16)AND1)=0THENDX=-DX:REM IF SPRITE IS TOUCHING...
                                <br>390 REM THE LEFT EDGE(X=24 AND THE MSB FOR SPRITE 0 IS 0), REVERSE IT
                                <br>400 IFX=40AND(PEEK(VIC+16)AND1)=1THENDX=-DX:REM IF SPRITE IS TOUCHING...
                                <br>410 REM THE RIGHT EDGE (X=40 AND THE MSB FOR SPRITE 0 IS 1), REVERSE IT
                                <br>420 IFX=255ANDDX=1THENX=-1:SIDE=1
                                <br>430 REM SWITCH TO OTHER SIDE OF THE SCREEN
                                <br>440 IFX=0ANDDX=-1THENX=256:SIDE=0
                                <br>450 REM SWITCH TO OTHER SIDE OF THE SCREEN
                                <br>460 X=X+DX:REM ADD DELTA X TO X
                                <br>470 X=XAND255:REM MAKE SURE X IS IN ALLOWED RANGE
                                <br>480 Y=Y+DY:REM ADD DELTA Y TO Y
                                <br>485 POKEVIC+16,SIDE
                                <br>490 POKEVIC,X:REM PUT NEW X VALUE INTO SPRITE 0'S X POSITION
                                <br>510 POKEVIC+1,Y:REM PUT NEW Y VALUE INTO SPRITE 0'S Y POSITION
                                <br>530 GOTO340
                                <br>600 REM ***** SPRITE DATA *****
                                <br>610 DATA0,127,0,1,255,192,3,255,224,3,231,224
                                <br>620 DATA7,217,240,7,223,240,7,217,240,3,231,224
                                <br>630 DATA3,255,224,3,255,224,2,255,160,1,127,64
                                <br>640 DATA1,62,64,0,156,128,0,156,128,0,73,0,0,73,0
                                <br>650 DATA0,62,0,0,62,0,0,62,0,0,28,0,0
                                <br>STOP TOK64XT HERE TO CONVERT CASE
                            </code>
                        </blockquote>

                        <p class="example">Sprite Example 2</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE147.PRG
                                <br>10 REM SPRITE EXAMPLE 2...
                                <br>20 REM THE HOT AIR BALLOON AGAIN
                                <br>30 VIC=13*4096:REM THIS IS WHERE THE VIC REGISTERS BEGIN
                                <br>35 POKEVIC+21,63:REM ENABLE SPRITES 0 THRU 5
                                <br>36 POKEVIC+33,14:REM SET BACKGROUND COLOR TO LIGHT BLUE
                                <br>37 POKEVIC+23,3:REM EXPAND SPRITES 0 AND 1 IN Y
                                <br>38 POKEVIC+29,3:REM EXPAND SPRITES 0 AND 1 IN X
                                <br>40 POKE2040,192:REM SET SPRITE 0'S POINTER
                                <br>50 POKE2041,193:REM SET SPRITE 1'S POINTER
                                <br>60 POKE2042,192:REM SET SPRITE 2'S POINTER
                                <br>70 POKE2043,193:REM SET SPRITE 3'S POINTER
                                <br>80 POKE2044,192:REM SET SPRITE 4'S POINTER
                                <br>90 POKE2045,193:REM SET SPRITE 5'S POINTER
                                <br>100 POKEVIC+4,30:REM SET SPRITE 2'S X POSITION
                                <br>110 POKEVIC+5,58:REM SET SPRITE 2'S Y POSITION
                                <br>120 POKEVIC+6,65:REM SET SPRITE 3'S X POSITION
                                <br>130 POKEVIC+7,58:REM SET SPRITE 3'S Y POSITION
                                <br>140 POKEVIC+8,100:REM SET SPRITE 4'S X POSITION
                                <br>150 POKEVIC+9,58:REM SET SPRITE 4'S Y POSITION
                                <br>160 POKEVIC+10,100:REM SET SPRITE 5'S X POSITION
                                <br>170 POKEVIC+11,58:REM SET SPRITE 5'S Y POSITION
                                <br>175 PRINT"{WHITE}{CLEAR}"TAB(15)"THIS IS TWO HIRES SPRITES";
                                <br>176 PRINTTAB(55)"ON TOP OF EACH OTHER"
                                <br>180 POKEVIC+0,100:REM SET SPRITE 0'S X POSITION
                                <br>190 POKEVIC+1,100:REM SET SPRITE 0'S Y POSITION
                                <br>200 POKEVIC+2,100:REM SET SPRITE 1'S X POSITION
                                <br>210 POKEVIC+3,100:REM SET SPRITE 1'S Y POSITION
                                <br>220 POKEVIC+39,1:REM SET SPRITE 0'S COLOR
                                <br>230 POKEVIC+41,1:REM SET SPRITE 2'S COLOR
                                <br>240 POKEVIC+43,1:REM SET SPRITE 4'S COLOR
                                <br>250 POKEVIC+40,6:REM SET SPRITE 1'S COLOR
                                <br>260 POKEVIC+42,6:REM SET SPRITE 3'S COLOR
                                <br>270 POKEVIC+44,6:REM SET SPRITE 5'S COLOR
                                <br>280 FORX=192TO193:REM THE START OF THE LOOP THAT DEFINES THE SPRITES
                                <br>290 FORY=0TO63:REM BYTE COUNTER WITH SPRITE LOOP
                                <br>300 READA:REM READ IN A BYTE
                                <br>310 POKEX*64+Y,A:REM STORE THE DATA IN SPRITE AREA
                                <br>320 NEXTY,X:REM CLOSE LOOPS
                                <br>330 DX=1:DY=1
                                <br>340 X=PEEK(VIC):REM LOOK AT SPRITE 0'S X POSITION
                                <br>350 IFY=50ORY=208THENDY=-DY:REM IF Y IS ON THE EDGE OF THE...
                                <br>370 REM SCREEN, THEN REVERSE DELTA Y
                                <br>380 IFX=24AND(PEEK(VIC+16)AND1)=0THENDX=-DX:REM IF SPRITE IS...
                                <br>390 REM TOUCHING THE LEFT EDGE, THEN REVERSE IT
                                <br>400 IFX=40AND(PEEK(VIC+16)AND1)=1THENDX=-DX:REM IF SPRITE IS...
                                <br>410 REM TOUCHING THE RIGHT EDGE, THEN REVERSE IT
                                <br>420 IFX=255ANDDX=1THENX=-1:SIDE=3
                                <br>430 REM SWITCH TO OTHER SIDE OF THE SCREEN
                                <br>440 IFX=0ANDDX=-1THENX=256:SIDE=0
                                <br>450 REM SWITCH TO OTHER SIDE OF THE SCREEN
                                <br>460 X=X+DX:REM ADD DELTA X TO X
                                <br>470 X=XAND255:REM MAKE SURE X IS IN ALLOWED RANGE
                                <br>480 Y=Y+DY:REM ADD DELTA Y TO Y
                                <br>485 POKEVIC+16,SIDE
                                <br>490 POKEVIC,X:REM PUT NEW X VALUE INTO SPRITE 0'S X POSITION
                                <br>500 POKEVIC+2,X:REM PUT NEW X VALUE INTO SPRITE 1'S X POSITION
                                <br>510 POKEVIC+1,Y:REM PUT NEW Y VALUE INTO SPRITE 0'S Y POSITION
                                <br>520 POKEVIC+3,Y:REM PUT NEW Y VALUE INTO SPRITE 1'S Y POSITION
                                <br>530 GOTO340
                                <br>600 REM ***** SPRITE DATA *****
                                <br>610 DATA0,255,0,3,153,192,7,24,224,7,56,224,14,126,112,14,126,112,14,126
                                <br>620 DATA112,6,126,96,7,56,224,7,56,224,1,56,128,0,153,0,0,90,0,0,56,0
                                <br>630 DATA0,56,0,0,0,0,0,0,0,0,126,0,0,42,0,0,84,0,0,40,0,0
                                <br>640 DATA0,0,0,0,102,0,0,231,0,0,195,0,1,129,128,1,129,128,1,129,128
                                <br>650 DATA1,129,128,0,195,0,0,195,0,4,195,32,2,102,64,2,36,64,1,0,128
                                <br>660 DATA1,0,128,0,153,0,0,153,0,0,0,0,0,84,0,0,42,0,0,20,0,0
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p class="example">Sprite Example 3</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE148.PRG
                                <br>10 REM SPRITE EXAMPLE 3...
                                <br>20 REM THE HOT AIR GORF
                                <br>30 VIC=53248:REM THIS IS WHERE THE VIC REGISTERS BEGIN
                                <br>35 POKEVIC+21,1:REM ENABLE SPRITE 0
                                <br>36 POKEVIC+33,14:REM SET BACKGROUND COLOR TO LIGHT BLUE
                                <br>37 POKEVIC+23,1:REM EXPAND SPRITE 0 IN Y
                                <br>38 POKEVIC+29,1:REM EXPAND SPRITE 0 IN X
                                <br>40 POKE2040,192:REM SET SPRITE 0'S POINTER
                                <br>50 POKEVIC+28,1:REM TURN ON MULTICOLOR
                                <br>60 POKEVIC+37,7:REM SET MULTICOLOR 0
                                <br>70 POKEVIC+38,4:REM SET MULTICOLOR 1
                                <br>180 POKEVIC+0,100:REM SET SPRITE 0'S X POSITION
                                <br>190 POKEVIC+1,100:REM SET SPRITE 0'S Y POSITION
                                <br>220 POKEVIC+39,2:REM SET SPRITE 0'S COLOR
                                <br>290 FORY=0TO63:REM BYTE COUNTER WITH SPRITE LOOP
                                <br>300 READA:REM READ IN A BYTE
                                <br>310 POKE12288+Y,A:REM STORE THE DATA IN SPRITE AREA
                                <br>320 NEXT Y:REM CLOSE LOOP
                                <br>330 DX=1:DY=1
                                <br>340 X=PEEK(VIC):REM LOOK AT SPRITE 0'S X POSITION
                                <br>350 Y=PEEK(VIC+1):REM LOOK AT SPRITE 0'S Y POSITION
                                <br>360 IFY=50ORY=208THEN DY=-DY:REM IF Y IS ON THE EDGE OF THE...
                                <br>370 REM SCREEN, THEN REVERSE DELTA Y
                                <br>380 IFX=24AND(PEEK(VIC+16)AND1)=0THENDX=-DX:REM IF SPRITE IS...
                                <br>390 REM TOUCHING THE LEFT EDGE, THEN REVERSE IT
                                <br>400 IFX=40AND(PEEK(VIC+16)AND1)=1THENDX=-DX:REM IF SPRITE IS...
                                <br>410 REM TOUCHING THE RIGHT EDGE, THEN REVERSE IT
                                <br>420 IFX=255ANDDX=1THENX=-1:SIDE=1
                                <br>430 REM SWITCH TO OTHER SIDE OF THE SCREEN
                                <br>440 IFX=0ANDDX=-1THENX=256:SIDE=0
                                <br>450 REM SWITCH TO OTHER SIDE OF THE SCREEN
                                <br>460 X=X+DX:REM ADD DELTA X TO X
                                <br>470 X=XAND255:REM MAKE SURE THAT X IS IN ALLOWED RANGE
                                <br>480 Y=Y+DY:REM ADD DELTA Y TO Y
                                <br>485 POKEVIC+16,SIDE
                                <br>490 POKEVIC,X:REM PUT NEW X VALUE INTO SPRITE 0'S X POSITION
                                <br>510 POKEVIC+1,Y:REM PUT NEW Y VALUE INTO SPRITE 0'S Y POSITION
                                <br>520 GETA$:REM GET A KEY FROM THE KEYBOARD
                                <br>521 IFA$="M"THENPOKEVIC+28,1:REM USER SELECTED MULTICOLOR
                                <br>522 IFA$="H"THENPOKEVIC+28,0:REM USER SELECTED HIGH RESOLUTION
                                <br>530 GOTO340
                                <br>600 REM ***** SPRITE DATA *****
                                <br>610 DATA64,0,1,16,170,4,6,170,144,10,170,
                                <br>160,42,170,168,41,105,104,169
                                <br>620 DATA235,106,169,235,106,169,235,106,170,
                                <br>170,170,170,170,170,170,170
                                <br>630 DATA170,170,170,170,166,170,154,169,85,106,
                                <br>170,85,170,42,170,168,10
                                <br>640 DATA170,160,1,0,64,1,0,64,5,0,80,0
                                <br>STOP TOK64
                            </code>
                        </blockquote>
                    </section>

                    <hr>

                    <section class="main-section" id="Other_Graphics_Features">
                        <header>
                            <h4>Other Graphics Features</h4>
                        </header>

                        <h5>Screen Blanking</h5>

                        <p>Bit 4 of the VIC-II control register controls the screen blanking function. It is found in
                            the control register at location 53265 ($D011). When it is turned ON (in other words, set to
                            a 1) the screen is normal. When bit 4 is set
                            to 0 (turned OFF), the entire screen changes to border color.
                        </p>
                        <p>The following POKE blanks the screen. No data is lost, it just isn't displayed.</p>

                        <blockquote>
                            <code>POKE 53265,PEEK(53265)AND 239</code>
                        </blockquote>

                        <p>To bring back the screen. use the POKE shown below:</p>

                        <blockquote>
                            <code>POKE 53265,PEEK(53265)OR 16</code>
                        </blockquote>

                        <p>
                            <strong>NOTE:</strong> Turning off the screen will speed up the processor slightly. This
                            means that program RUNning is also sped up.</p>

                        <h5>Raster Register</h5>

                        <p>The raster register is found in the VIC-II chip at location 53266 ($D012). The raster
                            register is a dual purpose register. When you read this register it returns the lower 8 bits
                            of the current raster position. The raster position
                            of the most significant bit is in register location 53265 ($D011). You use the raster
                            register to set up timing changes in your display so that you can get rid of screen flicker.
                            The changes on your screen should be mode when
                            the raster is not in the visible display area, which is when your dot positions fall between
                            51 and 251.</p>
                        <p>When the raster register is written to (including the MSB) the number written to is saved for
                            use with the raster compare function. When the actual raster value becomes the same as the
                            number written to the raster register, a bit
                            in the VIC-II chip interrupt register 53273 ($D019) is turned ON by setting it to 1.</p>
                        <p>
                            <strong>NOTE:</strong> If the proper interrupt bit is enabled (turned on), an interrupt
                            (IRQ) will occur.</p>

                        <h5>Interrupt Status Register</h5>

                        <p>The interrupt status register shows the current status of any interrupt source. The current
                            status of bit 2 of the interrupt register will be a 1 when two sprites hit each other. The
                            same is true, in a corresponding 1 to 1 relationship,
                            for bits 0-3 listed in the chart below. Bit 7 is also set with a 1, whenever an interrupt
                            occurs.</p>
                        <p>The interrupt status register is located at 53273 ($D019) and is as follows:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Latch</th>
                                    <th>Bit #</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>IRST</td>
                                    <td>0</td>
                                    <td>Set when current raster count = stored raster count</td>
                                </tr>
                                <tr>
                                    <td>IMDC</td>
                                    <td>1</td>
                                    <td>Set by SPRITE-DATA collision (1st one only, until reset)</td>
                                </tr>
                                <tr>
                                    <td>IMMC</td>
                                    <td>2</td>
                                    <td>Set by SPRITE-SPRITE collision (1st one only, until reset)</td>
                                </tr>
                                <tr>
                                    <td>ILP</td>
                                    <td>3</td>
                                    <td>Set by negative transition of light pen (1 per frame)</td>
                                </tr>
                                <tr>
                                    <td>IRQ</td>
                                    <td>7</td>
                                    <td>Set by latch set and enabled</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>Once an interrupt bit has been set, it's "latched" in and must be cleared by writing a 1 to
                            that bit in the interrupt register when you're ready to handle it. This allows selective
                            interrupt handling, without having to store the
                            other interrupt bits.</p>
                        <p>The INTERRUPT ENABLE REGISTER is located at 53274 ($D01A). It has the same format as the
                            interrupt status register. Unless the corresponding bit in the interrupt enable register is
                            set to a 1, no interrupt from that source will
                            take place. The interrupt status register can still be polled for information, but no
                            interrupts will be generated. To enable an interrupt request the corresponding interrupt
                            enable bit (as shown in the chart above) must be
                            set to a 1.</p>
                        <p>This powerful interrupt structure lets you use split screen modes. For instance you can have
                            half of the screen bit mapped, half text, more than 8 sprites at a time, etc. The secret is
                            to use interrupts properly. For example, if
                            you want the top half of the screen to be bit mapped and the bottom to be text, just set the
                            raster compare register (as explained previously) for halfway down the screen. When the
                            interrupt occurs, tell the VIC-II chip to
                            get characters from ROM, then set the raster compare register to interrupt at the top of the
                            screen. When the interrupt occurs at the top of the screen, tell the VIC-II chip to get
                            characters from RAM (bit map mode).
                        </p>
                        <p>You can also display more than 8 sprites in the same way. Unfortunately BASIC isn't fast
                            enough to do this very well. So if you want to start using display interrupts, you should
                            work in machine language.
                        </p>

                        <h5>Suggested Screen and Character Color Combinations</h5>

                        <p>Color TV sets are limited in their ability to place certain colors next to each other on the
                            same line. Certain combinations of screen and character colors produce blurred images. This
                            chart shows which color combinations to avoid,
                            and which work especially well together.</p>

                        <img src="https://s5.postimg.cc/5m2c3obsn/c64_char_color.png" alt="Character color guide">
                    </section>

                    <hr>

                    <section class="main-section" id="Programming_Sprites_Another_Look">
                        <header>
                            <h4>Programming Sprites - Another Look</h4>
                        </header>

                        <p>For those of you having trouble with graphics, this section has been designed as a more
                            elementary tutorial approach to sprites.</p>

                        <h5>Making Sprites in BASIC - A Short Program</h5>

                        <p>There are at least three different BASIC programming techniques which let you create graphic
                            images and cartoon animations on the Commodore 64. You can use the computer's built-in
                            graphics character set (see Page 376). You can
                            program your own characters (see Page 108) or... best of all... you can use the computer's
                            built-in "sprite graphics. To illustrate how easy it is, here's one of the shortest
                            spritemaking programs you can write in BASIC:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE153.PRG
                                <br>10 PRINT"{CLEAR}"
                                <br>20 POKE2040,13
                                <br>30 FORS=832TO832+62:POKES,255:NEXT
                                <br>40 V=53248
                                <br>50 POKEV+21,1
                                <br>60 POKEV+39,1
                                <br>70 POKEV,24
                                <br>80 POKEV+1,100
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>This program includes the key "ingredients" you need to create any sprite. The POKE numbers
                            come from the SPRITEMAKING CHART on Page 176. This program defines the first sprite...
                            sprite 0... as a solid white square on the screen.
                            Here's a line-by-line explanation of the program:
                        </p>

                        <p>LINE 10 clears the screen.</p>
                        <p>LINE 20 sets the "sprite pointer" to where the Commodore 64 will read its sprite data from.
                            Sprite 0 is set at 2040, sprite 1 at 2041, sprite 2 at 2042, and so on up to sprite 7 at
                            2047. You can set all 8 sprite pointers to 13
                            by using this line in place of line 20:</p>
                        <blockquote>
                            <code>20 FOR SP=2040TO2047:POKE SP,13:NEXT SP</code>
                        </blockquote>

                        <p>LINE 30 puts the first sprite (sprite 0) into 63 bytes of the Commodore 64's RAM memory
                            starting at location 832 (each sprite requires 63 bytes of memory). The first sprite (sprite
                            0) is "addressed" at memory locations 832 to 894.</p>
                        <p>LINE 40 sets the variable "V" equal to 53248, the starting address of the VIDEO CHIP. This
                            entry lets us use the form (V+number) for sprite settings. 're using the form (V+number)
                            when POKEing sprite settings because this format
                            conserves memory and lets us work with smaller numbers. For example, in line 50 we typed
                            POKE V+21. This is the same as typing POKE 53248+21 or POKE 53269... but V+21 requires less
                            space than 53269, and is easier to remember.
                        </p>
                        <p>LINE 50 enables or "turns on" sprite 0. There are 8 sprites, numbered from 0 to 7. To turn on
                            an individual sprite, or a combination of sprites, all you have to do is POKE V+21 followed
                            by a number from 0 (turn all sprites off)
                            to 255 (turn all 8 sprites on). You can turn on one or more sprites by POKEing the following
                            numbers:</p>

                        <table>
                            <tbody>
                                <tr>
                                    <td>
                                        ALL ON
                                        <br>255
                                    </td>
                                    <td>
                                        SPRT 0
                                        <br>1
                                    </td>
                                    <td>
                                        SPRT 1
                                        <br>2
                                    </td>
                                    <td>
                                        SPRT 2
                                        <br>4
                                    </td>
                                    <td>
                                        SPRT 3
                                        <br>8
                                    </td>
                                    <td>
                                        SPRT 4
                                        <br>16
                                    </td>
                                    <td>
                                        SPRT 5
                                        <br>20
                                    </td>
                                    <td>
                                        SPRT 6
                                        <br>164
                                    </td>
                                    <td>
                                        SPRT 7
                                        <br>128
                                    </td>
                                    <td>
                                        ALL OFF
                                        <br>0
                                    </td>
                                </tr>
                            </tbody>
                        </table>

                        <p>POKE V+21,1 turns on sprite 0. POKE V+21,128 turns on sprite 7. You can also turn on
                            combinations of sprites. For example, POKE V+21,129 turns on both sprite 0 and sprite 7 by
                            adding the two "turn on" numbers (1+128) together.
                            (See SPRITEMAKING CHART
                            <a href="#sprite-chart">here</a>)</p>
                        <p>LINE 60 sets the COLOR of sprite 0. There are 16 possible sprite colors, numbered from 0
                            (black) to 15 (grey). Each sprite requires a different POKE to set its color, from V+39 to
                            V+46. POKE V+39,1 colors sprite 0 white. POKE V+46,15
                            colors sprite 7 grey. (See the SPRITEMAKING CHART for more information.)</p>
                        <p>When you create a sprite, as you just did, the sprite will STAY IN MEMORY until you POKE it
                            off, redefine it, or turn off your computer. This lets you change the color, position and
                            even shape of the sprite in DIRECT or IMMEDIATE
                            mode, which is useful for editing purposes. As an example, RUN the program above, then type
                            this line in DIRECT mode (without a line number) and hit the &lt;RETURN&gt; key:</p>

                        <blockquote>
                            <code>POKE V+39,8</code>
                        </blockquote>

                        <p>The sprite on the screen is now ORANGE. Try POKEing some other numbers from 0 to 15 to see
                            the other sprite colors. Because you did this in DIRECT mode, if you RUN your program the
                            sprite will return to its original color (white).</p>
                        <p>LINE 70, determines the HORIZONTAL or "X" POSITION of the sprite on the screen. This number
                            represents the location of the UPPER LEFT CORNER of the sprite. The farthest left horizontal
                            (X) position which you can see on your television
                            screen is position number 24, although you can move the sprite OFF THE SCREEN to position
                            number 0.</p>
                        <p>LINE 80 determines the VERTICAL or "Y" POSITION of the sprite. In this program, we placed the
                            sprite at X (horizontal) position 24, and Y (vertical) position 100. To try another
                            location, type this POKE in DIRECT mode and hit &lt;RETURN&gt;:</p>

                        <blockquote>
                            <code>POKE V,24:POKE V+1,50</code>
                        </blockquote>

                        <p>This places the sprite at the upper left corner of the screen. To move the sprite to the
                            lower left corner, type this:</p>

                        <blockquote>
                            <code>POKE V,24:POKE V+1,229</code>
                        </blockquote>

                        <p>Each number from 832 to 895 in our sprite 0 address represents one block of 8 pixels, with
                            three 8-pixel blocks in each horizontal row of the sprite. The loop in line 80 tells the
                            computer to POKE 832,255 which makes the first
                            8 pixels solid . . . then POKE 833,255 to make the second 8 pixels solid, and so on to
                            location 894 which is the last group of 8 pixels in the bottom right corner of the sprite.
                            To better see how this works, try typing the
                            following in DIRECT r-node, and notice that the second group of 8 pixels is erased:</p>

                        <blockquote>
                            <code>POKE 833,0 (to put it back type POKE 833,255 or RUN your program)</code>
                        </blockquote>

                        <p>The following line, which you can add to your program. erases the blocks in the MIDDLE of the
                            sprite you created:</p>

                        <blockquote>
                            <code>90 FOR A=836 TO 891 STEP 3:POKE A,O:NEXT A</code>
                        </blockquote>

                        <p>Remember, the pixels that make up the sprite are grouped in blocks of eight. This line erases
                            the 5th group of eight pixels (block 836) and every third block up to block 890. Try POKEing
                            any of the other numbers from 832 to 894
                            with either a 255 to make them solid or 0 to make them blank.
                        </p>

                        <h5>Crunching Your Sprite Programs</h5>

                        <p> Here's a helpful "crunching" tip: The program described above is already short, but it can
                            be made even shorter by "crunching" it smaller. In our example we list the key sprite
                            settings on separate program lines so you can see
                            what's happening in the program. In actual practice, a good programmer would probably write
                            this program as a TWO LINE PROGRAM... by "crunching" it as follows:</p>

                        <blockquote>
                            <code>
                                10 PRINTCHR$(147):V=53248:POKEV+21,1:POKE2040.13:POKEV+39,1
                                <br>20 FORS=832TO894:POKES,255:NEXT:POKEV,24:POKEV+1,100
                            </code>
                        </blockquote>

                        <p>For more tips on how to crunch your programs so they fit in less memory and run more
                            efficiently, see the "crunching guide"
                            <a href="#crunching">here.</a>
                        </p>

                        <img src="https://s5.postimg.cc/cdsr6dnvr/c64_sprt_crunch.png" alt="TV Screen">

                        <h5>Positioning Sprites on the Screen</h5>

                        <p>The entire display screen is divided into a grid of X and Y coordi- nates, like a graph. The
                            X COORDINATE is the HORIZONTAL position across the screen and the Y COORDINATE is the
                            VERTICAL position up and down (see Figure 3-4).</p>
                        <p>To position any sprite on the screen, you must POKE TWO SETTINGS... the X position and the Y
                            position... these tell the computer where to display the UPPER LEFT HAND CORNER of the
                            sprite. Remember that a sprite consists of 504
                            individual pixels, 24 across by 21 down... so if you POKE a sprite onto the upper left
                            corner of your screen, the sprite will be displayed as a graphic image 24 pixels ACROSS and
                            21 pixels DOWN starting at the X-Y position
                            you defined. The sprite will be displayed based on the upper left corner of the entire
                            sprite, even if you define the sprite using only a small part of the 24X21-pixel sprite
                            area.</p>
                        <p>To understand how X-Y positioning works, study the following diagram (Figure 3-5), which
                            shows the X and Y numbers in relation to your display screen. Note that the GREY AREA in the
                            diagram shows your television viewing area...
                            the white area represents positions which are OFF your viewing screen...
                        </p>

                        <img src="https://s5.postimg.cc/6pmgfkyzr/c64_sprite_pos.png" alt="Sprite Positioning">

                        <p>To display a sprite in a given location, You must POKE the X and Y settings for each
                            SPRITE... remembering that every sprite has its own unique X POKE and Y POKE. The X and Y
                            settings for ail 8 sprites are shown here:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th colspan="9">POKE these values to set X-Y SPRITE POSITIONS</th>
                                </tr>
                                <tr>
                                    <th></th>
                                    <th>SPRT 0</th>
                                    <th>SPRT 1</th>
                                    <th>SPRT 2</th>
                                    <th>SPRT 3</th>
                                    <th>SPRT 4</th>
                                    <th>SPRT 5</th>
                                    <th>SPRT 6</th>
                                    <th>SPRT 7</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>SET X</td>
                                    <td>V,X</td>
                                    <td>V+2,X</td>
                                    <td>V+4,X</td>
                                    <td>V+6,X</td>
                                    <td>V+8,X</td>
                                    <td>V+10,X</td>
                                    <td>V+12,X</td>
                                    <td>V+14,X</td>
                                </tr>
                                <tr>
                                    <td>SET Y</td>
                                    <td>V+1,Y</td>
                                    <td>V+3,Y</td>
                                    <td>V+5,Y</td>
                                    <td>V+7,Y</td>
                                    <td>V+9,Y</td>
                                    <td>V+11,Y</td>
                                    <td>V+13,Y</td>
                                    <td>V+15,Y</td>
                                </tr>
                                <tr>
                                    <td>RIGHTX</td>
                                    <td>V+16,1</td>
                                    <td>V+16,2</td>
                                    <td>V+16,4</td>
                                    <td>V+16,8</td>
                                    <td>V+16,16</td>
                                    <td>V+16,32</td>
                                    <td>V+16,64</td>
                                    <td>V+16,128</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>
                            <strong>POKEING AN X POSITION:</strong> The possible values of X are 0 to 255, counting from
                            left to right. Values 0 to 23 place all or part of the sprite OUT OF THE VIEWING AREA off
                            the left side of the screen... values 24
                            to 255 place the sprite IN THE VIEWING AREA up to the 255th position (see next paragraph for
                            settings beyond the 255th X position). To place the sprite at one of these positions, just
                            type the X-POSITION POKE for the sprite
                            you're using. For example, to POKE sprite I at the farthest left X position IN THE VIEWING
                            AREA, type:
                            <code>POKE V+2,24</code>.</p>
                        <p>
                            <strong> X VALUES BEYOND THE 255TH POSITION:</strong> To get beyond the 255th position
                            across the screen, you need to make a SECOND POKE using the numbers in the "RIGHT X" row of
                            the chart (Figure 3-5). Normally, the horizontal
                            (X) numbering would continue past the 255th position to 256, 257, etc., but because
                            registers only contain 8 bits we must use a "second register" to access the RIGHT SIDE of
                            the screen and start our X numbering over again at
                            0. So to get beyond X position 255, you must POKE V+16 and a number (depending on the
                            sprite). This gives you 65 additional X positions (renumbered from 0 to 65) in the viewing
                            area on the RIGHT side of the viewing screen.
                            (You can actually POKE the right side X value as high as 255, which takes you off the right
                            edge of the viewing screen.)</p>
                        <p>
                            <strong>POKEING A Y POSITION:</strong> The possible values of Y are 0 to 255, counting from
                            top to bottom. Values 0 to 49 place all or part of the sprite OUT OF THE VIEWING AREA off
                            the TOP of the screen. Values 50 to 229 place
                            the sprite IN THE VIEWING AREA. Values 230 to 255 place all or part of the sprite OUT OF THE
                            VIEWING AREA off the BOTTOM of the screen.
                        </p>
                        <p> Let's see how this X-Y positioning works, using sprite 1. Type this program:
                        </p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE159.PRG
                                <br>10 PRINT"{CLEAR}":V=53248:POKEV+21,2:POKE2041,13
                                <br>20 FORS=832TO895:POKES,255:NEXT:POKEV+40,7
                                <br>30 POKEV+2,24
                                <br>40 POKEV+3,50
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>This simple program establishes sprite 1 as a solid box and positions it at the upper left
                            corner of the screen. Now change line 40 to read:</p>

                        <blockquote>
                            <code>40 POKE V+3,229</code>
                        </blockquote>

                        <p>This moves the sprite to the bottom left corner of the screen. Now let's test the RIGHT X
                            LIMIT of the sprite. Change line 30 as shown:</p>

                        <blockquote>
                            <code>30 POKE V+2,255</code>
                        </blockquote>

                        <p>This moves the sprite to the RIGHT but reaches the RIGHT X LIMIT, which is 255. At this
                            point, the "most significant bit" in register 16 must be SET. In other words, you must type
                            POKE V+ 16 and the number shown in the "RIGHT X"
                            column in the X-Y POKE CHART above to RESTART the X position counter at the 256th
                            pixel/position on the screen. Change line 30 as follows:
                        </p>

                        <blockquote>
                            <code>30 POKE V+16,PEEK(V+16)OR 2:POKE V+2,0</code>
                        </blockquote>

                        <p>POKE V+16,2 sets the most significant bit of the X position for sprite 1 and restarts it at
                            the 256th pixel/position on the screen. POKE V+2,0 displays the sprite at the NEW POSITION
                            ZERO, which is now reset to the 256th pixel.</p>
                        <p>To get back to the left side of the screen, you must reset the most significant bit of the X
                            position counter to 0 by typing (for sprite 1):</p>

                        <blockquote>
                            <code>POKE V+16, PEEK(V+16)AND 253</code>
                        </blockquote>

                        <p>TO SUMMARIZE how the X positioning works... POKE the X POSITION for any sprite with a number
                            from 0 to 255. To access a position beyond the 255th position/pixel across the screen, you
                            must use an additional POKE (V+16) which sets
                            the most significant bit of the X position and start counting from 0 again at the 256th
                            pixel across the screen.</p>
                        <p>This POKE starts the X numbering over again from 0 at the 256th position (Example: POKE
                            V+16,PEEK(V+16)OR 1 and POKE V,1 must be included to place sprite 0 at the 257th pixel
                            across the screen.) To get back to the left side X positions
                            you have to TURN OFF the control setting by typing POKE V+16,PEEK(V+16)AND 254.
                        </p>

                        <h5>Positioning Multiple Sprites on the Screen</h5>

                        <p>Here's a program which defines THREE DIFFERENT SPRITES (0, 1 and 2) in different colors and
                            places them in different positions on the screen:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE160.PRG
                                <br>10 PRINT"{CLEAR}":V=53248:FORS=832TO895:POKES,255:NEXT
                                <br>20 FORM=2040TO2042:POKEM,13:NEXT
                                <br>30 POKEV+21,7
                                <br>40 POKEV+39,1:POKEV+40,7:POKEV+41,8
                                <br>50 POKEV,24:POKEV+1,50
                                <br>60 POKEV+2,12:POKEV+3,229
                                <br>70 POKEV+4,255:POKEV+5,50
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>For convenience, all 3 sprites have been defined as solid squares, getting their data from
                            the same place. The important lesson here is how the 3 sprites are positioned. The white
                            sprite 0 is at the top lefthand corner. The yellow
                            sprite 1 is at the bottom lefthand corner but HALF the sprite is OFF THE SCREEN (remember,
                            24 is the leftmost X position in the viewing area... an X position less than 24 puts all or
                            part of the sprite off the screen and we
                            used an X position 12 here which put the sprite halfway off the screen). Finally, the orange
                            sprite 2 is at the RIGHT X LIMIT (position 255)... but what if you want to display a sprite
                            in the area to the RIGHT of X position
                            255?</p>

                        <h5>Displaying a Sprite Beyond the 255th X-Position</h5>

                        <p>Displaying a sprite beyond the 255th X position requires a special POKE which SETS the most
                            significant bit of the X position and starts over at the 256th pixel position across the
                            screen. Here's how it works...</p>
                        <p> First, you POKE V+16 with the number for the sprite you're using (check the "RIGHT X" row in
                            the X-Y chart... we'll use sprite 0). Now we assign an X position, keeping in mind that the
                            X counter starts over from 0 at the 256th
                            position on the screen. Change line 50 to read as follows:
                        </p>

                        <blockquote>
                            <code>50 POKE V+16,1:POKE V,24:POKE V+1,75</code>
                        </blockquote>

                        <p>This line POKEs V+ 16 with the number required to "open up" the right side of the screen...
                            the new X position 24 for sprite 0 now begins 24 pixels to the RIGHT of position 255. To
                            check the right edge of the screen, change line
                            60 to:</p>

                        <blockquote>
                            <code>60 POKE V+16,1:POKE V,65:POKE V+1,75</code>
                        </blockquote>

                        <p>Some experimentation with the settings in the sprite chart will give you the settings you
                            need to position and move sprites on the left and right sides of the screen. The section on
                            "moving sprites" will also increase your understanding
                            of how sprite positioning works.</p>

                        <h5>Sprite Priorities</h5>

                        <p>You can actually make different sprites seem to move IN FRONT OF or BEHIND each other on the
                            screen. This incredible three dimensional illu- sion is achieved by the built-in SPRITE
                            PRIORITIES which determine which sprites have
                            priority over the others when 2 or more sprites OVERLAP on the screen.
                        </p>
                        <p>The rule is "first come, first served" which means lower-numbered sprites AUTOMATICALLY have
                            priority over higher-numbered sprites. For example, if you display sprite 0 and sprite 1 so
                            they overlap on the screen, sprite 0 will
                            appear to be IN FRONT OF sprite 1. Actually, sprite 0 always supersedes all the other
                            sprites because it's the lowest numbered sprite. In comparison, sprite 1 has priority over
                            sprites 2-7; sprite 2 has priority over sprites
                            3-7, etc. Sprite 7 (the last sprite) has LESS PRIORITY than any of the other sprites, and
                            will always appear to be displayed "BEHIND" any other sprites which overlap its position.
                        </p>
                        <p>To illustrate how priorities work, change lines 50, 60, and 70 in the program above to the
                            following:
                        </p>

                        <blockquote>
                            <code>
                                50 POKEV,24:POKEV+1,50:POKEV+16,0
                                <br>60 POKEV+2,34:POKEV+3,60
                                <br>70 POKEV+4,44:POKEV+5,70
                            </code>
                        </blockquote>

                        <p>You should see a white sprite on top of a yellow sprite on top of an orange sprite. Of
                            course, now that you see how priorities work, you can also MOVE SPRITES and take advantage
                            of these priorities in your animation.</p>

                        <h5>Drawing a Sprite</h5>

                        <p>Drawing a Commodore sprite is like coloring the empty spaces in a coloring book. Every sprite
                            consists of tiny dots called pixels. To draw a sprite, all you have to do is "color in" some
                            of the pixels.
                        </p>
                        <p>Look at the spritemaking grid in Figure 3-6. This is what a blank sprite looks like:</p>

                        <img src="https://s5.postimg.cc/y8xj801vb/c64_sprite_grid.png" alt="Spritemaking Grid">

                        <p>Each little "square" represents one pixel in the sprite. There are 24 pixels across and 21
                            pixels up and down, or 504 pixels in the entire sprite. To make the sprite look like
                            something, you have to color in these pixels using
                            a special PROGRAM... but how can you control over 500 individual pixels? That's where
                            computer programming can help you. In- stead of typing 504 separate numbers, you only have
                            to type 63 numbers for each sprite. Here's how
                            it works...</p>

                        <h5>CREATING A SPRITE... STEP BY STEP</h5>

                        <p>To make this as easy as possible for you, we've put together this simple step by step guide
                            to help you draw your own sprites.</p>

                        <p>
                            <strong>Step 1:</strong>
                        </p>

                        <p>Write the spritemaking program shown here ON A PIECE OF PAPER... note that line 100 starts a
                            special DATA section of your program which will contain the 63 numbers you need to create
                            your sprite.
                        </p>

                        <img src="https://s5.postimg.cc/e2u19e8vb/c64_sprite_prg.png" alt="Sprite Program">

                        <p>
                            <strong>Step 2:</strong>
                        </p>

                        <p>Color in the pixels on the spritemaking grid on Page 162 (or use a piece of graph paper...
                            remember, a sprite has 24 squares across and 21 squares down). We suggest you use a pencil
                            and draw lightly so you can reuse this grid.
                            You can create any image you like, but for our example we'll draw a simple box.</p>

                        <p>
                            <strong>Step 3:</strong>
                        </p>

                        <p>Look at the first EIGHT pixels. Each column of pixels has a number (128, 64, 32, 16, 8, 4, 2,
                            1). The special type of addition we are going to show you is a type of BINARY ARITHMETIC
                            which is used by most computers as a special
                            way of counting. Here's a close-up view of the first eight pixels in the top left hand
                            corner of the sprite:</p>

                        <img src="https://s5.postimg.cc/by9o8cp93/c64_sprite_closeup.png" alt="Closeup">

                        <p>
                            <strong>Step 4:</strong>
                        </p>

                        <p>Add up the numbers of the SOLID pixels. This first group of eight pixels is completely solid,
                            so the total number is 255.</p>

                        <p>
                            <strong>Step 5:</strong>
                        </p>

                        <p>Enter that number as the FIRST DATA STATEMENT in line 100 of the Spritemaking Program below.
                            Enter 255 for the second and third groups of eight.</p>

                        <p>
                            <strong>Step 6:</strong>
                        </p>

                        <p>Look at the FIRST EIGHT PIXELS IN THE SECOND ROW of the sprite. Add up the values of the
                            solid pixels. Since only one of these pixels is solid, the total value is 128. Enter this as
                            the first DATA number in line 101.</p>

                        <img src="https://s5.postimg.cc/lvkp1f4kn/c64_sprite_closeup2.png" alt="Closeup 2">

                        <p>
                            <strong>Step 7:</strong>
                        </p>

                        <p>Add up the values of the next group of eight pixels (which is 0 because they're all BLANK)
                            and enter in line 101. Now move to the next group of pixels and repeat the process for each
                            GROUP OF EIGHT PIXELS (there are 3 groups across
                            each row, and 21 rows). This will give you a total of 63 numbers. Each number represents ONE
                            group of 8 pixels, and 63 groups of eight equals 504 total individual pixels. Perhaps a
                            better way of looking at the program is like
                            this... each line in the program represents ONE ROW in the sprite. Each of the 3 numbers in
                            each row represents ONE GROUP OF EIGHT PIXELS. And each number tells the computer which
                            pixels to make SOLID and which pixels to leave
                            blank.
                        </p>

                        <p>
                            <strong>Step 8:</strong>
                        </p>

                        <p>CRUNCH YOUR PROGRAM INTO A SMALLER SPACE BY RUNNING TOGETHER ALL THE DATA STATEMENTS, AS
                            SHOWN IN THE SAMPLE PROGRAM BELOW. Note that we asked you to write your sprite program on a
                            piece of paper. We did this for a good reason.
                            The DATA STATEMENT LINES 100-120 in the program in STEP 1 are only there to help you see
                            which numbers relate to which groups of pixels in your sprite. Your final program should be
                            "crunched" like this:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE165.PRG
                                <br>10 PRINT"{CLEAR}":POKE53280,5:POKE53281,6
                                <br>20 V=53248:POKEV+34,3
                                <br>30 POKE 53269,4:POKE2042,13
                                <br>40 FORN=0TO62:READQ:POKE832+N,Q:NEXT
                                <br>100 DATA255,255,255,128,0,1,128,0,1,128,0,1,144,0,1,144,0,1,144,0,1,144,0
                                <br>101 DATA1,144,0,1,144,0,1,144,0,1,144,0,1,144,0,1,144,0,1,128,0,1,128,0,1
                                <br>102 DATA128,0,1,128,0,1,128,0,1,128,0,1,255,255,255
                                <br>200 X=200:Y=100:POKE53252,X:POKE53253,Y
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <h5>Moving Your Sprite Across the Screen</h5>

                        <p> Now that you've created your sprite, let's do some interesting things with it. To move your
                            sprite smoothly across the screen, add these two lines to your program:</p>

                        <blockquote>
                            <code>
                                50 POKE V+5,100:FOR X=24TO255:POKE V+4,X:NEXT:POKE V+16,4
                                <br>55 FOR X=0TO65:POKE V+4,X:NEXT X:POKE V+16,0:GOTO 50
                            </code>
                        </blockquote>

                        <p> LINE 50 POKEs the Y POSITION at 100 (try 50 or 229 instead for variety). Then it sets up a
                            FOR... NEXT loop which POKEs the sprite into X position 0 to X position 255, in order. When
                            it reaches the 255th position, it POKEs the
                            RIGHT X POSITION (POKE V+16,4) which is required to cross to the right side of the screen.
                        </p>
                        <p>LINE 55 has a FOR... NEXT loop which continues to POKE the sprite in the last 65 positions on
                            the screen. Note that the X value was reset to zero but because you used the RIGHT X setting
                            (POKE V+16,2) X starts over on the right
                            side of the screen.</p>
                        <p>This line keeps going back to itself (GOTO 50). If you just want the sprite to move ONCE
                            across the screen and disappear, then take out GOTO50.
                        </p>
                        <p>Here's a line which moves the sprite BACK AND FORTH:</p>

                        <blockquote>
                            <code>
                                50 POKE V+5,100:FOR X=24TO255:POKE V+4,X:NEXT:POKE V+16,4: FOR X=0TO65: POKE V+4,X:
                                NEXT X
                                <br>55 FOR X=65TO0 STEP-1:POKE V+4,X:NEXT:POKE V+16,0: FOR X=255TO24 STEP-1: POKE
                                V+4,X:NEXT
                                <br>60 GOTO 50
                            </code>
                        </blockquote>

                        <p>Do you see how these programs work? This program is the same as the previous one, except when
                            it reaches the end of the right side of the screen, it REVERSES ITSELF and goes back in the
                            other direction. That is what the STEP-1
                            accomplishes... it tells the program to POKE the sprite into X values from 65 to 0 on the
                            right side of the screen, then from 255 to 0 on the left side of the screen, STEPping
                            backwards minus-1 position at a time.</p>

                        <h5>Vertical Scrolling</h5>

                        <p>This type of sprite movement is called "scrolling." To scroll your sprite up or down in the Y
                            position, you only have to use ONE LINE. ERASE LINES 50 and 55 by typing the line numbers by
                            themselves and hitting &lt;RETURN&gt; like
                            this:</p>

                        <blockquote>
                            <code>
                                50 &lt;RETURN&gt;
                                <br>60 &lt;RETURN&gt;
                            </code>
                        </blockquote>

                        <p>Now enter LINE 50 again as follows:</p>

                        <blockquote>
                            <code>50 POKE V+4,24:FOR Y=0TO255:POKE V+5,Y:NEXT</code>
                        </blockquote>

                        <h5>The Dancing Mouse: A Sprite Program Example</h5>

                        <p>Sometimes the techniques described in a programmer's reference manual are difficult to
                            understand, so we've put together a fun sprite program called "Michael's Dancing Mouse."
                            This program uses three different sprites in a cute
                            animation with sound effects-and to help you understand how it works we've included an
                            explanation of EACH COMMAND so you can see exactly how the program is constructed:</p>

                        <p class="example">Program</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE167.PRG
                                <br>5 S=54272:POKES+24,15:POKES,220:POKES+1,68:POKES+5,15:POKES+6,215
                                <br>10 POKES+7,120:POKES+8,100:POKES+12,15:POKES+13,215
                                <br>15 PRINT"{CLEAR}":V=53248:POKEV+21,1
                                <br>20 FORS1=12288TO12350:READQ1:POKES1,Q1:NEXT
                                <br>25 FORS2=12352TO12414:READQ2:POKES2,Q2:NEXT
                                <br>30 FORS3=12416TO12478:READQ3:POKES3,Q3:NEXT
                                <br>35 POKEV+39,15:POKEV+1,68
                                <br>40 PRINTTAB(160)"{WHITE}I AM THE DANCING MOUSE!{LIGHT BLUE}"
                                <br>45 P=192
                                <br>50 FORX=0TO347STEP3
                                <br>55 RX=INT(X/256):LX=X-RX*256
                                <br>60 POKEV,LX:POKEV+16,RX
                                <br>70 IFP=192THENGOSUB200
                                <br>75 IFP=193THENGOSUB300
                                <br>80 POKE2040,P:FORT=1TO60:NEXT
                                <br>85 P=P+1:IFP&gt;194THENP=192
                                <br>90 NEXT
                                <br>95 END
                                <br>100 DATA30,0,120,63,0,252,127,129,254,127,129,254,127,189,254,127,255,254
                                <br>101 DATA63,255,252,31,187,248,3,187,192,1,255,128,3,189,192,1,231,128,1,
                                <br>102 DATA255,0,31,255,0,0,124,0,0,254,0,1,199,32,3,131,224,7,1,192,1,192,0
                                <br>103 DATA3,192,0,30,0,120,63,0,252,127,129,254,127,129,254,127,189,254,127
                                <br>104 DATA255,254,63,255,252,31,221,248,3,221,192,1,255,128,3,255,192,1,195
                                <br>105 DATA128,1,231,3,31,255,255,0,124,0,0,254,0,1,199,0,7,1,128,7,0,204,1
                                <br>106 DATA128,124,7,128,5630,0,120,63,0,252,127,129,254,127,129,254,127,189
                                <br>107 DATA254,127,255,25463,255,252,31,221,248,3,221,192,1,255,134,3,189
                                <br>108 DATA204,1,199,152,1,255,48,1,255,224,1,252,0,3,254,0
                                <br>109 DATA7,14,0,204,14,0,248,56,0,112,112,0,0,60,0,-1
                                <br>200 POKES+4,129:POKES+4,128:RETURN
                                <br>300 POKES+11,129:POKES+11,128:RETURN
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p class="example">Line-by-line Explanation</p>

                        <blockquote>
                            <pre>
LINE 5:

S=54272             Sets the variable 5 equal to 54272, which is the
                    beginning memory location of the SOUND CHIP.
                    From now on, instead of poking a direct memory
                    location, we will POKE S plus a value.
POKES+24,15         Same as POKE 54296,15 which sets VOLUME to
                    highest level.
POKES,220           Same as POKE 54272,220 which sets Low Fre-
                    quency in Voice 1 for a note which approximates
                    high C in Octave 6.
POKES+1,68          Same as POKE 54273,68 which sets High Fre-
                    quency in Voice I for a note which approximates
                    high C in Octave 6.
POKES+5,15          Same as POKE 54277,15 which sets Attack/Decay
                    for Voice 1 and in this case consists of the
                    maximum DECAY level with no attack, which pro-
                    duces the "echo" effect.
POKES+6,215         Same as POKE 54278,215 which sets Sustain/Re-
                    lease for Voice 1 (215 represents a combination
                    of sustain and release values).
LINE 10:

POKES+7,120         Same as POKE 54279,120 which sets the Low Fre-
                    quency for Voice 2.
POKES+8,100         Same as POKE 54280,100 which sets the High
                    Frequency for Voice 2.
POKES+12,15         Same as POKE 54284,15 which sets Attack/Decay
                    for Voice 2 to same level as Voice 1 above.
POKES+13,215        Same as POKE 54285,215 which sets Sustain/Re-
                    lease for Voice 2 to same level as Voice 1 above.
LINE 15:

PRINT"&lt;SHIFT+CLR/HOME&gt;" Clears the screen when the program begins.

V=53248             Defines the variable "V" as the starting location
                    of the VIC chip which controls sprites. From now
                    on we will define sprite locations as V plus a
                    value.
POKEV+21,1          Turns on (enables) sprite number 1.

LINE 20:

FORS1=12288         We are going to use ONE SPRITE (sprite 0) in this
TO 12350            animation, but we are going to use THREE sets of
                    sprite data to define three separate shapes. To
                    get our animation, we will switch the POINTERS
                    for sprite 0 to the three places in memory where
                    we have stored the data which defines our three
                    different shapes. The same sprite will be rede-
                    fined rapidly over and over again as 3 different
                    shapes to produce the dancing mouse animation.
                    You can define dozens of sprite shapes in DATA
                    STATEMENTS, and rotate those shapes through
                    one or more sprites. So you see, you don't have to
                    limit one sprite to one shape or vice-versa. One
                    sprite can have many different shapes, simply by
                    changing the POINTER SETTING FOR THAT SPRITE to
                    different places in memory where the sprite data
                    for different shapes is stored. This line means we
                    have put the DATA for "sprite shape 1" at memory
                    locations 12288 to 12350.

READ Q1             Reads 63 numbers in order from the DATA state-
                    ments which begin at line 100. Q1 is an arbitrary
                    variable name. It could just as easily be A, Z1 or
                    another numeric variable.

POKES1,Q1           Pokes the first number from the DATA statements
                    (the first "Q1" is 30) into the first memory
                    location (the first memory location is 12288). This
                    is the same as POKE12288,30.

NEXT                This tells the computer to look BETWEEN the FOR and
                    NEXT parts of the loop and perform those in-between
                    commands (READQ1 and POKES1,Q1 using the NEXT
                    numbers in order). In other words, the NEXT
                    statement makes the computer READ the NEXT Q1 from
                    the DATA STATEMENTS, which is 0, and also
                    increments S1 by 1 to the next value, which is
                    12289. The result is POKE12289,0... the NEXT
                    command makes the loop keep going back until the
                    last values in the series, which are POKE 12350,0.
                    LINE 25:

FORS2=12352         The second shape of sprite zero is defined by the
TO 12414            DATA which is located at locations 12352 to 12414.
                    NOTE that location 12351 is SKIPPED... this is the
                    64th location which is used in the definition of
                    the first sprite group but does not contain any of
                    the sprite data numbers. Just remember when
                    defining sprites in consecutive locations that you
                    will use 64 locations, but only POKE sprite data
                    into the first 63 locations.

READQ2              Reads the 63 numbers which follow the numbers we
                    used for the first sprite shape. This READ simply
                    looks for the very next number in the DATA area and
                    starts reading 63 numbers, one at a time.

POKES2,Q2           Pokes the data (Q2) into the memory locations (S2)
                    for our second sprite shape, which begins at
                    location 12352.

NEXT                Same use as line 20 above.

LINE 30:

FORS3=12416         The third shape of sprite zero is defined by the
TO 12478            DATA to be located at locations 12416 to 12478.
READQ3              Reads last 63 numbers in order as Q3.
POKES3,Q3           Pokes those numbers into locations 12416 to 12478.
NEXT                Same as lines 20 and 25.

LINE 35:

POKEV+39,15         Sets color for sprite 0 to light grey.

POKEV+1,68          Sets the upper right hand corner of the sprite
                    square to vertical (Y) position 68. For the sake of
                    comparison, position 50 is the top lefthand corner
                    Y position on the viewing screen.

LINE 40:

PRINTTAB(160)       Tabs 160 spaces from the top lefthand CHARACTER
                    SPACE on the screen, which is the same as 4 rows
                    beneath the clear command... this starts your PRINT
                    message on the 6th line down on the screen.
"{white}            Hold down the &lt;CTRL&gt; key and press the key marked
                    &lt;WHT&gt; at the same time. If you do this inside
                    quotation marks, a "reversed E" will appear. This
                    sets the color to everything PRINTed from then on
                    to WHITE.
I AM THE            This is a simple PRINT statement.
DANCING
MOUSE!

{light blue}        This sets the color back to light blue when the
                    PRINT statement ends. Holding down &lt;CMDRE&gt; and &lt;7&gt;
                    a at the same time inside quotation marks
                    causes a "reversed diamond symbol" to appear.

LINE 45:

P=192               Sets the variable P equal to 192. This number 192
                    is the pointer you must use, in this case to
                    "point" sprite 0 to the memory locations that begin
                    at location 12288. Changing this pointer to the
                    locations of the other two sprite shapes is the
                    secret of using one sprite to create an animation
                    that is actually three different shapes.

LINE 50:

FORX=0TO347         Steps the movement of your sprite 3 X positions at
STEP3               a time (to provide fast movement) from position 0
                    to position 347.

LINE 55:

RX=INT(X/256)       RX is the integer of X/256 which means that RX is
                    rounded off to 0 when X is less than 256, and RX
                    becomes 1 when X reaches position 256. We will
                    use RX in a moment to POKE V+16 with a 0 or 1
                    to turn on the "RIGHT SIDE" of the screen.

LX=X-RX*256         When the sprite is at X position 0, the formula
                    looks like this: LX = 0 - (0 times 256) or 0. When
                    the sprite is at X position 1 the formula looks
                    like this: LX = 1 - (0 times 256) or 1. When the
                    sprite is at X position 256 the formula looks like
                    this: LX = 256 - (1 times 256) or 0 which resets X
                    back to 0 which must be done when you start over on
                    the RIGHT SIDE of the screen (POKEV+16,1).

LINE 60:

POKEV,LX            You POKE V by itself with a value to set the Hori-
                    zontal (X) Position of sprite 0 on the screen. (See
                    SPRITEMAKING CHART on Page 176). As shown above,
                    the value of LX, which is the horizontal position
                    of the sprite, changes from 0 to 255 and when it
                    reaches 255 it automatically resets back to zero
                    because of the LX equation set up in line 55.

POKEV+16,RX         POKEV+16 always turns on the "right side" of the
                    screen beyond position 256, and resets the
                    horizontal positioning coordinates to zero. RX is
                    either a 0 or a 1 based on the position of the
                    sprite as determined by the RX formula in line 55.

LINE 70:

IFP=192THEN         If the sprite pointer is set to 192 (the first
GOSUB200            sprite shape) the waveform control for the first
                    sound effect is set to 129 and 128 per line 200.

LINE 75:

IFP=193THEN         If the sprite pointer is set to 193 (the second
GOSUB300            sprite shape) the waveform control for the second
                    sound effect (Voice 2) is set to 129 and 128 per
                    line 300.

LINE 80:

POKE2040,P          Sets the SPRITE POINTER to location 192 (remember
                    P=192 in line 45? Here's where we use the P).

FORT=1TO60:         A simple time delay loop which sets the speed at
NEXT                which the mouse dances. (Try a faster or slower
                    speed by increasing/decreasing the number 60.)

LINE 85:

P=P+1               Now we increase the value of the pointer by adding
                    1 to the original value of P.

IFP&gt;194THEN         We only want to point the sprite to 3 memory lo-
P=192               cations. 192 points to locations 12288 to 12350,
                    193 points to locations 12352 to 12414, and 194
                    points to locations 12416 to 12478. This line tells
                    the computer to reset P back to 192 as soon as P
                    becomes 195 so P never really becomes 195. P is
                    192, 193, 194 and then resets back to 192 and the
                    pointer winds up pointing consecutively to the
                    three sprite shapes in the three 64-byte groups of
                    memory locations containing the DATA.

LINE 90:

NEXTX               After the sprite has become one of the 3 different
                    shapes defined by the DATA, only then is it allowed
                    to move across the screen. It will jump 3 X
                    positions at a time (instead of scrolling smoothly
                    one position at a time, which is also possible).
                    STEPping 3 positions at a time makes the mouse
                    "dance" faster across the screen. NEXT X matches
                    the FOR... X position loop in line 50.

LINE 95

END                 ENDs the program, which occurs when the sprite
                    moves off the screen.

LINES 100-109

DATA                The sprite shapes are read from the data numbers,
                    in order. First the 63 numbers which comprise
                    sprite shape 1 are read, then the 63 numbers for
                    sprite shape 2, and then sprite shape 3. This data
                    is permanently read into the 3 memory locations and
                    after it is read into these locations, all the
                    program has to do is point sprite 0 at the 3 memory
                    locations and the sprite automatically takes the
                    shape of the data in those locations. We are
                    pointing the sprite at 3 locations one at a time
                    which produces the "animation" effect. If you want
                    to see how these numbers affect each sprite, try
                    changing the first 3 numbers in LINE 100 to 255,
                    255, 255. See the section on defining sprite shapes
                    for more information.

LINE 200:

POKES+4,129         Waveform control set to 129 turns on the sound
                    effect.
POKES+4,128         Waveform control set to 128 turns off the sound
                    effect.
RETURN              Sends program back to end of line 70 after
                    waveform control settings are changed, to resume
                    program.

LINE 300:

POKES+11,129        Waveform control set to 129 turns on the sound
                    effect.
POKES+11,128        Waveform control set to 128 turns off the sound
                    effect.
RETURN              Sends program back to end of line 75 to resume.
                            </pre>
                        </blockquote>

                        <img src="https://s5.postimg.cc/pj51kyexj/c64_ez_sprt_chrt.png" alt="Easy Spritemaking Chart">

                        <h5>Spritemaking Notes</h5>

                        <table>
                            <thead>
                                <tr>
                                    <th colspan="5">Alternative Sprite Memory Pointers and Memory Locations Using
                                        Cassette Buffer</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td rowspan="2">Put In Memory (Set pointers)</td>
                                    <td>SPRT 0</td>
                                    <td>SPRT 1</td>
                                    <td>SPRT 2</td>
                                    <td rowspan="3">If you're using 1 to 3 sprites, you can use these memory locations
                                        in the cassette buffer (832 to 1023), but for more than 3 sprites we suggest
                                        using locations from 12288 to 12798 (see chart above).</td>
                                </tr>
                                <tr>
                                    <td>2040, 13</td>
                                    <td>2041, 14</td>
                                    <td>2042, 15</td>
                                </tr>
                                <tr>
                                    <td>Sprite Pixel Locations for Blocks 13-15</td>
                                    <td>832 to 894</td>
                                    <td>896 to 958</td>
                                    <td>960 to 1022</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>
                            <strong>Turning on Sprites:</strong>
                        </p>

                        <p>You can turn on any individual sprite by using POKE V+21 and the number from the chart...
                            BUT... turning on just ONE sprite will turn OFF any others. To turn on TWO OR MORE sprites,
                            ADD TOGETHER the numbers of the sprites you want
                            to turn on (Example: POKE V+21, 6 turns on sprites 1 and 2). Here is a method you can use to
                            turn one sprite off and on without affecting any of the others (useful for animation).</p>

                        <p>
                            <strong>Example:</strong>
                        </p>

                        <p>To turn off just sprite 0 type: POKE V+21,PEEK V+21AND(255-1). Change the number 1 in (255-1)
                            to 1,2,4,8,16,32,64, or 128 (for sprites 0-7). To re-enable the sprite and not affect the
                            other sprites currently turned on, POKE V+21,
                            PEEK(V+21)OR 1 and change the OR 1 to OR 2 (sprite 2), OR 4 (sprite 3), etc.</p>

                        <p>
                            <strong>X Position Values Beyond 255:</strong>
                        </p>

                        <p>X positions run from 0 to 255... and then START OVER from 0 to 255. To put a sprite beyond X
                            position 255 on the far right side of the screen, you must first POKE V+ 16 as shown, THEN
                            POKE a new X valve from 0 to 63, which will
                            place the sprite in one of the X positions at the right side of the screen. To get back to
                            positions 0-255, POKE V+16,0 and POKE in an X value from 0 to 255.
                        </p>

                        <p>
                            <strong>Y Position Values:</strong>
                        </p>

                        <p>Y positions run from 0 to 255, including 0 to 49 off the TOP of the viewing area, 50 to 229
                            IN the,viewing area, and 230 to 255 off the BOTTOM of the viewing area.</p>

                        <p>
                            <strong>Sprite Colors:</strong>
                        </p>

                        <p>To make sprite 0 WHITE, type: POKE V+39,1 (use COLOR POKE SETTING shown in chart, and
                            INDIVIDUAL COLOR CODES shown below):</p>

                        <blockquote>
                            <pre>
0-BLACK     4-PURPLE        8-ORANGE        12-MED. GREY
1-WHITE     5-GREEN         9-BROWN         13-LT. GREEN
2-RED       6-BLUE          10-LT. RED      14-LT. BLUE
3-CYAN      7-YELLOW        11-DARK GREY    15-LT. GREY
                            </pre>
                        </blockquote>

                        <p>
                            <strong>Memory Location:</strong>
                        </p>

                        <p>You must "reserve" a separate 64-BYTE BLOCK of numbers in the computer's memory for each
                            sprite of which 63 BYTES will be used for sprite data. The memory settings shown below are
                            recommended for the "sprite pointer" settings in
                            the chart above. Each sprite will be unique and you'll have to define it as you wish. To
                            make all sprites exactly the same, point the sprites you want to look the same to the same
                            register for sprites.</p>

                        <p>
                            <strong>Different Sprite Pointer Settings:</strong>
                        </p>

                        <p>These sprite pointer settings are RECOMMENDATIONS ONLY.</p>

                        <p>Caution: you can set your sprite pointers anywhere in RAM memory but if you set them too
                            "low" in memory a long BASIC program may overwrite your sprite data, or vice versa. To
                            protect an especially LONG BASIC PROGRAM from overwriting
                            sprite data, you may want to set the sprites at a higher area of memory (for example,
                            2040,192 for sprite 0 at locations 12288 to 12350... 2041,193 at locations 12352 to 12414
                            for sprite 1 and so on... by adjusting the memory
                            locations from which sprites get their "data," you can define as many as 64 different
                            sprites plus a sizable BASIC program. To do this, define several sprite "shapes" in your
                            DATA statements and then redefine a particular sprite
                            by changing the "pointer" so the sprite you are using is "pointed" at different areas of
                            memory containing different sprite picture data. See the "Dancing Mouse" to see how this
                            works. If you want two or more sprites to have
                            THE SAME SHAPE (you can still change position and color of each sprite), use the same sprite
                            pointer and memory location for the sprites you want to match (for example, you can point
                            sprites 0 and 1 to the same location by
                            using POKE 2040,192 and POKE 2041, 192).</p>

                        <p>
                            <strong>Priority:</strong>
                        </p>

                        <p>Priority means one sprite will appear to move "in front of" or "behind" another sprite on the
                            display screen. Sprites with more priority always appear to move "in front of" or "on top
                            of" sprites with less priority. The rule is
                            that lower numbered sprites have priority over higher numbered sprites. Sprite 0 has
                            priority over all other sprites. Sprite 7 has no priority in relation to the other sprites.
                            Sprite 1 has priority over sprites 2-7, etc. If
                            you put two sprites in the some position, the sprite with the higher priority will appear IN
                            FRONT OF the sprite with the lower priority. The sprite with lower priority will either be
                            obscured, or will "show through" (from
                            "behind") the sprite with higher priority.
                        </p>

                        <p>
                            <strong>Using Multi-Color:</strong>
                        </p>

                        <p>You can create multi-colored sprites although using multi-color mode requires that you use
                            PAIRS of pixels instead of individual pixels in your sprite picture (in other words each
                            colored "dot" or "block" in the sprite will consist
                            of two pixels side by side). You have 4 colors to choose from: Sprite Color (chart,above),
                            Multi-Color 1, Multi-Color 2 and "Background Color" (background is achieved by using zero
                            settings which let the background color "show
                            through"). Consider one horizontal 8-pixel block in a sprite picture. The color of each PAIR
                            of pixels is determined according to whether the left, right, or both pixels are solid, like
                            this:
                        </p>

                        <img src="https://s5.postimg.cc/pii2oatgn/c64_sprite_mc.png" alt="Using Multi-color">

                        <p>Look at the horizontal 8-pixel row shown below. This block sets the first two pixels to
                            background color, the second two pixels to Multi-Color 1, the third two pixels to Sprite
                            Color and the fourth two pixels to Multi- Color 2.
                            The color of each PAIR of pixels depends on which bits in each pair are solid and which are
                            blank, according to the illustration above. After you determine which colors you want in
                            each pair of pixels, the next step is to add
                            the values of the solid pixels in the 8-pixel block, and POKE that number into the proper
                            memory location. For example, if the 8-pixel row shown below is the first block in a sprite
                            which begins at memory location 832, the
                            value of the solid pixels is 16+8+2+1 27, so you would POKE 832,27.</p>

                        <img src="https://s5.postimg.cc/d3vao0c93/c64_sprite_mc2.png" alt="Using Multi-color 2">

                        <p>
                            <strong>Collision:</strong>
                        </p>

                        <p>You can detect whether a sprite has collided with another sprite by using this line: IF
                            PEEK(V+30)ANDX=XTHEN [insert action here]. This line checks to see if a particular sprite
                            has collided with ANY OTHER SPRITE, where X equals
                            1 for sprite 0, 2 for sprite 1, 4 for sprite 2, 8 for sprite 3, 16 for sprite 4, 32 for
                            sprite 5, 64 for sprite 6, and 128 for sprite 7. To check to see if the sprite has collided
                            with a "BACKGROUND CHARACTER" use this line:
                            IF PEEK(V+31)ANDX=XTHEN [insert action here].
                        </p>

                        <h5>Using Graphics Characters in Data Statements</h5>

                        <p>The following program allows you to create a sprite using blanks and solid circles
                            &lt;SHIFT+Q&gt; in DATA statements. The sprite and the numbers POKED into the sprite data
                            registers are displayed.
                        </p>

                        <blockquote>
                            <pre>
START TOK64 PAGE181.PRG
10 PRINT"{CLEAR}":FORI=0TO63:POKE832+I,0:NEXT
20 GOSUB60000
999 END
60000 DATA"         &#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;        "
60001 DATA"       &#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;      "
60002 DATA"      &#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;     "
60003 DATA"      &#9679;&#9679;&#9679;&#9679;&#9679;   &#9679;&#9679;&#9679;&#9679;&#9679;     "
60004 DATA"     &#9679;&#9679;&#9679;&#9679;&#9679; &#9679;&#9679;&#9679;  &#9679;&#9679;&#9679;&#9679;    "
60005 DATA"     &#9679;&#9679;&#9679;&#9679;&#9679; &#9679;&#9679;&#9679; &#9679;&#9679;&#9679;&#9679;&#9679;    "
60006 DATA"     &#9679;&#9679;&#9679;&#9679;&#9679; &#9679;&#9679;&#9679;  &#9679;&#9679;&#9679;&#9679;    "
60007 DATA"      &#9679;&#9679;&#9679;&#9679;&#9679;   &#9679;&#9679;&#9679;&#9679;&#9679;     "
60008 DATA"      &#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;     "
60009 DATA"      &#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;     "
60010 DATA"      &#9679; &#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679; &#9679;     "
60011 DATA"       &#9679; &#9679;&#9679;&#9679;&#9679;&#9679;&#9679;&#9679; &#9679;      "
60012 DATA"       &#9679;  &#9679;&#9679;&#9679;&#9679;&#9679;  &#9679;      "
60013 DATA"        &#9679;  &#9679;&#9679;&#9679;  &#9679;       "
60014 DATA"        &#9679;  &#9679;&#9679;&#9679;  &#9679;       "
60015 DATA"         &#9679;  &#9679;  &#9679;        "
60016 DATA"         &#9679;  &#9679;  &#9679;        "
60017 DATA"          &#9679;&#9679;&#9679;&#9679;&#9679;         "
60018 DATA"          &#9679;&#9679;&#9679;&#9679;&#9679;         "
60019 DATA"          &#9679;&#9679;&#9679;&#9679;&#9679;         "
60020 DATA"           &#9679;&#9679;&#9679;          "
60100 V=53248:POKEV,200:POKEV+1,100:POKEV+21,1:POKEV+39,14:POKE2040,13
60105 POKEV+23,1:POKEV+29,1
60110 FORI=0TO20:READA$:FORK=0TO2:T=0:FORJ=0TO7:B=0
60140 IFMID$(A$,J+K*8+1,1)="Q"THENB=1
60150 T=T+B*2^(7-J):NEXT:PRINTT;:POKE832+I*3+K,T:NEXT:PRINT:NEXT
60200 RETURN
STOP TOK64
                            </pre>
                        </blockquote>
                    </section>

                    <h3>Programming Sound and Music</h3>

                    <section class="main-section" id="Sound_Introduction">
                        <header>
                            <h4>Sound Introduction</h4>
                        </header>

                        <p>Your Commodore computer is equipped with one of the most sophisticated electronic music
                            synthesizers available on any computer. It comes complete with three voices, totally
                            addressable, ATTACK/DECAY/SUSTAIN/ RELEASE (ADSR), filtering,
                            modulation, and "white noise." All of these capabilities are directly available for you
                            through a few easy to use BASIC and/or assembly language statements and functions. This
                            means that you can make very complex sounds and
                            songs using programs that are relatively simple to design.</p>
                        <p>This section of your Programmer's Reference Guide has been created to help you explore all
                            the capabilities of the 6581 "SID" chip, the sound and music synthesizer inside your
                            Commodore computer. We'll explain both the theory behind
                            musical ideas and the practical aspects of turning those ideas into real finished songs on
                            your Commodore computer.</p>
                        <p>You need not be an experienced programmer nor a music expert to achieve exciting results from
                            the music synthesizer. This section is full of programming examples with complete
                            explanations to get you started.</p>
                        <p>You get to the sound generator by POKEing into specified memory locations. A full list of the
                            locations used is provided in Appendix O. We will go through each concept, step by step. By
                            the end you should be able to create an almost
                            infinite variety of sounds, and be ready to perform experiments with sound on your own.</p>
                        <p>Each section of this chapter begins by giving you an example and a full line-by-line
                            description of each program, which will show you how to use the characteristic being
                            discussed. The technical explanation is for you to read whenever
                            you are curious about what is actually going on. The workhorse of your sound programs is the
                            POKE statement. POKE sets the indicated memory location (MEM) equal to a specified value
                            (NUM).</p>

                        <blockquote>
                            <code>POKE MEM,NUM</code>
                        </blockquote>

                        <p>The memory locations (MEM) used for music synthesis start at 54272 ($D400) in the Commodore
                            64. The memory locations 54272 to 54296 inclusive are the POKE locations you need to
                            remember when you're using the 6581 (SID) chip register
                            map. Another way to use the locations above is to remember only location 54272 and then add
                            a number from 0 through 24 to it. By doing this you can POKE all the locations from 54272 to
                            54296 that you need from the SID chip.
                            The numbers (NUM) that you use in your POKE statement must be between 0 and 255, inclusive.
                        </p>
                        <p>When you've had a little more practice with making music, then you can get a little more
                            involved, by using the PEEK function. PEEK is a function that is equal to the value
                            currently in the indicated memory location.
                        </p>

                        <blockquote>
                            <code>X=PEEK(MEM)</code>
                        </blockquote>

                        <p>The value of the variable X is set equal to the current contents of memory location MEM.</p>
                        <p>Of course, your programs include other BASIC commands, but for a full explanation of them,
                            refer to the BASIC Statements section of this manual.
                        </p>
                        <p>Let's jump right in and try a simple program using only one of the three voices. Computer
                            ready? Type NEW, then type in this program, and save it on your Commodore DATASSETTE(TM) or
                            disk. Then, RUN it.</p>

                        <p class="example">Example Program 1</p>
                        <blockquote>
                            <code>
                                START TOK64 PAGE185.PRG
                                <br>5 S=54272
                                <br>10 FORL=STOS+24:POKEL,0:NEXT:REM CLEAR SOUND CHIP
                                <br>20 POKES+5,9:POKES+6,0
                                <br>30 POKES+24,15 :REM SET VOLUME TO MAXIMUM
                                <br>40 READHF,LF,DR
                                <br>50 IFHF&lt;0THENEND
                                <br>60 POKES+1,HF:POKES,LF
                                <br>70 POKES+4,33
                                <br>80 FORT=1TODR:NEXT
                                <br>90 POKES+4,32:FORT=1TO50:NEXT
                                <br>100 GOTO40
                                <br>110 DATA25,177,250,28,214,250
                                <br>120 DATA25,177,250,25,177,250
                                <br>130 DATA25,177,125,28,214,125
                                <br>140 DATA32,94,750,25,177,250
                                <br>150 DATA28,214,250,19,63,250
                                <br>160 DATA19,63,250,19,63,250
                                <br>170 DATA21,154,63,24,63,63
                                <br>180 DATA25,177,250,24,63,125
                                <br>190 DATA19,63,250,-1,-1,-1
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>Here's a line-by-line description of the program you've just typed in. Refer to it whenever
                            you feel the need to investigate parts of the program that you don't understand completely.
                        </p>

                        <p class="example">Line-by-line Explanation of Example Program 1</p>
                        <table>
                            <thead>
                                <tr>
                                    <th>Line(s)</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>5</td>
                                    <td>Set S to start of sound chip</td>
                                </tr>
                                <tr>
                                    <td>10</td>
                                    <td>Clear all sound chip registers</td>
                                </tr>
                                <tr>
                                    <td>20</td>
                                    <td>Set Attack/Decay for voice 1 (A=0, D=9). Set Sustain/Release for voice 1 (S=0,
                                        R=0).
                                    </td>
                                </tr>
                                <tr>
                                    <td>30</td>
                                    <td>Set volume at maximum.</td>
                                </tr>
                                <tr>
                                    <td>40</td>
                                    <td>Read high frequency, low frequency, duration of note.</td>
                                </tr>
                                <tr>
                                    <td>50</td>
                                    <td>When high frequency less than zero, song is over.</td>
                                </tr>
                                <tr>
                                    <td>60</td>
                                    <td>Poke high and low frequency of voice 1.</td>
                                </tr>
                                <tr>
                                    <td>70</td>
                                    <td>Gate sawtooth waveform for voice 1.</td>
                                </tr>
                                <tr>
                                    <td>80</td>
                                    <td>Timing loop for duration of note.</td>
                                </tr>
                                <tr>
                                    <td>90</td>
                                    <td>Release sawtooth waveform for voice 1.</td>
                                </tr>
                                <tr>
                                    <td>100</td>
                                    <td>Return for next note.</td>
                                </tr>
                                <tr>
                                    <td>110-180</td>
                                    <td>Data for song: high frequency, low frequency, duration (number of counts) for
                                        each note.</td>
                                </tr>
                                <tr>
                                    <td>190</td>
                                    <td>Last note of song and negative is signaling end of song.</td>
                                </tr>
                            </tbody>
                        </table>

                        <h5>Volume Control</h5>

                        <p>Chip register 24 contains the overall volume control. The volume can be set anywhere between
                            0 and 15. The other four bits are used for purposes we'll get into later. For now it is
                            enough to know volume is 0 to 15. Look at line
                            30 to see how it's set in Example Program 1.
                        </p>

                        <h5>Frequencies of Sound Waves</h5>

                        <p>Sound is created by the movement of air in waves. Think of throwing a stone into a pool and
                            seeing the waves radiate outward. When similar waves are created in air, we hear it. If we
                            measure the time between one peak of a wave
                            and the next, we find the number of seconds for one cycle of the wave (n = number of
                            seconds). The reciprocal of this number (1/n) gives you the cycles per second. Cycles per
                            second are more commonly known as the frequency.
                            The highness or lowness of a sound (pitch) is determined by the frequency of the sound waves
                            produced.
                        </p>
                        <p>The sound generator in your Commodore computer uses two locations to determine the frequency.
                            Appendix E gives you the frequency values you need to reproduce a full eight octaves of
                            musical notes. To create a frequency other than
                            the ones listed in the note table use "F
                            <sub>out</sub>" (frequency output) and the following formula to represent the frequency (F
                            <sub>n</sub>) of the sound you want to create. Remember that each note requires both a high
                            and a low frequency number.</p>

                        <blockquote>
                            <p>F
                                <sub>n</sub> = F
                                <sub>out</sub> / .06097</p>
                        </blockquote>

                        <p>Once you've figured out what F
                            <sub>n</sub> is for your "new" note the next step is to create the high and low frequency
                            values for that note. To do this you must first round off Fn so that any numbers to the
                            right of the decimal point are left off. You
                            are now left with an integer value. Now you can set the high frequency location (F
                            <sub>hi</sub>) by using the formula F
                            <sub>hi</sub>=INT(F
                            <sub>n</sub>/256) and the low frequency location (F
                            <sub>lo</sub>) should be F
                            <sub>lo</sub>=F
                            <sub>n</sub>-(256*F
                            <sub>hi</sub>).</p>
                        <p>At this point you have already played with one voice of your computer. If you wanted to stop
                            here you could find a copy of your favorite tune and become the maestro conducting your own
                            computer orchestra in your "at home" concert
                            hall.</p>
                    </section>

                    <section class="main-section" id="Using_Multiple_Voices">
                        <h4>Using Multiple Voices</h4>

                        <p> Your Commodore computer has three independently controlled voices (oscillators). Our first
                            example program used only one of them. later on, you'll learn how to change the quality of
                            the sound made by the voices. But right now,
                            let's get all three voices singing.</p>
                        <p>This example program shows you one way to translate sheet music for your computer orchestra.
                            Try typing it in, and then SAVE it on your DATASSETTE(TM) or disk. Don't forget to type NEW
                            before typing in this program.
                        </p>

                        <p class="example">Example Program 2</p>
                        <blockquote>
                            <code>
                                START TOK64 PAGE187.PRG
                                <br>10 S=54272:FORL=STOS+24:POKEL,0:NEXT
                                <br>20 DIMH(2,200),L(2,200),C(2,200)
                                <br>30 DIMFQ(11)
                                <br>40 V(0)=17:V(1)=65:V(2)=33
                                <br>50 POKES+10,8:POKES+22,128:POKES+23,244
                                <br>60 FORI=0TO11:READFQ(I):NEXT
                                <br>100 FORK=0TO2
                                <br>110 I=0
                                <br>120 READNM
                                <br>130 IFNM=0THEN250
                                <br>140 WA=V(K):WB=WA-1:IFNM0THENNM=-NM:WA=0:WB=0
                                <br>150 DR%NM/128:OC%=(NM-128*DR%)/16
                                <br>160 NT=NM-128*DR%-16*OC%
                                <br>170 FR=FQ(NT)
                                <br>180 IFOC%=7THEN200
                                <br>190 FORJ=6TOOC%STEP-1:FR=FR/2:NEXT
                                <br>200 HF%=FR/256:LF%=FR-256*HF%
                                <br>210 IFDR%=1THENH(K,I)=HF%:L(K,I)=LF%:C(K,I)=WA:I=I+1:GOTO120
                                <br>220 FORJ=1TODR%-1:H(K,I)=HF%:L(K,I)=LF%:C(K,I)=WA:I=I+1:NEXT
                                <br>230 H(K,I)=HF%:L(K,I)=LF%:C(K,I)=WB
                                <br>240 I=I+1:GOTO120
                                <br>250 IFI>IMTHENIM=I
                                <br>260 NEXT
                                <br>500 POKES+5,0:POKES+6,240
                                <br>510 POKES+12,85:POKES+13,133
                                <br>520 POKES+19,10:POKES+20,197
                                <br>530 POKES+24,31
                                <br>540 FORI=0TOIM
                                <br>550 POKES,L(0,I):POKES+7,L(1,I):POKES+14,L(2,I)
                                <br>560 POKES+1,H(0,I):POKES+8,H(1,I):POKES+15,H(2,I)
                                <br>570 POKES+4,C(0,I):POKES+11,C(1,I):POKES+18,C(2,I)
                                <br>580 FORT=1TO80:NEXT:NEXT
                                <br>590 FORT=1TO200:NEXT:POKES+24,0
                                <br>600 DATA34334,36376,38539,40830
                                <br>610 DATA43258,45830,48556,51443
                                <br>620 DATA54502,57743,61176,64814
                                <br>1000 DATA594,594,594,596,596,1618,587,592,587.585,331,336
                                <br>1010 DATA1097,583,585,585,585,587,587,1609,585,331,337,594,594,593
                                <br>1020 DATA1618,594,596,594,592,587,1616,587,585,331,336,841,327
                                <br>1999 DATA1607,0
                                <br>2000 DATA583,585,583,583,327,329,1611,583,585,578,578,578
                                <br>2010 DATA196,198,583,326,578,326,327,329,327,329,326,578,583
                                <br>2020 DATA1606,582,322,324,582,587,329,327,1606,583,327,329,587,331,329
                                <br>2999 DATA329,328,1609,578,834,324,322,327,585,1602,0
                                <br>3000 DATA567,566,567,304,306,308,310,1591,567,311,310,567
                                <br>3010 DATA306,304,299,308,304,171,176,306,291,551,306,308
                                <br>3020 DATA310,308,310,306,295,297,299,304,1586,562,567,310,315,311
                                <br>3030 DATA308,313,297,1586,567,560,311,309,308,309,306,308
                                <br>3999 DATA1577,299,295,306,310,311,304,562,546,1575,0
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>Here is a line-by-line explanation of Example Program 2. For now, we are interested in how
                            the three voices are controlled.</p>

                        <p class="example">Line-by-line Explanation of Example Program 2</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Line</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>10</td>
                                    <td>Set S equal to start of sound chip and clear all sound chip registers.</td>
                                </tr>
                                <tr>
                                    <td>20</td>
                                    <td>Dimension arrays to contain activity of song, 1/16th of a measure per location.
                                    </td>
                                </tr>
                                <tr>
                                    <td>30</td>
                                    <td>Dimension array to contain base frequency for each note</td>
                                </tr>
                                <tr>
                                    <td>40</td>
                                    <td>Store waveform data for each voice.</td>
                                </tr>
                                <tr>
                                    <td>50</td>
                                    <td>Set high pulse width for voice 2.
                                        <br>Set high frequency for filter cutoff.
                                        <br>Set resonance for filter and filter voice 3.</td>
                                </tr>
                                <tr>
                                    <td>60</td>
                                    <td>Read in base frequency for each note.</td>
                                </tr>
                                <tr>
                                    <td>100</td>
                                    <td>Begin decoding loop for each voice.</td>
                                </tr>
                                <tr>
                                    <td>110</td>
                                    <td>Initialize pointer to activity array.</td>
                                </tr>
                                <tr>
                                    <td>120</td>
                                    <td>Read coded note.</td>
                                </tr>
                                <tr>
                                    <td>130</td>
                                    <td>If coded note is zero, then next voice.</td>
                                </tr>
                                <tr>
                                    <td>140</td>
                                    <td>Set waveform controls to proper voice.
                                        <br>If silence, set waveform controls to 0.
                                    </td>
                                </tr>
                                <tr>
                                    <td>150</td>
                                    <td>Decode duration and octave.</td>
                                </tr>
                                <tr>
                                    <td>160</td>
                                    <td>Decode note.</td>
                                </tr>
                                <tr>
                                    <td>170</td>
                                    <td>Get base frequency for this note.</td>
                                </tr>
                                <tr>
                                    <td>180</td>
                                    <td>If highest octave, skip division loop.</td>
                                </tr>
                                <tr>
                                    <td>190</td>
                                    <td>Divide base frequency by 2 appropriate number of times.</td>
                                </tr>
                                <tr>
                                    <td>200</td>
                                    <td>Get high and low frequency bytes.</td>
                                </tr>
                                <tr>
                                    <td>210</td>
                                    <td>If sixteenth note, set activity array:
                                        <br>high frequency, low frequency, and waveform control (voice on).</td>
                                </tr>
                                <tr>
                                    <td>220</td>
                                    <td>For all but last beat of note, set activity array:
                                        <br>high frequency, low frequency, and waveform control (voice on).</td>
                                </tr>
                                <tr>
                                    <td>230</td>
                                    <td>For last beat of note, set activity array:
                                        <br>high frequency, low frequency, and waveform control (voice off).</td>
                                </tr>
                                <tr>
                                    <td>240</td>
                                    <td>Increment pointer to activity array. Get next note.</td>
                                </tr>
                                <tr>
                                    <td>250</td>
                                    <td>If longer than before, reset number of activities.</td>
                                </tr>
                                <tr>
                                    <td>260</td>
                                    <td>Go back for next voice.</td>
                                </tr>
                                <tr>
                                    <td>500</td>
                                    <td>Set Attack/Decay for Voice 1 (A=0, D=0)
                                        <br>Set Sustain/Release for voice 1 (S=15, R=0)</td>
                                </tr>
                                <tr>
                                    <td>510</td>
                                    <td>Set Attack/Decay for voice 2 (A=5, D=5)
                                        <br>Set Sustain/Release for voice 2 (S=15, R=0)</td>
                                </tr>
                                <tr>
                                    <td>520</td>
                                    <td>Set Attack/Decay for voice 3 (A=0, D=10)
                                        <br>Set Sustain/Release 3 (S=12, R=5)
                                    </td>
                                </tr>
                                <tr>
                                    <td>530</td>
                                    <td>Set volume 15, low-pass filtering</td>
                                </tr>
                                <tr>
                                    <td>540</td>
                                    <td>Start loop for every 1/16th of a measure.</td>
                                </tr>
                                <tr>
                                    <td>550</td>
                                    <td>POKE low frequency from activity array for all voices.</td>
                                </tr>
                                <tr>
                                    <td>560</td>
                                    <td>POKE high frequency from activity array for all voices.</td>
                                </tr>
                                <tr>
                                    <td>570</td>
                                    <td>POKE waveform control from activity array for all voices.</td>
                                </tr>
                                <tr>
                                    <td>580</td>
                                    <td>Timing loop for 1/16th of a measure and back for next 1/16th of a measure</td>
                                </tr>
                                <tr>
                                    <td>590</td>
                                    <td>Pause, then turn off volume</td>
                                </tr>
                                <tr>
                                    <td>600-620</td>
                                    <td>Base frequency data</td>
                                </tr>
                                <tr>
                                    <td>1000-1999</td>
                                    <td>Voice 1 data</td>
                                </tr>
                                <tr>
                                    <td>2000-2999</td>
                                    <td>Voice 2 data</td>
                                </tr>
                                <tr>
                                    <td>3000-3999</td>
                                    <td>Voice 3 data</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>The values used in the data statements were found by using the note table in <a
                                href="#E_Music_Note_Values">Appendix E</a> and the chart below:</p>

                        <table>
                            <tr>
                                <th>Note Type</th>
                                <th>Duration</th>
                            </tr>
                            <tr>
                                <td>16th</td>
                                <td>128</td>
                            </tr>
                            <tr>
                                <td>8th</td>
                                <td>256</td>
                            </tr>
                            <tr>
                                <td>Dotted 8th</td>
                                <td>384</td>
                            </tr>
                            <tr>
                                <td>Quarter</td>
                                <td>512</td>
                            </tr>
                            <tr>
                                <td>Quarter + 16th</td>
                                <td>640</td>
                            </tr>
                            <tr>
                                <td>Dotted Quarter</td>
                                <td>768</td>
                            </tr>
                            <tr>
                                <td>Half</td>
                                <td>1024</td>
                            </tr>
                            <tr>
                                <td>Half + 16th</td>
                                <td>1152</td>
                            </tr>
                            <tr>
                                <td>Half + 8th</td>
                                <td>1280</td>
                            </tr>
                            <tr>
                                <td>Dotted Half</td>
                                <td>1536</td>
                            </tr>
                            <tr>
                                <td>Whole</td>
                                <td>2048</td>
                            </tr>

                        </table>

                        <p>The note number from the note table is added to the duration above. Then each note can be
                            entered using only one number which is decoded by your program. This is only one method of
                            coding note values. You may be able to come up
                            with one with which you are more comfortable. The formula used here for encoding a note is
                            as follows:</p>

                        <ol>
                            <li>The duration (number of 1/16ths of a measure) is multiplied by 8.</li>
                            <li>The result of step 1 is added to the octave you've chosen (0-7).</li>
                            <li>The result of step 2 is then multiplied by 16.</li>
                            <li>Add your note choice (0-11) to the result of the operation in step 3.</li>
                        </ol>

                        <p>In other words:</p>

                        <blockquote>
                            <code>((((D*8)+O)*16)+N)</code>
                        </blockquote>

                        <p>Where D = duration, O = octave, and N = note.</p>

                        <p>A silence is obtained by using the negative of the duration number (number of 1/16ths of a
                            measure * 128).</p>

                        <h5>Controlling Multiple Voices</h5>

                        <p>Once you have gotten used to using more than one voice, you will find that the timing of the
                            three voices needs to be coordinated. This is accomplished in this program by:</p>

                        <ol>
                            <li>Divide each musical measure into 16 parts.</li>
                            <li>Store the events that occur in each 1/16th measure interval in three separate arrays.
                            </li>
                        </ol>

                        <p>The high and low frequency bytes are calculated by dividing the fre- quencies of the highest
                            octave by two (lines 180 and 190). The waveform control byte is a start signal for beginning
                            a note or continuing a note that is already
                            playing. It is a stop signal to end a note. The waveform choice is made once for each voice
                            in line 40.</p>

                        <p>Again, this is only one way to control multiple voices. You may come up with your own
                            methods. However, you should now be able to take any piece of sheet music and figure out the
                            notes for all three voices.</p>

                        <h5>Changing Waveforms</h5>

                        <p>The tonal quality of a sound is called the timbre. The timbre of a sound is determined
                            primarily by its "waveform." If you remember the example of throwing a pebble into the water
                            you know that the waves ripple evenly across the
                            pond. These waves almost look like the first sound wave we're going to talk about, the
                            sinusoidal wave, or sine wave for short (shown below).</p>

                        <img src="https://i.postimg.cc/pT5S1jR3/sine.png" alt="Sine Wave">

                        <p>To make what we're talking about a bit more practical, let's go back to the first example
                            program to investigate different waveforms. The reason for this is that you can hear the
                            changes more easily using only one voice. LOAD the
                            first music program that you typed in earlier, from your DATASSETTE(TM) or disk, and RUN it
                            again. That program is using the sawtooth waveform (shown here)</p>

                        <img src="https://i.postimg.cc/yxqGqNNx/sawtooth.png" alt="Sawtooth Wave">

                        <p>from the 6581 SID chip's sound generating device. Try changing the note start number in line
                            70 from 33 to 17 and the note stop number in line 90 from 32 to 16. Your program should now
                            look like this:</p>

                        <p class="example">Example Program 3 (Example 1 Modified):</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE193.PRG
                                <br>5 S=54272
                                <br>10 FORL=STOS+24:POKEL,0:NEXT
                                <br>20 POKES+5,9:POKES+6,0
                                <br>30 POKES+24,15
                                <br>40 READHF,LF,DR
                                <br>50 IFHF&lt;0THENEND
                                <br>60 POKES+1,HF:POKES,LF
                                <br>70 POKES+4,17
                                <br>80 FORT=1TODR:NEXT
                                <br>90 POKES+4,16:FORT=1TO50:NEXT
                                <br>100 GOTO40
                                <br>110 DATA25,177,250,28,214,250
                                <br>120 DATA25,177,250,25,177,250
                                <br>130 DATA25,177,125,28,214,125
                                <br>140 DATA32,94,750,25,177,250
                                <br>150 DATA28,214,250,19,63,250
                                <br>160 DATA19,63,250,19,63,250
                                <br>170 DATA21,154,63,24,63,63
                                <br>180 DATA25,177,250,24,63,125
                                <br>190 DATA19,63,250,-1,-1,-1
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>Now RUN the program.</p>

                        <p> Notice how the sound quality is different, less twangy, more hollow. That's because we
                            changed the sawtooth waveform into a triangular waveform (shown below).</p>

                        <img src="https://i.postimg.cc/NFPtJVyx/tri-wave.png" alt="Triangle Wave">

                        <p>The third musical waveform is called a variable pulse wave (shown below).</p>

                        <img src="https://i.postimg.cc/fybZvZbL/pulse-wave.png" alt="Pulse Wave">

                        <p>It is a rectangular wave and you determine the length of the pulse cycle by defining the
                            proportion of the wave which will be high. This is accomplished for voice 1 by using
                            registers 2 and 3: Register 2 is the low byte of the
                            pulse width (Lpw = 0 through 255). Register 3 is the high 4 bits (Hpw = 0 through 15).</p>

                        <p>Together these registers specify a 12-bit number for your pulse width, which you can
                            determine by using the following formula:</p>

                        <blockquote>
                            <code>PW
                                <sub>n</sub>=H
                                <sub>pw</sub>*256+L
                                <sub>pw</sub>
                            </code>
                        </blockquote>

                        <p>The pulse width is determined by the following equation:</p>

                        <blockquote>
                            <code>PW
                                <sub>out</sub>=(PW
                                <sub>n</sub>/40.95) %
                            </code>
                        </blockquote>

                        <p>When PWn has a value of 2048, it will give you a square wave. That means that register 2
                            (Lpw) = 0 and register 3 (Hpw) = 8.</p>

                        <p>Now try adding this line to your program:</p>

                        <blockquote>
                            <code>15 POKES+3.8:POKES+2,0</code>
                        </blockquote>

                        <p>Then change the start number in line 70 to 65 and the stop number in fine 90 to 64, and RUN
                            the program. Now change the high pulse width (register 3 in line 15) from an 8 to a 1.
                            Notice how dramatic the difference in sound quality
                            is?</p>

                        <p>The last waveform available to you is white noise (shown here).</p>

                        <img src="https://i.postimg.cc/mDLGbRCw/noise.png" alt="Noise">

                        <p>It is used mostly for sound effects and such. To hear how it sounds, try changing the start
                            number in line 70 to 129 and the stop number in line 90 to 128.</p>

                        <h5>Understanding Waveforms</h5>

                        <p>When a note is played, it consists of a sine wave oscillating at the fundamental frequency
                            and the harmonics of that wave.</p>

                        <p>The fundamental frequency defines the overall pitch of the note. Harmonics are sine waves
                            having frequencies which are integer multiples of the fundamental frequency. A sound wave is
                            the fundamental frequency and all of the harmonics
                            it takes to make up that sound.</p>

                        <img src="https://i.postimg.cc/mrS0pqJF/waveform.png" alt="Waveform">

                        <p>In musical theory let's say that the fundamental frequency is harmonic number 1. The second
                            harmonic has a frequency twice the fundamental frequency, the third harmonic is three times
                            the fundamental frequency, and so on. The amounts
                            of each harmonic present in a note give it its timbre.
                        </p>

                        <p>An acoustic instrument, like a guitar or a violin, has a very compli- cated harmonic
                            structure. In fact, the harmonic structure may vary as a single note is played. You have
                            already played with the waveforms available in your Commodore
                            music synthesizer. Now let's talk about how the harmonics work with the triangular,
                            sawtooth, and rectangular waves.</p>

                        <p>A triangular wave contains only odd harmonics. The amount of each harmonic present is
                            proportional to the reciprocal of the square of the harmonic number. In other words harmonic
                            number 3 is 1/9 quieter than harmonic number 1,
                            because the harmonic 3 squared is 9 (3 X 3) and the reciprocal of 9 is 1/9.</p>

                        <p>As you can see, there is a similarity in shape of a triangular wave to a sine wave
                            oscillating at the fundamental frequency.</p>

                        <p>Sawtooth waves contain all the harmonics. The amount of each harmonic present is proportional
                            to the reciprocal of the harmonic number. For example, harmonic number 2 is 1/2 as loud as
                            harmonic number 1.</p>

                        <p>The square wave contains odd harmonics in proportion to the reciprocal of the harmonic
                            number. Other rectangular waves have varying harmonic content. By changing the pulse width,
                            the timbre of the sound of a rectangular wave can
                            be varied tremendously.</p>

                        <p>By choosing carefully the waveform used, you can start with a harmonic structure that looks
                            somewhat like the sound you want. To refine the sound, you can add another aspect of sound
                            quality available on your Commodore 64 called
                            filtering, which we'll discuss later in this section.
                        </p>
                    </section>

                    <section class="main-section" id="Envelope_Generator">

                        <h4>The Envelope Generator</h4>

                        <p>The volume of a musical tone changes from the moment you first hear it, all the way through
                            until it dies out and you can't hear it anymore. When a note is first struck, it rises from
                            zero volume to its peak volume. The rate at
                            which this happens is called the ATTACK. Then, it fails from the peak to some middle-ranged
                            volume. The rate at which the fall of the note occurs is called the DECAY. The mid-ranged
                            volume itself is called the SUSTAIN level.
                            And finally, when the note stops playing, it fails from the SUSTAIN level to zero volume.
                            The rate at which it fails is called the RELEASE. Here is a sketch of the four phases of a
                            note:
                        </p>

                        <img src="https://i.postimg.cc/63FJCZFH/adsr.png" alt="ADSR Envelope">

                        <p>Each of the items mentioned above give certain qualities and restrictions to a note. The
                            bounds are called parameters.</p>

                        <p>The parameters ATTACK/DECAY/SUSTAIN/RELEASE and collectively called ADSR, can be controlled
                            by your use of another set of locations in the sound generator chip. LOAD your first example
                            program again. RUN it again and remember how
                            it sounds. Then, changing line 20 so the program is like this:
                        </p>

                        <p class="example">Example Program 4 (Example 1 Modified)</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE197.PRG
                                <br>5 S=54272
                                <br>10 FORL=STOS+24:POKEL,0:NEXT
                                <br>20 POKES+5,88:POKES+6,195
                                <br>30 POKES+24,15
                                <br>40 READHF,LF,DR
                                <br>50 IFHF&lt;0THENEND
                                <br>60 POKES+1,HF:POKES,LF
                                <br>70 POKES+4,33
                                <br>80 FORT=1TODR:NEXT
                                <br>90 POKES+4,32:FORT=1TO50:NEXT
                                <br>100 GOTO40
                                <br>110 DATA25,177,250,28,214,250
                                <br>120 DATA25,177,250,25,177,250
                                <br>130 DATA25,177,125,28,214,125
                                <br>140 DATA32,94,750,25,177,250
                                <br>150 DATA28,214,250,19,63,250
                                <br>160 DATA19,63,250,19,63,250
                                <br>170 DATA21,154,63,24,63,63
                                <br>180 DATA25,177,250,24,63,125
                                <br>190 DATA19,63,250,-1,-1,-1
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>Registers 5 and 6 define the ADSR for voice 1. The ATTACK is the high nybble of register 5.
                            Nybble is half a byte, in other words the lower 4 or higher 4 on/off locations (bits) in
                            each register. DECAY is the low nybble. You can
                            pick any number 0 through 15 for ATTACK, multiply it by 16 and add to any number 0 through
                            15 for DECAY. The values that correspond to these numbers are listed below.</p>

                        <p>SUSTAIN level is the high nybble of register 6. It can be 0 through 15. It defines the
                            proportion of the peak volume that the SUSTAIN level will be. RELEASE rate is the low nybble
                            of register 6.</p>

                        <p>Here are the meanings of the values for ATTACK, DECAY, and RELEASE:</p>

                        <table>
                            <thead>
                                <tr>
                                    <th>Value</th>
                                    <th>Attack Rate (Time/Cycle)</th>
                                    <th>Decay/Release Rate (Time/Cycle)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>0</td>
                                    <td>2 ms</td>
                                    <td>6 ms</td>
                                </tr>
                                <tr>
                                    <td>1</td>
                                    <td>8 ms</td>
                                    <td>24 ms</td>
                                </tr>
                                <tr>
                                    <td>2</td>
                                    <td>16 ms</td>
                                    <td>48 ms</td>
                                </tr>
                                <tr>
                                    <td>3</td>
                                    <td>24 ms</td>
                                    <td>72 ms</td>
                                </tr>
                                <tr>
                                    <td>4</td>
                                    <td>38 ms</td>
                                    <td>114 ms</td>
                                </tr>
                                <tr>
                                    <td>5</td>
                                    <td>56 ms</td>
                                    <td>168 ms</td>
                                </tr>
                                <tr>
                                    <td>6</td>
                                    <td>68 ms</td>
                                    <td>204 ms</td>
                                </tr>
                                <tr>
                                    <td>7</td>
                                    <td>80 ms</td>
                                    <td>240 ms</td>
                                </tr>
                                <tr>
                                    <td>8</td>
                                    <td>100 ms</td>
                                    <td>300 ms</td>
                                </tr>
                                <tr>
                                    <td>9</td>
                                    <td>250 ms</td>
                                    <td>750 ms</td>
                                </tr>
                                <tr>
                                    <td>10</td>
                                    <td>500 ms</td>
                                    <td>1.5 s</td>
                                </tr>
                                <tr>
                                    <td>11</td>
                                    <td>800 ms</td>
                                    <td>2.4 s</td>
                                </tr>
                                <tr>
                                    <td>12</td>
                                    <td>1 s</td>
                                    <td>3 s</td>
                                </tr>
                                <tr>
                                    <td>13</td>
                                    <td>3 s</td>
                                    <td>9 s</td>
                                </tr>
                                <tr>
                                    <td>14</td>
                                    <td>5 s</td>
                                    <td>15 s</td>
                                </tr>
                                <tr>
                                    <td>15</td>
                                    <td>8 s</td>
                                    <td>24 s</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>Here are a few sample settings to try in your example program. Try these and a few of your
                            own. The variety of sounds you can produce is astounding! For a violin type sound, try
                            changing line 20 to read:</p>

                        <blockquote>
                            <code>20 POKES+5,88:POKES+6,89:REM A=5;D=8;S=5;R=9</code>
                        </blockquote>

                        <p>Change the waveform to triangle and get a xylophone type sound by using these lines:</p>

                        <blockquote>
                            <code>
                                20 POKES+5,9:POKES+6,9:REM A=0;D=9;S=O;R=9
                                <br>70 POKES+4,17
                                <br>90 POKES+4,16:FORT=1TO50:NEXT
                            </code>
                        </blockquote>

                        <p>Change the waveform to square and try a piano type sound with these lines:</p>

                        <blockquote>
                            <code>
                                15 POKES+3,8:POKES+2,0
                                <br>20 POKES+5,9:POKES+6,0: REM A=0;D=9;S=0;R=0
                                <br>70 POKES+4,65
                                <br>90 POKES+4,64:FORT=1TO50:NEXT
                            </code>
                        </blockquote>

                        <p>The most exciting sounds are those unique to the music synthesizer itself, ones that do not
                            attempt to mimic acoustic instruments. For example try:</p>

                        <blockquote>
                            <code>20 POKES+5,144:POKES+6,243:REM A=9;D=O; S=15;R=3</code>
                        </blockquote>
                    </section>

                    <section class="main-section" id="Filtering">

                        <h4>Filtering</h4>

                        <p>The harmonic content of a waveform can be changed by using a filter. The SID chip is equipped
                            with three types of filtering. They can be used separately or in combination with one
                            another. Let's go back to the sample program you've
                            been using to play with a simple example that uses a filter. There are several filter
                            controls to set.</p>

                        <p>You add line 15 in the program to set the cutoff frequency of the filter. The cutoff
                            frequency is the reference point for the filter. You SET the high and low frequency cutoff
                            points in registers 21 and 22. To turn ON the filter
                            for voice 1, POKE register 23.</p>

                        <p> Next change line 30 to show that a high-pass filter will be used (see the SID register map).
                        </p>

                        <p class="example">Example Program 5 (Example 1 Modified)</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE200.PRG
                                <br>5 S=54272
                                <br>10 FORL=STOS+24:POKEL,0:NEXT
                                <br>15 POKES+22,128:POKES+21,0:POKES+23,1
                                <br>20 POKES+5,9:POKES+6,0
                                <br>30 POKES+24,79
                                <br>40 READHF,LF,DR
                                <br>50 IFHF&lt;0THENEND
                                <br>60 POKES+1,HF:POKES,LF
                                <br>70 POKES+4,33
                                <br>80 FORT=1TODR:NEXT
                                <br>90 POKES+4,32:FORT=1TO50:NEXT
                                <br>100 GOTO40
                                <br>110 DATA25,177,250,28,214,250
                                <br>120 DATA25,177,250,25,177,250
                                <br>130 DATA25,177,125,28,214,125
                                <br>140 DATA32,94,750,25,177,250
                                <br>150 DATA28,214,250,19,63,250
                                <br>160 DATA19,63,250,19,63,250
                                <br>170 DATA21,154,63,24,63,63
                                <br>180 DATA25,177,250,24,63,125
                                <br>190 DATA19,63,250,-1,-1,-1
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p>Try RUNning the program now. Notice the lower tones have had their volume cut down. It makes
                            the overall quality of the note sound tinny. This is because you are using a high-pass
                            filter which attenuates (cuts down the level of)
                            frequencies below the specified cutoff frequency.
                        </p>

                        <p>There are three types of filters in your Commodore computer's SID chip. We have been using
                            the high-pass filter. It will pass all the frequencies at or above the cutoff, while
                            attenuating the frequencies below the cutoff.
                        </p>

                        <img src="https://i.postimg.cc/8zvZ4BHv/high-pass.png" alt="High Pass Filter">

                        <p>The SID chip also has a low-pass filter. As its name implies, this filter will pass the
                            frequencies below cutoff and attenuate those above.</p>

                        <img src="https://i.postimg.cc/Rq5HZfHr/low-pass.png" alt="Low Pass Filter">

                        <p>Finally, the chip is equipped with a bandpass filter, which passes a narrow band of
                            frequencies around the cutoff, and attenuates all others.</p>

                        <img src="https://i.postimg.cc/KjgTbQ4r/bandpass.png" alt="Band Pass Filter">

                        <p>The high- and low-pass filters can be combined to form a notch reject filter which passes
                            frequencies away from the cutoff while attenuating at the cutoff frequency.</p>

                        <img src="https://i.postimg.cc/tR1v7jxD/notch-reject.png" alt="Notch Reject Filter">

                        <p>Register 24 determines which type filter you want to use. This is in addition to register
                            24's function as the overall volume control. Bit 6 controls the high-pass filter (0 = off, 1
                            = on), bit 5 is the bandpass filter, and bit
                            4 is the low-pass filter. The low 3 bits of the cutoff frequency are determined by register
                            21 (L<sub>cf</sub>) (L<sub>cf</sub> = 0 through 7). While the 8 bits of the high cutoff
                            frequency are determined by register 22 (H
                            <sub>cf</sub>) (H<sub>cf</sub> = 0 through 255).</p>

                        <p>Through careful use of filtering, you can change the harmonic structure of any waveform to
                            get just the sound you want. In addition, changing the filtering of a sound as it goes
                            through the ADSR phases of its life can produce interesting
                            effects.</p>
                    </section>

                    <section class="main-section" id="Advanced_Techniques">

                        <h4>Advanced Techniques</h4>

                        <p> The SID chip's parameters can be changed dynamically during a note or sound to create many
                            interesting and fun effects. In order to make this easy to do, digitized outputs from
                            oscillator three and envelope generator three are
                            available for you in registers 27 and 28, respectively.
                        </p>

                        <p>The output of oscillator 3 (register 27) is directly related to the waveform selected. If you
                            choose the sawtooth waveform of oscillator 3, this register will present a series of numbers
                            incremented (increased step by step) from
                            0 to 255 at a rate determined by the frequency of oscillator 3. If you choose the triangle
                            waveform, the output will incre- ment from 0 up to 255, then decrement (decrease step by
                            step) back down to 0. If you choose the pulse
                            wave, the output will jump back-and-forth between 0 and 255. Finally, choosing the noise
                            waveform will give you a series of random numbers. When oscillator 3 is used for modulation,
                            you usually do NOT want to hear its output.
                            Setting bit 7 of register 24 turns the audio output of voice 3 off. Register 27 always
                            reflects the changing output of the oscillator and is not affected in any way by the
                            envelope (ADSR) generator.</p>

                        <p>Register 25 gives you access to the output of the envelope generator of oscillator 3. It
                            functions in much the same fashion that the output of oscillator 3 does. The oscillator must
                            be turned on to produce any output from this
                            register.</p>

                        <p>Vibrato (a rapid variation in frequency) can be achieved by adding the output of oscillator 3
                            to the frequency of another oscillator. Example Program 6 illustrates this idea.</p>

                        <p class="example">Example Program 6:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE203.PRG
                                <br>10 S=54272
                                <br>20 FORL=0TO24:POKES+L,0:NEXT
                                <br>30 POKES+3,8
                                <br>40 POKES+5,41:POKES+6,89
                                <br>50 POKES+14,117
                                <br>60 POKES+18,16
                                <br>70 POKES+24,143
                                <br>80 READFR,DR
                                <br>90 IFFR=0THENEND
                                <br>100 POKES+4,65
                                <br>110 FORT=1TODR*2
                                <br>120 FQ=FR+PEEK(S+27)/2
                                <br>130 HF=INT(FQ/256):LF=LQAND255
                                <br>140 POKES+0,LF:POKES+1,HF
                                <br>150 NEXT
                                <br>160 POKES+4,64
                                <br>170 GOTO80
                                <br>500 DATA4817,2,5103,2,5407,2
                                <br>510 DATA8583,4,5407,2,8583,4
                                <br>520 DATA5407,4,8583,12,9634,2
                                <br>530 DATA10207,2,10814,2,8583,2
                                <br>540 DATA9634,4,10814,2,8583,2
                                <br>550 DATA8583,12
                                <br>560 DATA0,0
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p class="example">Line-by-line Explanation of Example Program 6:</p>

                        <table>
                            <tr>
                                <th>Line(s)</th>
                                <th>Description</th>
                            </tr>
                            <tr>
                                <td>10</td>
                                <td>Set S to beginning of sound chip.</td>
                            </tr>
                            <tr>
                                <td>20</td>
                                <td>Clear all sound chip locations.</td>
                            </tr>
                            <tr>
                                <td>30</td>
                                <td>Set high pulse width for voice 1.</td>
                            </tr>
                            <tr>
                                <td>40</td>
                                <td>Set Attack/Decay for voice 1 (A=2, D=9).
                                    <br>Set Sustain/Release for voice 1 (S=5, R=9).
                                </td>
                            </tr>
                            <tr>
                                <td>50</td>
                                <td>Set low frequency for voice 3.</td>
                            </tr>
                            <tr>
                                <td>60</td>
                                <td>Set triangle waveform for voice 3.</td>
                            </tr>
                            <tr>
                                <td>70</td>
                                <td>Set volume 15, turn off audio output of voice 3.</td>
                            </tr>
                            <tr>
                                <td>80</td>
                                <td>Read frequency and duration of note.</td>
                            </tr>
                            <tr>
                                <td>90</td>
                                <td>If frequency equals zero, stop.</td>
                            </tr>
                            <tr>
                                <td>100</td>
                                <td>POKE start pulse waveform control voice 1.</td>
                            </tr>
                            <tr>
                                <td>110</td>
                                <td>Start timing loop for duration.</td>
                            </tr>
                            <tr>
                                <td>120</td>
                                <td>Get new frequency using oscillator 3 output.</td>
                            </tr>
                            <tr>
                                <td>130</td>
                                <td>Get high and low frequency.</td>
                            </tr>
                            <tr>
                                <td>140</td>
                                <td>POKE high and low frequency for voice 1.</td>
                            </tr>
                            <tr>
                                <td>150</td>
                                <td>End of timing loop.</td>
                            </tr>
                            <tr>
                                <td>160</td>
                                <td>POKE stop pulse waveform control voice 1.</td>
                            </tr>
                            <tr>
                                <td>170</td>
                                <td>Go back for next note.</td>
                            </tr>
                            <tr>
                                <td>500-550</td>
                                <td>Frequencies and durations for song.</td>
                            </tr>
                            <tr>
                                <td>560</td>
                                <td>Zeros signal end of song.</td>
                            </tr>
                        </table>

                        <p> A wide variety of sound effects can also be achieved using dynamic effects. For example, the
                            following siren program dynamically changes the frequency output of oscillator 1 when it's
                            based on the output of oscillator 3's triangular
                            wave:</p>

                        <p class="example">Example Program 7:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE205.PRG
                                <br>10 S=54272
                                <br>20 FORL=0TO24:POKES+L,0:NEXT
                                <br>30 POKES+14,5
                                <br>40 POKES+18,16
                                <br>50 POKES+3,1
                                <br>60 POKES+24,143
                                <br>70 POKES+6,240
                                <br>80 POKES+4,65
                                <br>90 FR=5389
                                <br>100 FORT=1TO200
                                <br>110 FQ=FR+PEEK(S+27)*3.5
                                <br>120 HF=INT(FQ/256):LF=FQ-HF*256
                                <br>130 POKES+0,LF:POKES+1,HF
                                <br>140 NEXT
                                <br>150 POKES+24,0
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p class="example">Line-by-line Explanation of Example Program 7:</p>

                        <table>
                            <tr>
                                <th>Line(s)</th>
                                <th>Description</th>
                            </tr>
                            <tr>
                                <td>10</td>
                                <td>Set S to start of sound chip.</td>
                            </tr>
                            <tr>
                                <td>20</td>
                                <td>Clear sound chip registers.</td>
                            </tr>
                            <tr>
                                <td>30</td>
                                <td>Set low frequency of voice 3.</td>
                            </tr>
                            <tr>
                                <td>40</td>
                                <td>Set triangular waveform voice 3.</td>
                            </tr>
                            <tr>
                                <td>50</td>
                                <td>Set high pulse width for voice 1.</td>
                            </tr>
                            <tr>
                                <td>60</td>
                                <td>Set volume 15, turn off audio output of voice 3.</td>
                            </tr>
                            <tr>
                                <td>70</td>
                                <td>Set Sustain/Release for voice 1 (S=15, R=0).</td>
                            </tr>
                            <tr>
                                <td>80</td>
                                <td>POKE start pulse waveform control voice 1.</td>
                            </tr>
                            <tr>
                                <td>90</td>
                                <td>Set lowest frequency for siren.</td>
                            </tr>
                            <tr>
                                <td>100</td>
                                <td>Begin timing loop.</td>
                            </tr>
                            <tr>
                                <td>110</td>
                                <td>Get new frequency using output of oscillator 3.</td>
                            </tr>
                            <tr>
                                <td>120</td>
                                <td>Get high and low frequencies.</td>
                            </tr>
                            <tr>
                                <td>130</td>
                                <td>POKE high and low frequencies for voice 1.</td>
                            </tr>
                            <tr>
                                <td>140</td>
                                <td>End timing loop.</td>
                            </tr>
                            <tr>
                                <td>140</td>
                                <td>Turn off volume.</td>
                            </tr>
                        </table>

                        <p>The noise waveform can be used to provide a wide range of sound effects. THis example mimics
                            a hand clap using a filtered noise waveform:</p>

                        <p class="example">Example Program 8:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE206.PRG
                                <br>10 S=54272
                                <br>20 FORL=0TO24:POKES+L,0:NEXT
                                <br>30 POKES+0,240:POKES+1,33
                                <br>40 POKES+5,8
                                <br>50 POKES+22,104
                                <br>60 POKES+23,1
                                <br>70 POKES+24,79
                                <br>80 FORN=1TO15
                                <br>90 POKES+4,129
                                <br>100 FORT=1TO250:NEXT:POKES+4,128
                                <br>110 FORT=1TO30:NEXT:NEXT
                                <br>120 POKES+24,0
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p class="example">Line-by-line Explanation of Example Program 8:</p>

                        <table>
                            <tr>
                                <th>Line(s)</th>
                                <th>Description</th>
                            </tr>
                            <tr>
                                <td>10</td>
                                <td>Set S to start of sound chip.</td>
                            </tr>
                            <tr>
                                <td>20</td>
                                <td>Clear all sound chip registers.</td>
                            </tr>
                            <tr>
                                <td>30</td>
                                <td>Set high and low frequencies for voice 1.</td>
                            </tr>
                            <tr>
                                <td>40</td>
                                <td>Set Attack/Decay for voice 1 (A=0, D=8)</td>
                            </tr>
                            <tr>
                                <td>50</td>
                                <td>Set high cuttof frequency for filter.</td>
                            </tr>
                            <tr>
                                <td>60</td>
                                <td>Turn on filter for voice 1.</td>
                            </tr>
                            <tr>
                                <td>70</td>
                                <td>Set volume 15, high pass filter.</td>
                            </tr>
                            <tr>
                                <td>80</td>
                                <td>Count 15 claps.</td>
                            </tr>
                            <tr>
                                <td>90</td>
                                <td>Set start noise waveform control.</td>
                            </tr>
                            <tr>
                                <td>100</td>
                                <td>Wait, then set stop noise waveform control.</td>
                            </tr>
                            <tr>
                                <td>110</td>
                                <td>Wait, then start next clap.</td>
                            </tr>
                            <tr>
                                <td>120</td>
                                <td>Turn off volume.</td>
                            </tr>
                        </table>

                    </section>

                    <section class="main-section" id="Synchronization_and_Ring_Modulation">

                        <h4>Synchronization and Ring Modulation</h4>

                        <p>The 6581 SID chip lets you create more complex harmonic structures through synchronization or
                            ring modulation of two voices.</p>

                        <p>The process of synchronization is basically a logical ANDing of two wave forms. When either
                            is zero, the output is zero. The following example uses this process to create an imitation
                            of a mosquito:</p>

                        <p class="example">Example Program 9:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE207.PRG
                                <br>10 S=54272
                                <br>20 FORL=0TO24:POKES+L,0:NEXT
                                <br>30 POKES+1,100
                                <br>40 POKES+5,219
                                <br>50 POKES+15,28
                                <br>60 POKES+24,15
                                <br>70 POKES+4,19
                                <br>80 FORT=1TO5000:NEXT
                                <br>90 POKES+4,18
                                <br>100 FORT=1TO1000:NEXT:POKES+24,0
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p class="example">Line-by-line Explanation of Example Program 9:</p>

                        <table>
                            <tr>
                                <th>Line(s)</th>
                                <th>Description</th>
                            </tr>
                            <tr>
                                <td>10</td>
                                <td>Set S to start of sound chip.</td>
                            </tr>
                            <tr>
                                <td>20</td>
                                <td>Clear sound chip registers.</td>
                            </tr>
                            <tr>
                                <td>30</td>
                                <td>Set high frequency voice 1.</td>
                            </tr>
                            <tr>
                                <td>40</td>
                                <td>Set Attack/Decay for voice 1 (A=13, D=11).</td>
                            </tr>
                            <tr>
                                <td>50</td>
                                <td>Set high frequency voice 3.</td>
                            </tr>
                            <tr>
                                <td>60</td>
                                <td>Set volume 15.</td>
                            </tr>
                            <tr>
                                <td>70</td>
                                <td>Set start triangle, sync waveform control for voice 1.</td>
                            </tr>
                            <tr>
                                <td>80</td>
                                <td>Timing loop.</td>
                            </tr>
                            <tr>
                                <td>90</td>
                                <td>Set stop triangle, sync waveform control for voice 1.</td>
                            </tr>
                            <tr>
                                <td>100</td>
                                <td>Wait, then turn off volume.</td>
                            </tr>
                        </table>

                        <p>The synchronization feature is enabled (turned on) in line 70, where bits 0, 1, and 4 of
                            register 4 are set. Bit 1 enables the syncing function between voice 1 and voice 3. Bits 0
                            and 4 have their usual functions of gating voice
                            1 and setting the triangular waveform.</p>

                        <p>Ring modulation (accomplished for voice 1 by setting bit 3 of register 4 in line 70 of the
                            program below) replaces the triangular output of oscillator I with a "ring modulated"
                            combination of oscillators 1 and 3. This produces
                            non-harmonic overtone structures for use in mimicking bell or gong sounds. This program
                            produces a clock chime imitation:</p>

                        <p class="example">Example Program 10:</p>

                        <blockquote>
                            <code>
                                START TOK64 PAGE208.PRG
                                <br>10 S=54272
                                <br>20 FORL=0TO24:POKES+L,0:NEXT
                                <br>30 POKES+1,130
                                <br>40 POKES+5,9
                                <br>50 POKES+15,30
                                <br>60 POKES+24,15
                                <br>70 FORL=1TO12:POKES+4,21
                                <br>80 FORT=1TO1000:NEXT:POKES+4,20
                                <br>90 FORT=1TO1000:NEXT:NEXT
                                <br>STOP TOK64
                            </code>
                        </blockquote>

                        <p class="example">Line-by-line Explanation of Example Program 10:</p>

                        <table>
                            <tr>
                                <th>Line(s)</th>
                                <th>Description</th>
                            </tr>
                            <tr>
                                <td>10</td>
                                <td>Set S to start of sound chip.</td>
                            </tr>
                            <tr>
                                <td>20</td>
                                <td>Clear sound chip registers.</td>
                            </tr>
                            <tr>
                                <td>30</td>
                                <td>Set high frequency for voice 1.</td>
                            </tr>
                            <tr>
                                <td>40</td>
                                <td>Set Attack/Decay for voice 1.</td>
                            </tr>
                            <tr>
                                <td>50</td>
                                <td>Set high frequency for voice 3.</td>
                            </tr>
                            <tr>
                                <td>60</td>
                                <td>Set volume 15.</td>
                            </tr>
                            <tr>
                                <td>70</td>
                                <td>Count number of clings, set start triangle, ring mod waveform control voice 1.</td>
                            </tr>
                            <tr>
                                <td>80</td>
                                <td>Timing loop, set stop triangle, ring mod.</td>
                            </tr>
                            <tr>
                                <td>90</td>
                                <td>TIming loop, next ding.</td>
                            </tr>
                        </table>

                        <p>The effects available through the use of the parameters of your Commodore 64's SID chip are
                            numerous and varied. Only through experimentation on your own will you fully appreciate the
                            capabilities of your machine. The examples
                            in this section of the Programmer's Reference Guide merely scratch the surface.</p>

                        <p>Watch for the book MAKING MUSIC ON YOUR COMMODORE COMPUTER for everything from simple fun and
                            games to professional-type musical instruction.
                        </p>
                    </section>

                    <h3>Basic to Machine Language</h3>

                    <section class="main-section" id="Machine_Language">

                        <h4>What is Machine Language?</h4>

                        <p>At the heart of every microcomputer, is a central microprocessor. It's a very special
                            microchip which is the "brain" of the computer. The Commodore 64 is no exception. Every
                            microprocessor understands its own language of instructions.
                            These instructions are called machine language instructions. To put it more precisely,
                            machine language is the ONLY programming language that your Commodore 64 understands. It is
                            the NATIVE language of the machine.
                        </p>

                        <p>If machine language is the only language that the Commodore 64 understands, then how does it
                            understand the CBM BASIC programming language? CBM BASIC is NOT the machine language of the
                            Commodore 64. What, then, makes the Commodore
                            64 understand CBM BASIC instructions like PRINT and GOTO?</p>

                        <p>To answer this question, you must first see what happens inside your Commodore 64. Apart from
                            the microprocessor which is the brain of the Commodore 64, there is a machine language
                            program which is stored in a special type of memory
                            so that it can't be changed. And, more importantly, it does not disappear when the Commodore
                            64 is turned off, unlike a program that you may have written. This machine language program
                            is called the OPERATING SYSTEM of the
                            Commodore 64. Your Commodore 64 knows what to do when it's turned on because its OPERATING
                            SYSTEM (program) is automatically "RUN."</p>

                        <p>The OPERATING SYSTEM is in charge of "organizing" all the memory in your machine for various
                            tasks. It also looks at what characters you type on the keyboard and puts them onto the
                            screen, plus a whole number of other functions.
                            The OPERATING SYSTEM can be thought of as the "intelligence and personality" of the
                            Commodore 64 (or any computer for that matter). So when you turn on your Commodore 64, the
                            OPERATING SYSTEM takes control of your machine,
                            and after it has done its housework, it then says:</p>

                        <blockquote>
                            <code>READY.</code>
                        </blockquote>

                        <p>The OPERATING SYSTEM of the Commodore 64 then allows you to type on the keyboard, and use the
                            built-in SCREEN EDITOR on the Commodore 64. The SCREEN EDITOR allows you to move the cursor,
                            DELete, INSert, etc., and is, in fact, only
                            one part of the operating system that is built in for your convenience.</p>

                        <p>All of the commands that are available in CBM BASIC are simply recognized by another huge
                            machine language program built into your Commodore 64. This huge program "RUNS" the
                            appropriate piece of machine language depending on which
                            CBM BASIC command is being executed. This program is called the BASIC INTERPRETER, because
                            it interprets each command, one by one, unless it encounters a command it does not
                            understand, and then the familiar message appears:</p>

                        <blockquote>
                            <code>
                                ?SYNTAX ERROR
                                <br>
                                <br>READY.
                            </code>
                        </blockquote>

                        <h5>What Does Machine Code Look Like?</h5>

                        <p>You should be familiar with the PEEK and POKE commands in the CBM BASIC language for changing
                            memory locations. You've probably used them for graphics on the screen, and for sound
                            effects. Each memory location has its own number
                            which identifies it. This number is known as the "address" of a memory location. If you
                            imagine the memory in the Commodore 64 as a street of buildings, then the number on each
                            door is, of course, the address. Now let's look
                            at which parts of the street are used for what purposes.
                        </p>

                        <p class="example">Simple Memory Map of the Commodore 64</p>

                        <table>
                            <tr>
                                <th>Address</th>
                                <th>Description</th>
                            </tr>
                            <tr>
                                <td>0 & 1</td>
                                <td>6510 Registers</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>Start of memory</td>
                            </tr>
                            <tr>
                                <td>2-1023</td>
                                <td>Memory used by the operating system</td>
                            </tr>
                            <tr>
                                <td>1024-2039</td>
                                <td>Screen memory</td>
                            </tr>
                            <tr>
                                <td>2040-2047</td>
                                <td>SPRITE pointers</td>
                            </tr>
                            <tr>
                                <td>2048-40959</td>
                                <td>This is YOUR memory. This is where your BASIC or machine language programs, or both,
                                    are stored.</td>
                            </tr>
                            <tr>
                                <td>40960-49151</td>
                                <td>8K CBM BASIC Interpreter</td>
                            </tr>
                            <tr>
                                <td>49152-53247</td>
                                <td>Special programs RAM area</td>
                            </tr>
                            <tr>
                                <td>53248-53294</td>
                                <td>VIC-II Registers</td>
                            </tr>
                            <tr>
                                <td>54272-55295</td>
                                <td>SID Registers</td>
                            </tr>
                            <tr>
                                <td>55296-56296</td>
                                <td>Color RAM</td>
                            </tr>
                            <tr>
                                <td>56320-57343</td>
                                <td>I/O Registers</td>
                            </tr>
                            <tr>
                                <td>57344-65535</td>
                                <td>8K CBM KERNAL Operating System</td>
                            </tr>
                        </table>

                        <p>If you don't understand what the description of each part of memory means right now, this
                            will become clear from other parts of this manual.</p>

                        <p>Machine language programs consist of instructions which may or may not have operands
                            (parameters) associated with them. Each instruction takes up one memory location, and any
                            operand is contained in one or two locations following
                            the instruction.</p>

                        <p>In your BASIC programs, words like PRINT and GOTO do, in fact, only take up one memory
                            location, rather than one for each character of the word. The contents of the location that
                            represents a particular BASIC keyword is called
                            a token. In machine language, there are different tokens for different instructions, which
                            also take up just one byte (memory location=byte).
                        </p>

                        <p>Machine language instructions are very simple. Therefore, each individual instruction cannot
                            achieve a great deal. Machine language instructions either change the contents of a memory
                            location, or change one of the internal registers
                            (special storage locations) inside the microprocessor. The internal registers form the very
                            basis of machine language.</p>

                        <h4>The Registers Inside the 6510 Microprocessor</h4>

                        <h5>The Accumulator</h5>

                        <p>This is THE most important register in the microprocessor. Various machine language
                            instructions allow you to copy the contents of a memory location into the accumulator, copy
                            the contents of the accumulator into a memory location,
                            modify the contents of the accumulator or some other register directly, without affecting
                            any memory. And the accumulator is the only register that has instructions for performing
                            math.</p>

                        <h5>The X Index Register</h5>

                        <p>This is a very important register. There are instructions for nearly all of the
                            transformations you can make to the accumulator. But there are other instructions for things
                            that only the X register can do. Various machine language
                            instructions allow you to copy the contents of a memory location into the X register, copy
                            the contents of the X register into a memory location, and modify the contents of the X, or
                            some other register directly.
                        </p>

                        <h5>The Y Index Register</h5>

                        <p>This is a very important register. There are instructions for nearly all of the
                            transformations you can make to the accumulator, and the X register. But there are other
                            instructions for things that only the Y register can do. Various
                            machine language instructions allow you to copy the contents of a memory location into the Y
                            register, copy the contents of the Y register into a memory location, and modify the
                            contents of the Y, or some other register directly.</p>

                        <h5>The Status Register</h5>

                        <p>This register consists of eight "flags" (a flag = something that indicates whether something
                            has, or has not occurred).</p>

                        <h5>The Program Counter</h5>

                        <p>This contains the address of the current machine language instruction being executed. Since
                            the operating system is always "RUN"ning in the Commodore 64 (or, for that matter, any
                            computer), the program counter is always changing.
                            It could only be stopped by halting the microprocessor in some way.</p>

                        <h5>The Stack Pointer</h5>

                        <p>This register contains the location of the first empty place on the stack. The stack is used
                            for temporary storage by machine language programs, and by the computer.</p>

                        <h5>The Input/Output Port</h5>

                        <p>This register appears at memory locations 0 (for the DATA DIRECTION REGISTER) and 1 (for the
                            actual PORT). It is an 8-bit input/output port. On the Commodore 64 this register is used
                            for memory management, to allow the chip to control more than 64K of RAM and ROM memory.</p>

                        <p>The details of these registers are not given here. They are explained as the principles
                            needed to explain them are explained.</p>
                    </section>

                    <section class="Main Section" id="Programming_in_Machine_Language">

                        <h4>How Do You Write Machine Language Programs?</h4>

                        <p>Since machine language programs reside in memory, and there is no facility in your Commodore
                            64 for writing and editing machine language programs, you must use either a program to do
                            this,
                            or write for yourself a BASIC program that "allows" you to write machine language.</p>

                        <p>The most common methods used to write machine language programs are assembler programs. These
                            packages allow you to write machine language instructions in a standardized mnemonic format,
                            which makes the machine language program a lot
                            more readable than a stream of numbers! Let's review: A program that allows you to write
                            machine
                            language programs in mnemonic format is called an assembler. Incidentally, a program that
                            displays a machine language program in mnemonic
                            format is called a disassembler. Available for your Commodore 64 is a machine language
                            monitor
                            cartridge (with assembler/disassembler, etc.) made by Commodore:</p>

                        <h5>64MON</h5>

                        <p>The 64MON cartridge available from your local dealer, is a program that allows you to escape
                            from the world of CBM BASIC, into the land of machine language. It can display the contents
                            of
                            the internal registers in the 6510 microprocessor,
                            and it allows you to display portions of memory, and change them on the screen, using the
                            screen editor. It also has a built-in assembler and disassembler, as well as many other
                            features
                            that allow you to write and edit machine language programs easily. You don't HAVE to use an
                            assembler to write machine language, but
                            the task is considerably easier with it. If you wish to write machine language programs, it
                            is
                            strongly suggested that you purchase an assembler of some sort. Without an assembler you
                            will probably have to "POKE" the machine
                            language program into memory, which is totally unadvisable. This manual will give its
                            examples in the format that 64MON uses, from now on. Nearly all assembler formats are the
                            same, therefore the machine language examples shown
                            will almost certainly be compatible with any assembler. But before explaining any of the
                            other
                            features of 64MON, the hexadecimal numbering system must be explained.</p>
                    </section>

                    <section class="main-section" id="Hexadecimal_Notation">

                        <h4>Hexadecimal Notation</h4>

                        <p>Hexadecimal notation is used by most machine language programmers when they talk about a
                            number or address in a machine language program.</p>

                        <p>Some assemblers let you refer to addresses and numbers in decimal (base 10), binary (base 2),
                            or even octal (base 8) as well as hexadecimal (base 16) (or just "hex" as most people say).
                            These assemblers do the conversions for you.</p>

                        <p>Hexadecimal probably seems a little hard to grasp at first, but like most things, it won't
                            take long to master with practice.</p>

                        <p>By looking at decimal (base 10) numbers, you can see that each digit fails somewhere in the
                            range between zero and a number equal to the base less one (e.g., 9). THIS IS TRUE OF ALL
                            NUMBER BASES. Binary (base 2) numbers have digits
                            ranging from zero to one (which is one less than the base). Similarly, hexadecimal numbers
                            should have digits ranging from zero to fifteen, but we do not have any single digit figures
                            for the numbers ten to fifteen, so the
                            first six letters of the alphabet are used instead:
                        </p>

                        <table>
                            <tr>
                                <th>Decimal</th>
                                <th>Hexadecimal</th>
                                <th>Binary</th>
                            </tr>
                            <tr>
                                <td>0</td>
                                <td>0</td>
                                <td>00000000</td>
                            </tr>
                            <tr>
                                <td>1</td>
                                <td>1</td>
                                <td>00000001</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>2</td>
                                <td>00000010</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>3</td>
                                <td>00000011</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>4</td>
                                <td>00000100</td>
                            </tr>
                            <tr>
                                <td>5</td>
                                <td>5</td>
                                <td>00000101</td>
                            </tr>
                            <tr>
                                <td>6</td>
                                <td>6</td>
                                <td>00000110</td>
                            </tr>
                            <tr>
                                <td>7</td>
                                <td>7</td>
                                <td>00000111</td>
                            </tr>
                            <tr>
                                <td>8</td>
                                <td>8</td>
                                <td>00001000</td>
                            </tr>
                            <tr>
                                <td>9</td>
                                <td>9</td>
                                <td>00001001</td>
                            </tr>
                            <tr>
                                <td>10</td>
                                <td>A</td>
                                <td>00001010</td>
                            </tr>
                            <tr>
                                <td>11</td>
                                <td>B</td>
                                <td>00001011</td>
                            </tr>
                            <tr>
                                <td>12</td>
                                <td>C</td>
                                <td>00001100</td>
                            </tr>
                            <tr>
                                <td>13</td>
                                <td>D</td>
                                <td>00001101</td>
                            </tr>
                            <tr>
                                <td>14</td>
                                <td>E</td>
                                <td>00001110</td>
                            </tr>
                            <tr>
                                <td>15</td>
                                <td>F</td>
                                <td>00001111</td>
                            </tr>
                            <tr>
                                <td>16</td>
                                <td>10</td>
                                <td>00010000</td>
                            </tr>
                        </table>

                        <p>Let's look at it another way; here's an example of how a base 10 (decimal number) is
                            constructed:
                        </p>

                        <pre>
Base raised by        10<sup>3</sup>    10<sup>2</sup>  10<sup>1</sup>  10<sup>0</sup>
increasing powers:   --------------------
                     1000   100   10   1

Consider 4569(base 10): 4569 = (4*1000)+(5*100)+(6*10)+9
                        </pre>

                        <p>Now look at an example of how a base 16 (hexadecimal number) is constructed:</p>

                        <pre>
Base raised by        16<sup>3</sup>    16<sup>2</sup>  16<sup>1</sup>  16<sup>0</sup>
increasing powers:   --------------------
                     4096   256   16   1

Consider 11D9(base 10): 11D9 = (1*4096)+(1*256)+(13*16)+9
                        </pre>

                        <p>Therefore, 4569 (base 10) = 11D9 (base 16)</p>

                        <p>The range for addressable memory locations is 0-65535 (as was stated earlier). This range is
                            therefore 0-FFFF in hexadecimal notation.</p>

                        <p>Usually hexadecimal numbers are prefixed with a dollar sign ($). This is to distinguish them
                            from decimal numbers. Let's look at some "hex" numbers, using 64MON, by displaying the
                            contents of some memory by typing:
                        </p>

                        <pre>
    SYS 8*4096            (or SYS 12*4096)
    B*
       PC  SR AC XR YR SP
    .;0401 32 04 5E 00 F6 (these may be different)    
                        </pre>

                        <p>Then if you type in:</p>

                        <blockquote>
                            <code>
                                .M 0000 0020 (and press &lt;RETURN&gt;)
                            </code>
                        </blockquote>

                        <p>you will see rows of 6 hex numbers. The first 4-digit number is the address of the first byte
                            of memory being shown in that row, and the other eight numbers are the actual contents of
                            the memory locations beginning at that start
                            address.</p>

                        <p>You should really try to learn to "think" in hexadecimal. It's not too difficult, because you
                            don't have to think about converting it back into decimal. For example, if you said that a
                            particular value is stored at $14ED instead
                            of 5357, it shouldn't make any difference.</p>

                        <h5>Your First Machine Language Instruction</h5>

                        <h5>LDA - Load the Accumulator</h5>

                        <p> In 6510 assembly language, mnemonics are always three characters. LDA represents "load
                            accumulator with...", and what the accumulator should be loaded with is decided by the
                            parameter(s) associated with that instruction. The assembler
                            knows which token is represented by each mnemonic, and when it "assembles" an instruction,
                            it simply puts into memory (at whatever address has been specified), the token, and what
                            parameters, are given. Some assemblers give
                            error messages, or warnings when you try to assemble something that either the assembler, or
                            the 6510 microprocessor, cannot do.</p>

                        <p>If you put a "#" symbol in front of the parameter associated with the instruction, this means
                            that you want the register specified in the instruction to be loaded with the "value" after
                            the "#". For example:</p>

                        <blockquote>
                            <code>LDA #$05 &lt;----[ $=HEX ]</code>
                        </blockquote>

                        <p>This instruction will put $05 (decimal
                            5) into the accumulator register. The assembler will put into the specified address
                            for this instruction, $A9 (which is the token for this particular instruction, in
                            this mode), and it will put $05 into the next location after the location containing the
                            instruction ($A9).
                        </p>

                        <p>If the parameter to be used by an instruction has "#" before it; i.e., the
                            parameter is a "value," rather than the contents of a memory location, or
                            another register, the instruction is said to be in the "immediate" mode. To put
                            this into perspective, let's compare this with another mode:</p>

                        <p>The assembler can distinguish between the two different modes because the latter
                            does not have a "#" before the parameter. The 6510 microprocessor can
                            distinguish between the immediate mode, and the absolute mode of the LDA
                            instruction, because they have slightly different tokens. LDA (immediate) has $A9 as its
                            token, and LDA (absolute), has $AD as its token.</p>

                        <p>The mnemonic representing an instruction usually implies what it does. For
                            instance, if we consider another instruction, LDX, what do you think this does?
                        </p>

                        <p>If you said "load the X register with...", go to the top of the class. If you
                            didn't, then don't worry, learning machine language does take patience, and
                            cannot be learned in a day.</p>

                        <p>The various internal registers can be thought of as special memory locations,
                            because they too can hold one byte of information. It is not necessary for us to
                            explain the binary numbering system (base 2) since it follows the same
                            rules as outlined for hexadecimal and decimal outlined previously, but one "bit"
                            is one binary digit and eight bits make up one byte! This means that the maximum
                            number that can be contained in a byte is the largest number
                            that an eight digit binary number can be. This number is 11111111 (binary),
                            which equals $FF (hexadecimal), which equals 255 (decimal). You have probably
                            wondered why only numbers from zero to 255 could be put into a memory
                            location. If you try POKE 7680,260 (which is a BASIC statement that "says": "Put
                            the number two hundred and sixty, into memory location seven thousand, six
                            hundred and eighty", the BASIC interpreter knows that only numbers
                            0 - 255 can be put in a memory location, and your Commodore 64 will reply with:
                        </p>

                        <blockquote>
                            <code>
                                ?ILLEGAL QUANTITY ERROR
                                <br>
                                <br>READY.
                            </code>
                        </blockquote>

                        <p>If the limit of one byte is $FF (hex), how is the address parameter in the
                            absolute instruction "LDA $102E" expressed in memory? It's expressed in two
                            bytes (it won't fit into one, of course). The lower (rightmost) two digits of
                            the hexadecimal address form the "low byte" of the address, and the upper
                            (leftmost) two digits form the "high byte."</p>

                        <p>The 6510 requires any address to be specified with its low byte first, and then
                            the high byte. This means that the instruction "LDA $102E" is represented in
                            memory by the three consecutive values:</p>

                        <blockquote>
                            <code>$AD, $2E, $10</code>
                        </blockquote>

                        <p>Now all you need to know is one more instruction and then you can write your
                            first program. That instruction is BRK. For a full explanation of this
                            instruction, refer to M.O.S. 6502 Programming Manual. But right now, you can
                            think
                            of it as the END instruction in machine language.</p>

                        <p>If we write a program with 64MON and put the BRK instruction at the end, then
                            when the program is executed, it will return to 64MON when it is finished. This
                            might not happen if there is a mistake in your program, or the BRK instruction
                            is never reached (just like an END statement in BASIC may never get executed).
                            This means that if the Commodore 64 didn't have a STOP key, you wouldn't be able
                            to abort your BASIC programs!</p>

                        <h5>Writing Your First Program</h5>

                        <p>If you've used the POKE statement in BASIC to put characters onto the screen,
                            you're aware that the character codes for POKEing are different from CBM ASCII
                            character values. For example, if you enter:</p>

                        <blockquote>
                            <code>PRINT ASC("A") (and press &lt;RETURN&gt; )</code>
                        </blockquote>

                        <p>the Commodore 64 will respond with:</p>

                        <blockquote>
                            <code>
                                65
                                <br>
                                <br>READY.
                            </code>
                        </blockquote>

                        <p>However, to put an "A" onto the screen by POKEing, the code is 1, enter:</p>

                        <blockquote>
                            <code>
                                &lt;SHIFT+CLR/HOME&gt; to clear the screen
                                <br>
                                <br>POKE 1024,1:POKE 55296,14 (and &lt;RETURN&gt; (1024 is the start of
                                screen memory)
                            </code>
                        </blockquote>

                        <p>The "P" in the POKE statement should now be an "A."</p>

                        <p>Now let's try this in machine language. Type the following in 64MON: (Your cursor
                            should be flashing alongside a "." right now.)</p>

                        <blockquote>
                            <code>.A 1400 LDA#$01 (and press &lt;RETURN&gt;)</code>
                        </blockquote>

                        <p>The Commodore 64 will prompt you with:</p>

                        <blockquote>
                            <code>
                                .A 1400 A9 01 LDA #$01
                                <br>.A 1402
                            </code>
                        </blockquote>

                        <p>Type:</p>

                        <blockquote>
                            <code>
                                .A 1402 STA $0400
                                <br>
                                <br>(The STA instruction stores the contents of the accumulator in a
                                specified memory location.)
                            </code>
                        </blockquote>

                        <p>Now type in:</p>

                        <blockquote>
                            <code>
                                .A 1405 LDA #$0E
                                <br>.A 1407 STA $D800
                                <br>.A 140A BRK
                            </code>
                        </blockquote>

                        <p>Clear the screen, and type:</p>

                        <blockquote>
                            <code>G 1400</code>
                        </blockquote>

                        <p>The G should turn into an "A" if you've done everything correctly. You have now
                            written your first machine language program. Its purpose is to store one
                            character ("A") at the first location in the screen memory. Having achieved
                            this, we must now explore some of the other instructions, and principles.</p>
                    </section>

                    <section class="main-section" id="Addressing_Modes">

                        <h4>Addressing Modes</h4>

                        <h5>Zero Page</h5>

                        <p>As shown earlier, absolute addresses are expressed in terms of a high and a low order byte.
                            The high order byte is often referred to as the page of memory. For example, the address
                            $1637 is in page $16 (22), and $0277 is in page
                            $02 (2). There is, however, a special mode of addressing known as zero page addressing and
                            is, as the name implies, associated with the addressing of memory locations in page zero.
                            These addresses, therefore, ALWAYS have a
                            high order byte of zero. The zero page mode of addressing only expects one byte to describe
                            the address, rather than two when using an absolute address. The zero page addressing mode
                            tells the microprocessor to assume that
                            the high order address is zero. Therefore zero page addressing can reference memory
                            locations whose addresses are between $0000 and $00FF. This may not seem too important at
                            the moment, but you'll need the principles of zero
                            page addressing soon.</p>

                        <h5>The Stack</h5>

                        <p>The 6510 microprocessor has what is known as a stack. This is used by both the programmer and
                            the microprocessor to temporarily remember things, and to remember, for example, an order of
                            events. The GOSUB statement in BASIC, which
                            allows the programmer to call a subroutine, must remember where it is being called from, so
                            that when the RETURN statement is executed in the subroutine, the BASIC interpreter "knows"
                            where to go back to continue executing.
                            When a GOSUB statement is encountered in a program by the BASIC interpreter, the BASIC
                            interpreter "pushes" its current position onto the stack before going to do the subroutine,
                            and when a RETURN is executed, the interpreter
                            "pulls" off the stack the information that tells it where it was before the subroutine call
                            was made. The interpreter uses instructions like PHA, which pushes the contents of the
                            accumulator onto the stack, and PLA (the reverse)
                            which pulls a value off the stack and into the accumulator. The status register can also be
                            pushed and pulled with the PHP and PLP, respectively.
                        </p>

                        <p>The stack is 256 bytes long, and is located in page one of memory. It is therefore from $01
                            00 to $01 FF. It is organized backwards in memory. In other words, the first position in the
                            stack is at $01 FF, and the last is at $0100.
                            Another register in the 651 0 microprocessor is called the stack pointer, and it always
                            points to the next available location in the stack. When something is pushed onto the stack,
                            it is placed where the stack pointer points
                            to, and the stack pointer is moved down to the next position (decremented). When something
                            is pulled off the stack, the stack pointer is incremented, and the byte pointed to by the
                            stack pointer is placed into the specified
                            register.</p>

                        <p>Up to this point, we have covered immediate, zero page, and absolute mode instructions. We
                            have also covered, but have not really talked about, the "implied" mode. The implied mode
                            means that information is implied by an instruction
                            itself. In other words, what registers, flags, and memory the instruction is referring to.
                            The examples we have seen are PHA, PLA, PHP, and PLP, which refer to stack processing and
                            the accumulator and status registers, respectively.
                        </p>

                        <p>
                            <strong>NOTE:</strong> The X register will be referred to as X from now on, and similarly A
                            (accumulator), Y (Y index register), S (stack pointer), and P (processor status).</p>
                    </section>

                    <section class="main-section" id="Indexing">

                        <h4>Indexing</h4>

                        <p>Indexing plays an extremely important part in the running of the 6510 microprocessor. It can
                            be defined as "creating an actual address from a base address plus the contents of either
                            the X or Y registers."</p>

                        <p>For example, if X contains $05, and the microprocessor executes an LDA instruction in the
                            "absolute X indexed mode" with base address (e.g., $9000), then the actual location that is
                            loaded into the A register is $9000 + $05 = $9005.
                            The mnemonic format of an absolute indexed instruction is the same as an absolute
                            instruction except a",X" or ",Y" denoting the index is added to the address.

                            <p class="example">Example:</p>

                            <blockquote>
                                <code>LDA $9000,X</code>
                            </blockquote>

                            <p>There are absolute indexed, zero page indexed, indirect indexed, and indexed indirect
                                modes of addressing available on the 6510 microprocessor.</p>

                            <h5>Indirect Indexed</h5>

                            <p>This only allows usage of the Y register as the index. The actual address can only be in
                                zero page, and the mode of instruction is called indirect because the zero page address
                                specified in the instruction contains the low
                                byte of the actual address, and the next byte to it contains the high order byte.</p>

                            <p class="example">Example:</p>

                            <p>Let us suppose that location $02 contains $45, and location $03 contains $1E. If the
                                instruction to load the accumulator in the indirect indexed mode is executed and the
                                specified zero page address is $02, then the actual address
                                will be:</p>

                            <blockquote>
                                <code>
                                    Low order = contents of $02
                                    <br>High order = contents of $03
                                    <br>Y register $00
                                </code>
                            </blockquote>

                            <p>Thus the actual address = $1E45 + Y = $1E45.</p>

                            <p>The title of this mode does in fact imply an indirect principle, although this may be
                                difficult to grasp at first sight. Let's look at it another way:</p>

                            <p>"I am going to deliver this letter to the post office at address $02, MEMORY ST., and the
                                address on the letter is $05 houses past $1600, MEMORY street." This is equivalent to
                                the code:</p>

                            <blockquote>
                                <code>
                                    LDA #$00 - load low order actual base address
                                    <br>STA $02 - set the low byte of the indirect address
                                    <br>LDA #$16 - load high order indirect address
                                    <br>STA $03 - set the high byte of the indirect address
                                    <br>LDY #$05 - set the indirect index (Y)
                                    <br>LDA ($02),Y - load indirectly indexed by Y
                                </code>
                            </blockquote>

                            <h5>Indexed Indirect</h5>

                            <p>Indexed indirect only allows usage of the X register as the index. This is the same as
                                indirect indexed, except it is the zero page address of the pointer that is indexed,
                                rather than the actual base address. Therefore, the
                                actual base address IS the actual address because the index has already been used for
                                the indirect. Index indirect would also be used if a table of indirect pointers were
                                located in zero page memory, and the X register
                                could then specify which indirect pointer to use.</p>

                            <p class="example">Example:</p>

                            <p>Let us suppose that location $02 contains $45, and location $03 contains $10. If the
                                instruction to load the accumulator in the indexed indirect mode is executed and the
                                specified zero page address is $02, then the actual address
                                will be:</p>

                            <blockquote>
                                <code>
                                    Low order = contents of ($02+X)
                                    <br>High order = contents of ($03+X)
                                    <br>X register = $00
                                </code>
                            </blockquote>

                            <p>Thus the actual pointer is in = $02 + X = $02.</p>

                            <p>Therefore, the actual address is the indirect address contained in $02 which is again
                                $1045.</p>

                            <p>The title of this mode does in fact imply the principle, although it may be difficult to
                                grasp at first sight. Look at it this way:</p>

                            <p>"I am going to deliver this letter to the fourth post office at address $01,MEMORY ST.,
                                and the address on the letter will then be delivered to $1600, MEMORY street." This is
                                the equivalent to the code:</p>

                            <blockquote>
                                <code>
                                    LDA #$00 - load low order actual base address
                                    <br>STA $06 - set the low byte of the indirect address
                                    <br>LDA #$16 - load high order indirect address
                                    <br>STA $07 - set the high byte of the indirect address
                                    <br>LDX #$05 - set the indirect index (X)
                                    <br>LDA ($02,X) - load indirectly indexed by X
                                </code>
                            </blockquote>

                            <p>
                                <strong>NOTE:</strong> Of the two indirect methods of addressing, the first (indirect
                                indexed) is far more widely used.</p>

                            <h5>Branches and Testing</h5>

                            <p>Another very important principle in machine language is the ability to test, and detect
                                certain conditions, in a similar fashion to the "IF... THEN, IF... GOTO" structure in
                                CBM BASIC.</p>

                            <p>The various flags in the status register are affected by different instructions in
                                different ways. For example, there is a flag that is set when an instruction has caused
                                a zero result, and is reset when a result is not zero. The instruction:</p>

                            <blockquote>
                                <code>LDA #$00</code>
                            </blockquote>

                            <p>will cause the zero result flag to be set, because the instruction has resulted in the
                                accumulator containing a zero.</p>

                            <p>There are a set of instructions that will, given a particular condition, branch to
                                another part of the program. An example of a branch instruction is BEQ, which means
                                Branch if result EQual to zero. The branch instructions
                                branch if the condition is true, and if not, the program continues onto the next
                                instruction, as if nothing had occurred. The branch instructions branch not by the
                                result of the previous instructions, but by internally
                                examining the status register. As was just mentioned, there is a zero result flag in the
                                status register. The BEQ instruction branches if the zero result flag (known as Z) is
                                set. Every branch instruction has an opposite
                                branch instruction. The BEQ instruction has an opposite instruction BNE, which means
                                Branch on result Not Equal to zero (i.e., Z not set).</p>

                            <p>The index registers have a number of associated instructions which modify their contents.
                                For example, the INX instruction INcrements the X index register. If the X register
                                contained $FF before it was incremented (the maximum
                                number the X register can contain), it will "wrap around" back to zero. If you wanted a
                                program to continue to do something until you had performed the increment of the X index
                                that pushed it around to zero, you could use
                                the BNE instruction to continue "looping" around, until X became zero.</p>

                            <p>The reverse of INX, is DEX, which is DEcrement the X index register. If the X index
                                register is zero, DEX wraps around to $FF. Similarly, there are INY and DEY for the Y
                                index register.</p>

                            <p>But what if a program didn't want to wait until X or Y had reached (or not reached) zero?
                                Well there are comparison instructions, CPX and CPY, which allow the machine language
                                programmer to test the index registers with specific
                                values, or even the contents of memory locations. If you wanted to see if the X register
                                contained $40, you would use the instruction:</p>

                            <blockquote>
                                <pre>
    CPX #$40         - compare X with the "value" $40.
    BEQ              - branch to somewhere else in the
    (some other        program, if this condition is "true."
    part of the
    program) 
                            </pre>
                            </blockquote>

                            <p>The compare and branch instructions play a major part in any machine language program.
                            </p>

                            <p>The operand specified in a branch instruction when using 64MON is the address of the part
                                of the program that the branch goes to when the proper conditions are met. However, the
                                operand is only an offset, which gets you from
                                where the program currently is to the address specified. This offset is just one byte,
                                and therefore the range that a branch instruction can branch to is limited. It can
                                branch from 128 bytes backward, to 127 bytes forward.</p>

                            <p>
                                <strong>NOTE:</strong> This is a total range of 255 bytes which is, of course, the
                                maximum range of values one byte can contain.</p>

                            <p>64MON will tell you if you "branch out of range" by refusing to "assemble" that
                                particular instruction. But don't worry about that now because it's unlikely that you
                                will have such branches for quite a while. The branch is
                                a "quick" instruction by machine language standards because of the "offset" principle as
                                opposed to an absolute address. 64MON allows you to type in an absolute address, and it
                                calculates the correct offset. This is just
                                one of the "comforts" of using an assembler.</p>

                            <p>
                                <strong>NOTE:</strong> It is NOT possible to cover every single branch instruction. For
                                further information, refer to the Bibliography section in Appendix F.</p>
                    </section>

                    <section class="main-section" id="Subroutines">

                        <h4>Subroutines</h4>

                        <p>In machine language (in the same way as using BASIC), you can call subroutines. The
                            instruction to call a subroutine is JSR (Jump to SubRoutine), followed by the specified
                            absolute address.</p>

                        <p>Incorporated in the operating system, there is a machine language subroutine that will PRINT
                            a character to the screen. The CBM ASCII code of the character should be in the accumulator
                            before calling the subroutine. The address
                            of this subroutine is $FFD2.</p>

                        <p>Therefore, to print "Hi" to the screen, the following program should be entered:</p>

                        <blockquote>
                            <pre>
    .A 1400 LDA #$48     - load the CBM ASCII code of "H"
    .A 1402 JSR $FFD2    -  print it
    .A 1405 LDA #$49     - load the CBM ASCII code of "I"
    .A 1407 JSR $FFD2    -  print that too
    .A 140A LDA #$0D     - print a carriage return as well
    .A 140C JSR $FFD2
    .A 140F BRK          - return to 64MON
    .G 1400              - will print "HI" and return to 64MON
                            </pre>
                        </blockquote>

                        <p>The "PRINT a character" routine we have just used is part of the KERNAL jump table. The
                            instruction similar to GOTO in BASIC is JMP, which means JUMP to the specified absolute
                            address. The KERNAL is a long list of "standardized"
                            subroutines that control ALL input and output of the Commodore 64. Each entry in the KERNAL
                            JMPs to a subroutine in the operating system. This "jump table" is found between memory
                            locations $FF84 to $FFF5 in the operating system.
                            A full explanation of the KERNAL is available in the "KERNAL Reference Section" of this
                            manual. However, certain routines are used here to show how easy and effective the KERNAL
                            is.
                        </p>

                        <p>Let's now use the new principles you've just learned in another program. It will help you to
                            put the instructions into context:</p>

                        <p>This program will display the alphabet using a KERNAL routine. The only new instruction
                            introduced here is TXA Transfer the contents of the X index register, into the Accumulator.
                        </p>

                        <blockquote>
                            <pre>
    .A 1400 LDX #$41     - X = CBM ASCII of "A"
    .A 1402 TXA          - A = X
    .A 1403 JSR $FFD2    - print character
    .A 1406 INX          - bump count
    .A 1407 CPX #$5B     - have we gone past "Z"?
    .A 1409 BNE $1402    - no, go back and do more
    .A 140B BRK          - yes, return to 64MON
                            </pre>
                        </blockquote>

                        <p>To see the Commodore 64 print the alphabet, type the familiar command:</p>

                        <blockquote>
                            <code>.G 1400</code>
                        </blockquote>

                        <p>The comments that are beside the program, explain the program flow and logic. If you are
                            writing a program, write it on paper first, and then test it in small parts if possible.</p>
                    </section>

                    <section class="main-section" id="Tips_for_the_Beginner">

                        <h4>Useful Tips for the Beginner</h4>

                        <p>One of the best ways to learn machine language is to look at other peoples' machine language
                            programs. These are published all the time in magazines and newsletters. Look at them even
                            if the article is for a different computer,
                            which also uses the 6510 (or 6502) microprocessor. You should make sure that you thoroughly
                            understand the code that you look at. This will require perseveres I ce, especially when you
                            see a new technique that you have never
                            come across before. This can be infuriating, but if patience prevails, you will be the
                            victor.</p>

                        <p>Having looked at other machine language programs, you MUST write your own. These may be
                            utilities for your BASIC programs, or they may be an all machine language program.</p>

                        <p>You should also use the utilities that are available, either IN your computer, or in a
                            program, that aid you in writing, editing, or tracking down errors in a machine language
                            program. An example would be the KERNAL, which allows
                            you to check the keyboard, print text, control peripheral devices like disk drives,
                            printers, modems, etc., manage memory and the screen. It is extremely powerful and it is
                            advised strongly that it is used (refer to KERNAL
                            section, Page 268).</p>

                        <p>Advantages of writing programs in machine language:</p>

                        <ol>
                            <li>Speed - Machine language is hunderds, and in some cases thousands of times faster than a
                                high-level language such as BASIC.</li>
                            <li>Tightness - A machine language program can be made totally "watertight," i.e., the user
                                can be made to do ONLY what the program allows, and no more. With a high level language,
                                you are relying on the user not "crashing" the
                                BASIC interpreter by entering, for example, a zero which later causes a:
                                <blockquote>
                                    <code>
                                        ?DIVISION BY ZERO ERROR IN LINE 830
                                        <br>
                                        <br>READY.
                                    </code>
                                </blockquote>
                            </li>
                        </ol>

                        <p>In essence, the computer can only be maximized by the machine language programmer.</p>
                    </section>

                    <section class="main-section" id="Approaching_a_Large_Task">

                        <h4>Approaching a Large Task</h4>

                        <p>When approaching a large task in machine language, a certain amount of subconscious thought
                            has usually taken place. You think about how certain processes are carried out in machine
                            language. When the task is started, it is usually
                            a good idea to write it out on paper. Use block diagrams of memory usage, functional modules
                            of code required, and a program flow. Let's say that you wanted to write a roulette game in
                            machine language. You could outline it
                            something like this:</p>

                        <ol>
                            <li>Display title</li>
                            <li>Ask if player requires instructions</li>
                            <li>YES - display them - Go to START</li>
                            <li>NO - Go to START</li>
                            <li>START - Initialize everything</li>
                            <li>MAIN - Display roulette table </li>
                            <li>Take in bets</li>
                            <li>Spin wheel</li>
                            <li>Slow wheel to stop</li>
                            <li>Check bets with result</li>
                            <li>Inform player</li>
                            <li>Player any money left?</li>
                            <li>YES - Go to MAIN</li>
                            <li>NO - Inform user, and go to START</li>
                        </ol>

                        <p>This is the main outline. As each module is approached, you can break it down further. If you
                            look at a large indigestable problem as something that can be broken down into small enough
                            pieces to be eaten, then you'll be able to
                            approach something that seems impossible, and have it all fall into place.</p>

                        <p>This process only improves with practice, so KEEP TRYING.</p>
                    </section>

                    <section class="main-section" id="MCS6510_Instruction_Set">

                        <h4>MCS6510 Microprocessor Instruction Set</h4>

                        <table>
                            <tr>
                                <th>Instruction</th>
                                <th>Description</th>
                            </tr>
                            <tr>
                                <td>ADC</td>
                                <td>Add memory to accumulator with carry</td>
                            </tr>
                            <tr>
                                <td>AND</td>
                                <td>"AND" memory with accumulator</td>
                            </tr>
                            <tr>
                                <td>ASL</td>
                                <td>Shift left one bit (memory or accumulator)</td>
                            </tr>
                            <tr>
                                <td>BCC</td>
                                <td>Branch on carry clear</td>
                            </tr>
                            <tr>
                                <td>BCS</td>
                                <td>Branch on carry set</td>
                            </tr>
                            <tr>
                                <td>BEQ</td>
                                <td>Branch on result zero</td>
                            </tr>
                            <tr>
                                <td>BIT</td>
                                <td>Test bits in memory with accumulator</td>
                            </tr>
                            <tr>
                                <td>BMI</td>
                                <td>Branch on result minus</td>
                            </tr>
                            <tr>
                                <td>BNE</td>
                                <td>Branch on result not zero</td>
                            </tr>
                            <tr>
                                <td>BPL</td>
                                <td>Branch on result plus</td>
                            </tr>
                            <tr>
                                <td>BRK</td>
                                <td>Force break</td>
                            </tr>
                            <tr>
                                <td>BVC</td>
                                <td>Branch on overflow clear</td>
                            </tr>
                            <tr>
                                <td>BVS</td>
                                <td>Branch on overflow set</td>
                            </tr>
                            <tr>
                                <td>CLC</td>
                                <td>Clear carry flag</td>
                            </tr>
                            <tr>
                                <td>CLD</td>
                                <td>Clear decimal mode</td>
                            </tr>
                            <tr>
                                <td>CLI</td>
                                <td>Clear interrupt disable bit</td>
                            </tr>
                            <tr>
                                <td>CLV</td>
                                <td>Clear overflow flag</td>
                            </tr>
                            <tr>
                                <td>CMP</td>
                                <td>Compare memory and accumulator</td>
                            </tr>
                            <tr>
                                <td>CPX</td>
                                <td>Compare memory and index X</td>
                            </tr>
                            <tr>
                                <td>CPY</td>
                                <td>Compare amemory and index Y.</td>
                            </tr>
                            <tr>
                                <td>DEC</td>
                                <td>Decrememnt memory by one</td>
                            </tr>
                            <tr>
                                <td>DEX</td>
                                <td>Decrement index X by one</td>
                            </tr>
                            <tr>
                                <td>DEY</td>
                                <td>Decrement index Y by one</td>
                            </tr>
                            <tr>
                                <td>EOR</td>
                                <td>"Exclusive-Or" memory with accumulator</td>
                            </tr>
                            <tr>
                                <td>INC</td>
                                <td>Increment memory by one</td>
                            </tr>
                            <tr>
                                <td>INX</td>
                                <td>Increment index X by one</td>
                            </tr>
                            <tr>
                                <td>INY</td>
                                <td>Increment index Y by one</td>
                            </tr>
                            <tr>
                                <td>JMP</td>
                                <td>Jump to new location</td>
                            </tr>
                            <tr>
                                <td>JSR</td>
                                <td>Jump to new location saving return address</td>
                            </tr>
                            <tr>
                                <td>LDA</td>
                                <td>Load accumulator with memory</td>
                            </tr>
                            <tr>
                                <td>LDX</td>
                                <td>Load index X with memory</td>
                            </tr>
                            <tr>
                                <td>LDY</td>
                                <td>Load index Y with memory</td>
                            </tr>
                            <tr>
                                <td>LSR</td>
                                <td>Shift right one bit (memory or accumulator)</td>
                            </tr>
                            <tr>
                                <td>NOP</td>
                                <td>No operation</td>
                            </tr>
                            <tr>
                                <td>ORA</td>
                                <td>"OR" memory with accumulator</td>
                            </tr>
                            <tr>
                                <td>PHA</td>
                                <td>Push accumulator on stack</td>
                            </tr>
                            <tr>
                                <td>PHP</td>
                                <td>Push processor status on stack</td>
                            </tr>
                            <tr>
                                <td>PLA</td>
                                <td>Pull accumulator from stack</td>
                            </tr>
                            <tr>
                                <td>PLP</td>
                                <td>Pull processor status from stack</td>
                            </tr>
                            <tr>
                                <td>ROL</td>
                                <td>Rotate one bit left (memory or accumulator)</td>
                            </tr>
                            <tr>
                                <td>ROR</td>
                                <td>Rotate one bit right (memory or accumulator)</td>
                            </tr>
                            <tr>
                                <td>RTI</td>
                                <td>Return from interrupt</td>
                            </tr>
                            <tr>
                                <td>RTS</td>
                                <td>Return from subroutine</td>
                            </tr>
                            <tr>
                                <td>SBC</td>
                                <td>Subtract memory from accumulator with borrow</td>
                            </tr>
                            <tr>
                                <td>SEC</td>
                                <td>Set carry flag</td>
                            </tr>
                            <tr>
                                <td>SED</td>
                                <td>Set decimal mode</td>
                            </tr>
                            <tr>
                                <td>SEI</td>
                                <td>Set interrupt disable status</td>
                            </tr>
                            <tr>
                                <td>STA</td>
                                <td>Store accumulator in memory</td>
                            </tr>
                            <tr>
                                <td>STX</td>
                                <td>Store index X in memory</td>
                            </tr>
                            <tr>
                                <td>STY</td>
                                <td>Store index Y in memory</td>
                            </tr>
                            <tr>
                                <td>TAX</td>
                                <td>Transfer accumulator to index X</td>
                            </tr>
                            <tr>
                                <td>TAY</td>
                                <td>Transfer accumulator to index Y</td>
                            </tr>
                            <tr>
                                <td>TSX</td>
                                <td>Transfer stack pointer to index accumulator</td>
                            </tr>
                            <tr>
                                <td>TXA</td>
                                <td>Transfer index X to accumulator</td>
                            </tr>
                            <tr>
                                <td>TXS</td>
                                <td>Transfer index X to stack pointer.</td>
                            </tr>
                            <tr>
                                <td>TYA</td>
                                <td>Transfer index Y to accumulator</td>
                            </tr>
                        </table>

                        <p>The following notation applies to this summary:</p>

                        <blockquote>
                            <pre>
                    A               Accumulator
                    X, Y            Index Registers
                    M               Memory
                    P               Processor Status Register
                    S               Stack Pointer
                    &radic;               Change
                    _               No Change
                    +               Add
                    &and;               Logical AND
                    -               Subtract
                    &oplus;              Logical Exclusive OR
                    &uarr;               Transfer from Stack
                    &darr;               Transfer to Stack 
                    &rarr;              Transfer to
                    &larr;              Transfer from
                    &or;               Logical OR
                    PC              Program Counter
                    PCH             Program Counter High
                    PCL             Program Counter Low
                    OPER            OPERAND
                    #               Immediate Addressing Node    
                            </pre>
                        </blockquote>

                        <p>
                            <strong>NOTE:</strong> At the top of each table is located in parentheses a reference number
                            (Ref: XX) which directs the user to that section in the MCS6500 Microcomputer Family
                            Programming Manual in which the instruction is defined and discussed.</p>

                        <h5 id="ADC">ADC</h5>

                        <p><em>Add memory to accumulator with carry</em></p>

                        <p>Operation: A + M + C &rarr; A, C</p>

                        <pre>
N Z C I D V
&radic; &radic; &radic; _ _ &radic;
                        </pre>

                        <p class="table-note">(Ref: 2.2.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>ADC #Oper</td>
                                <td>69</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>ADC Oper</td>
                                <td>65</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>ADC Oper, X</td>
                                <td>75</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>ADC Oper</td>
                                <td>60</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>ADC Oper, X</td>
                                <td>70</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>Absolute, Y</td>
                                <td>ADC Oper, Y</td>
                                <td>79</td>
                                <td>2</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>(Indirect, X)</td>
                                <td>ADC (Oper, X)</td>
                                <td>61</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>(Indirect, Y)</td>
                                <td>ADC (Oper, Y)</td>
                                <td>71</td>
                                <td>2</td>
                                <td>5*</td>
                            </tr>
                        </table>
                        <p class="table-note">* Add 1 if page boundary is crossed.</p>

                        <hr>

                        <h5 id="ML_AND">AND</h5>

                        <p><em>"AND" memory with accumulator</em></p>

                        <p>Operation: A &and; M &rarr; A</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 2.2.3.0)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>AND #Oper</td>
                                <td>29</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>AND Oper</td>
                                <td>25</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>AND Oper, X</td>
                                <td>35</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>AND Oper</td>
                                <td>2D</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>AND Oper, X</td>
                                <td>3D</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>Absolute, Y</td>
                                <td>AND Oper, Y</td>
                                <td>39</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>(Indirect, X)</td>
                                <td>AND (Oper, X)</td>
                                <td>21</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>(Indirect, Y)</td>
                                <td>AND (Oper, Y)</td>
                                <td>31</td>
                                <td>2</td>
                                <td>5</td>
                            </tr>
                        </table>
                        <p class="table-note">* Add 1 if page boundary is crossed.</p>

                        <hr>

                        <h5 id="ASL">ASL</h5>

                        <p><strong>ASL</strong>
                            <em>Shift Left One Bit (Memory or Accumulator)</em></p>

                        <p>Operation: C &larr; 75643210 &larr; 0</p>

                        <pre>
N Z C I D V
&radic; &radic; &radic; _ _ _
                            </pre>

                        <p class="table-note"> (Ref: 10.2)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Accumulator</td>
                                <td>ASL A</td>
                                <td>0A</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>ASL Oper</td>
                                <td>06</td>
                                <td>2</td>
                                <td>5</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>ASL Oper, X</td>
                                <td>16</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>ASL Oper</td>
                                <td>0E</td>
                                <td>3</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>ASL Oper, X</td>
                                <td>1E</td>
                                <td>3</td>
                                <td>7</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="BCC">BCC</h5>

                        <p><strong>BCC</strong>
                            <em>Branch on Carry Clear</em></p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p>Operation: Branch on C = 1</p>

                        <p class="table-note">(Ref: 4.1.1.3)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Relative</td>
                                <td>BCC Oper</td>
                                <td>90</td>
                                <td>2</td>
                                <td>2*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 if branch occurs to same page.
                            <br>* Add 2 if branch occurs to different page.</p>

                        <hr>

                        <h5 id="BCS">BCS</h5>

                        <p><strong>BCS</strong>
                            <em>Branch on carry set</em></p>

                        <p>Operation: Branch on C = 1</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 4.1.1.4)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Relative</td>
                                <td>BCS Oper</td>
                                <td>B0</td>
                                <td>2</td>
                                <td>2*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 if branch occurs to same page.
                            <br>* Add 2 if branch occurs to different page.</p>

                        <hr>

                        <h5 id="BEQ">BEQ</h5>

                        <p><strong>BEQ</strong>
                            <em>Branch on result zero</em></p>

                        <p>Operation: Branch on Z = 1</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 4.1.1.5)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Relative</td>
                                <td>BCS Oper</td>
                                <td>B0</td>
                                <td>2</td>
                                <td>2*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 if branch occurs to same page.
                            <br>* Add 2 if branch occurs to different page.</p>

                        <hr>

                        <h5 id="BIT">BIT</h5>

                        <p><strong>BIT</strong>
                            <em>Test bits in memory with accumulator</em></p>

                        <p>Operation: A &and; M, M<sub>7</sub> &rarr; N, M<sub>6</sub> &rarr; V
                            <br>Bit 6 and 7 are transferred to the status register. If the result of A &and; M is zero,
                            then Z = 1, otherwise Z = 0.</p>

                        <pre>
N Z C I D V
M<sub>7</sub>&radic; _ _ _ M<sub>6</sub>
                        </pre>

                        <p class="table-note">(Ref: 4.2.1.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>BIT Oper</td>
                                <td>24</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>BIT Oper</td>
                                <td>2C</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="BMI">BMI</h5>

                        <p><strong>BMI</strong>
                            <em>Branch on result minus</em></p>

                        <p>Operation: Branch on N = 1</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 4.1.1.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Relative</td>
                                <td>BMI Oper</td>
                                <td>30</td>
                                <td>2</td>
                                <td>2*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 if branch occurs to same page.
                            <br>* Add 2 if branch occurs to different page.</p>

                        <hr>

                        <h5 id="BNE">BNE</h5>

                        <p><strong>BNE</strong>
                            <em>Branch on result not zero</em></p>

                        <p>Operation: Branch on Z = 0</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 4.1.1.6)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Relative</td>
                                <td>BNE Oper</td>
                                <td>D0</td>
                                <td>2</td>
                                <td>2*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 if branch occurs to same page.
                            <br>* Add 2 if branch occurs to different page.</p>

                        <hr>

                        <h5 id="BPL">BPL</h5>

                        <p><strong>BPL</strong>
                            <em>Branch on result plus</em></p>

                        <p>Operation: Branch on N = 0</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 4.1.1.2)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Relative</td>
                                <td>BPL Oper</td>
                                <td>10</td>
                                <td>2</td>
                                <td>2*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 if branch occurs to same page.
                            <br>* Add 2 if branch occurs to different page.</p>

                        <hr>

                        <h5 id="BRK">BRK</h5>

                        <p><strong>BRK</strong>
                            <em>Forced break</em></p>

                        <p>Operation: Forced Interrupt PC + 2 &darr; P &darr;</p>

                        <pre>
N Z C I D V
_ _ _ 1 _ _
                        </pre>

                        <p class="table-note">(Ref: 9.11)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>BRK</td>
                                <td>00</td>
                                <td>1</td>
                                <td>7</td>
                            </tr>
                        </table>

                        <ol>
                            <li>A BRK command cannot be masked by setting I.
                        </ol>

                        <hr>

                        <h5 id="BVC">BVC</h5>

                        <p><strong>BVC</strong>
                            <em>Branch on overflow clear</em></p>

                        <p>Operation: Branch on V = 0</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 4.1.1.8)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Relative</td>
                                <td>BVC Oper</td>
                                <td>70</td>
                                <td>2</td>
                                <td>2*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 if branch occurs to same page.
                            <br>* Add 2 if branch occurs to different page.</p>

                        <hr>

                        <h5 id="BVS">BVS</h5>

                        <p><strong>BVS</strong>
                            <em>Branch on overflow set</em></p>

                        <p>Operation: Branch on V = 1</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 4.1.1.7)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Relative</td>
                                <td>BVS Oper</td>
                                <td>70</td>
                                <td>2</td>
                                <td>2*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 if branch occurs to same page.
                            <br>* Add 2 if branch occurs to different page.</p>

                        <hr>

                        <h5 id="CLC">CLC</h5>

                        <p><strong>CLC</strong>
                            <em>Clear carry flag</em></p>

                        <p>Operation: 0 &rarr; C</p>

                        <pre>
N Z C I D V
_ _ 0 _ _ _
                        </pre>

                        <p class="table-note">(Ref: 3.0.2)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>CLC</td>
                                <td>18</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="CLD">CLD</h5>

                        <p><strong>CLD</strong>
                            <em>Clear decimal mode</em></p>

                        <p>Operation: 0 &rarr; D </p>

                        <pre>
N Z C I D V
_ _ _ _ 0 _
                        </pre>

                        <p class="table-note">(Ref:3.3.2)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>CLD</td>
                                <td>D8</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="CLI">CLI</h5>

                        <p><strong>CLI</strong>
                            <em>Clear interrupt disable bit</em></p>

                        <p>Operation: 0 &rarr; I</p>

                        <pre>
N Z C I D V
_ _ _ 0 _ _
                        </pre>

                        <p class="table-note">(Ref: 3.2.2)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>CLI</td>
                                <td>58</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="CLV">CLV</h5>

                        <p><strong>CLV</strong>
                            <em>Clear overflow flag</em></p>

                        <p>Operation: 0 &rarr; V</p>

                        <pre>
N Z C I D V
_ _ _ _ _ 0
                        </pre>

                        <p class="table-note">(Ref: 3.6.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>CLv</td>
                                <td>B8</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="CMP">CMP</h5>

                        <p><strong>CMP</strong>
                            <em>Compare memory and accumulator</em></p>

                        <p>Operation: A - M</p>

                        <pre>
N Z C I D V
&radic; &radic; &radic; _ _ _
                        </pre>

                        <p class="table-note">(Ref: 4.2.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>CMP #Oper</td>
                                <td>C9</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>CMP Oper</td>
                                <td>C5</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>CMP Oper, X</td>
                                <td>D5</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>CMP Oper</td>
                                <td>CD</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>CMP Oper, X</td>
                                <td>DD</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>Absolute, Y</td>
                                <td>CMP Oper, Y</td>
                                <td>D9</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>(Indirect, X)</td>
                                <td>CMP (Oper, X)</td>
                                <td>C1</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>(Indirect, Y)</td>
                                <td>CMP (Oper, Y)</td>
                                <td>D1</td>
                                <td>2</td>
                                <td>5*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 if page boundary is crossed.</p>

                        <hr>

                        <h5 id="CPX">CPX</h5>

                        <p><strong>CPX</strong>
                            <em>Compare Memory and Index X</em></p>

                        <p>Operation: X - M</p>

                        <pre>
N Z C I D V
&radic; &radic; &radic; _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.8)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>CPX *Oper</td>
                                <td>E0</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>CPX Oper</td>
                                <td>E4</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>CPX Oper</td>
                                <td>EC</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="CPY">CPY</h5>

                        <p><strong>CPY</strong>
                            <em>Compare Memory and Index Y</em></p>

                        <p>Operation: Y - M</p>

                        <pre>
N Z C I D V
&radic; &radic; &radic; _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.9)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>CPY *Oper</td>
                                <td>C0</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>CPY Oper</td>
                                <td>C4</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>CPY Oper</td>
                                <td>CC</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="DEC">DEC</h5>

                        <p><strong>DEC</strong>
                            <em>Decrement memory by one</em></p>

                        <p>Operation: M - 1 &rarr; M</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 10.7)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>DEC Oper</td>
                                <td>C6</td>
                                <td>2</td>
                                <td>5</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>DEC Oper, X</td>
                                <td>D6</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>DEC Oper</td>
                                <td>CE</td>
                                <td>3</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>DEC Oper, X</td>
                                <td>DE</td>
                                <td>3</td>
                                <td>7</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="DEX">DEX</h5>

                        <p><strong>DEX</strong>
                            <em>Decrement index X by one.</em></p>

                        <p>Operation: X - 1 &rarr; X</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _                        
                        </pre>

                        <p class="table-note">(Ref: 7.6)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>DEX</td>
                                <td>CA</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="DEY">DEY</h5>

                        <p><strong>DEY</strong>
                            <em>Decrement index Y by one.</em></p>

                        <p>Operation: Y - 1 &rarr; Y</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _                        
                        </pre>

                        <p class="table-note">(Ref: 7.7)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>DEY</td>
                                <td>88</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="EOR">EOR</h5>

                        <p><strong>EOR</strong>
                            <em>"Exclusive-Or" memory with accumulator</em></p>

                        <p>Operation: A &oplus; M &rarr; A</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 2.2.3.2)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>EOR #Oper</td>
                                <td>49</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>EOR Oper</td>
                                <td>45</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>EOR Oper, X</td>
                                <td>55</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>EOR Oper</td>
                                <td>40</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>EOR Oper, X</td>
                                <td>50</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>Absolute, Y</td>
                                <td>EOR Oper, Y</td>
                                <td>59</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>(Indirect, X)</td>
                                <td>EOR (Oper, X)</td>
                                <td>41</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>(Indirect), Y</td>
                                <td>EOR (Oper), Y</td>
                                <td>51</td>
                                <td>2</td>
                                <td>5*</td>
                            </tr>
                        </table>

                        <hr>

                        <p class="table-note">* Add 1 if page boundary is crossed.</p>

                        <h5 id="INC">INC</h5>

                        <p><strong>INC</strong>
                            <em>Increment memory by one.</em></p>

                        <p>Operation: M + 1 &rarr; M</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref 10.6)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>INC Oper</td>
                                <td>E6</td>
                                <td>2</td>
                                <td>5</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>INC Oper, X</td>
                                <td>F6</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>INC Oper</td>
                                <td>EE</td>
                                <td>3</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>INC Oper, X</td>
                                <td>FE</td>
                                <td>3</td>
                                <td>7</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="INX">INX</h5>

                        <p><strong>INX</strong>
                            <em>Increment Index X by one.</em></p>

                        <p>Operation: X + 1 &rarr; X</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.4)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>INX</td>
                                <td>E8</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="INY">INY</h5>

                        <p><strong>INY</strong>
                            <em>Increment Index Y by one.</em></p>

                        <p>Operation: Y + 1 &rarr; X</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.5)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>INY</td>
                                <td>C8</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="JMP">JMP</h5>

                        <p><strong>JMP</strong>
                            <em>Jump to new location</em></p>

                        <p>Operation: (PC + 1) &rarr; PCL; (PC + 2) &rarr; PCH</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 4.0.2, 9.8.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>JMP Oper</td>
                                <td>4C</td>
                                <td>3</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Indirect</td>
                                <td>JMP (Oper)</td>
                                <td>6C</td>
                                <td>3</td>
                                <td>5</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="JSR">JSR</h5>

                        <p><strong>JSR</strong>
                            <em>Jump to new location saving return address</em></p>

                        <p>Operation: PC + 2 &darr;, (PC + 1) &rarr; PCL; (PC + 2) &rarr; PCH</p>

                        <p class="table-note">(Ref: 8.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>JSR Oper</td>
                                <td>20</td>
                                <td>3</td>
                                <td>6</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="LDA">LDA</h5>

                        <p><strong>LDA</strong>
                            <em>Load accumulator with memory</em></p>

                        <p>Operation: M &rarr; A</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 2.1.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>LDA #Oper</td>
                                <td>A9</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>LDA Oper</td>
                                <td>A5</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>LDA Oper, X</td>
                                <td>B5</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>LDA Oper</td>
                                <td>AD</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>LDA Oper, X</td>
                                <td>BD</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>Absolute, Y</td>
                                <td>LDA Oper, Y</td>
                                <td>B9</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>(Indirect, X)</td>
                                <td>LDA (Oper, X)</td>
                                <td>A1</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>(Indirect), Y</td>
                                <td>LDA (Oper), Y</td>
                                <td>B1</td>
                                <td>2</td>
                                <td>5*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 if page boundary is crossed.</p>

                        <hr>

                        <h5 id="LDX">LDX</h5>

                        <p><strong>LDX</strong>
                            <em>Load index X with memory</em></p>

                        <p>Operation: M &rarr; X</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.0)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>LDX #Oper</td>
                                <td>A2</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>LDX Oper</td>
                                <td>A6</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, Y</td>
                                <td>LDX Oper, Y</td>
                                <td>B6</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>LDX Oper</td>
                                <td>AE</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute, Y</td>
                                <td>LDX Oper, Y</td>
                                <td>BE</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 when page boundary is crossed.</p>

                        <hr>

                        <h5 id="LDY">LDY</h5>

                        <p><strong>LDY</strong>
                            <em>Load index Y with memory</em></p>

                        <p>Operation: M &rarr; Y</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>LDY #Oper</td>
                                <td>A0</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>LDY Oper</td>
                                <td>A4</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>LDY Oper</td>
                                <td>A4</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>LDY Oper, X</td>
                                <td>B4</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>LDY Oper</td>
                                <td>AC</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>LDY Oper, X</td>
                                <td>BC</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 when page boundary is crossed.</p>

                        <hr>

                        <h5 id="LSR">LSR</h5>

                        <p><strong>LSR</strong>
                            <em>Shift right one bit (memory or accumulator).</em></p>

                        <p>Operation: 0 &rarr; | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | &rarr; C</p>

                        <pre>
N Z C I D V
0 &radic; &radic; _ _ _
                        </pre>

                        <p class="table-note">(Ref: 10.1)</p>
                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Accumulator</td>
                                <td>LSR A</td>
                                <td>4A</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>LSR Oper</td>
                                <td>46</td>
                                <td>2</td>
                                <td>5</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>LSR Oper, X</td>
                                <td>56</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>LSR Oper</td>
                                <td>4E</td>
                                <td>3</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>LSR Oper, X</td>
                                <td>5E</td>
                                <td>3</td>
                                <td>7</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="NOP">NOP</h5>

                        <p><strong>NOP</strong>
                            <em>No operation.</em></p>

                        <p>Operation: No operation (2 cycles)</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>NOP</td>
                                <td>EA</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="ORA">ORA</h5>

                        <p><strong>ORA</strong>
                            <em>"OR" memory with accumulator</em></p>

                        <p>Operation: A &or; M &rarr; A</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 2.2.3.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>ORA #Oper</td>
                                <td>09</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>ORA Oper</td>
                                <td>05</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>ORA Oper, X</td>
                                <td>15</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>ORA Oper</td>
                                <td>0D</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>ORA Oper, X</td>
                                <td>1D</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>Absolute, Y</td>
                                <td>ORA Oper, Y</td>
                                <td>19</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>(Indirect, X)</td>
                                <td>ORA (Oper, X)</td>
                                <td>01</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>(Indirect), Y</td>
                                <td>ORA (Oper), Y</td>
                                <td>11</td>
                                <td>2</td>
                                <td>5</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 on page crossing</p>

                        <hr>

                        <h5 id="PHA">PHA</h5>

                        <p><strong>PHA</strong>
                            <em>Push accumulator on stack</em></p>

                        <p>Operation: A &darr;</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 8.11)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>PHA</td>
                                <td>48</td>
                                <td>1</td>
                                <td>3</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="PHP">PHP</h5>

                        <p><strong>PHP</strong>
                            <em>Push processor status on stack</em></p>

                        <p>Operation: P &darr;</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 8.11)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>PHP</td>
                                <td>08</td>
                                <td>1</td>
                                <td>3</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="PLA">PLA</h5>

                        <p><strong>PLA</strong>
                            <em>Pull accumulator from stack</em></p>

                        <p>Operation: A &uarr;</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 8.6)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>PLA</td>
                                <td>68</td>
                                <td>1</td>
                                <td>4</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="PLP">PLP</h5>

                        <p><strong>PLP</strong>
                            <em>Pull accumulator from stack</em></p>

                        <p>Operation: P &uarr;</p>

                        <pre>
N Z C I D V
 From Stack                       
                        </pre>

                        <p class="table-note">(Ref: 8.12)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>PLP</td>
                                <td>28</td>
                                <td>1</td>
                                <td>4</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="ROL">ROL</h5>

                        <p><strong>ROL</strong>
                            <em>Rotate one bit left (memory or accumulator)</em></p>

                        <p>Operation:&nbsp;&nbsp;&nbsp;<img class="ex-img"
                                src="https://i.postimg.cc/cJkksKT9/rotate-left.png" alt="Rotate one bit left"></p>

                        <pre>
N Z C I D V
&radic; &radic; &radic; _ _ _
                        </pre>

                        <p class="table-note">(Ref: 10.3)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Accumulator</td>
                                <td>ROL A</td>
                                <td>2A</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>ROL Oper</td>
                                <td>26</td>
                                <td>2</td>
                                <td>5</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>ROL Oper, X</td>
                                <td>36</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>ROL Oper</td>
                                <td>2E</td>
                                <td>3</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>ROL Oper, X</td>
                                <td>3E</td>
                                <td>3</td>
                                <td>7</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="ROR">ROR</h5>

                        <p><strong>ROR</strong>
                            <em>Rotate one bit right (memory or accumulator)</em></p>

                        <p>Operation:&nbsp;&nbsp;&nbsp;<img class="ex-img"
                                src="https://i.postimg.cc/nhPqrvbD/rotate-right.png" alt="Rotate one bit right"></p>

                        <pre>
N Z C I D V
&radic; &radic; &radic; _ _ _
                        </pre>

                        <p class="table-note">(Ref: 10.4)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Accumulator</td>
                                <td>ROR A</td>
                                <td>6A</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>ROR Oper</td>
                                <td>66</td>
                                <td>2</td>
                                <td>5</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>ROR Oper, X</td>
                                <td>76</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>ROR Oper</td>
                                <td>6E</td>
                                <td>3</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>ROR Oper, X</td>
                                <td>7E</td>
                                <td>3</td>
                                <td>7</td>
                            </tr>
                        </table>

                        <p class="table-note">Note: ROR instruction will be available on MCS650X microprocessors after
                            June 1976.</p>

                        <hr>

                        <h5 id="RTI">RTI</h5>

                        <p><strong>RTI</strong>
                            <em>Return from interrupt</em></p>

                        <p>Operation: P&uarr; PC&uarr;</p>

                        <pre>
N Z C I D V
 From Stack
                        </pre>

                        <p class="table-note">(Ref: 9.6)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>RTI</td>
                                <td>40</td>
                                <td>1</td>
                                <td>6</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="RTS">RTS</h5>

                        <p><strong>RTS</strong>
                            <em>Return from subroutine</em></p>

                        <p>Operation: PC&uarr;, PC + 1 &rarr; PC</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 8.2)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>RTS</td>
                                <td>60</td>
                                <td>1</td>
                                <td>6</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="SBC">SBC</h5>

                        <p><strong>SBC</strong>
                            <em>Subtract memory from accumulator with borrow</em></p>

                        <p>Operation: A - M - C&#773; &rarr; A</p>

                        <p>Note: C&#773; = Borrow</p>

                        <pre>
N Z C I D V
&radic; &radic; &radic; _ _ &radic;
                        </pre>

                        <p class="table-note">(Ref: 2.2.2)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Immediate</td>
                                <td>SBC #Oper</td>
                                <td>E9</td>
                                <td>2</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>SBC Oper</td>
                                <td>E5</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>SBC Oper, X</td>
                                <td>F5</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>SBC Oper</td>
                                <td>ED</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>SBC Oper, X</td>
                                <td>FD</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>Absolute, Y</td>
                                <td>SBC Oper, Y</td>
                                <td>F9</td>
                                <td>3</td>
                                <td>4*</td>
                            </tr>
                            <tr>
                                <td>(Indirect, X)</td>
                                <td>SBC (Oper, X)</td>
                                <td>E1</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>(Indirect), Y</td>
                                <td>SBC (Oper), Y</td>
                                <td>F1</td>
                                <td>2</td>
                                <td>5*</td>
                            </tr>
                        </table>

                        <p class="table-note">* Add 1 when page boundary is crossed.</p>

                        <hr>

                        <h5 id="SEC">SEC</h5>

                        <p><strong>SEC</strong>
                            <em>Set carry flag</em></p>

                        <p>Operation: 1 &rarr; C</p>

                        <pre>
N Z C I D V
_ _ _ _ 1 _
                        </pre>

                        <p class="table-note">(Ref: 3.0.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>SEC</td>
                                <td>38</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="SED">SED</h5>

                        <p><strong>SED</strong>
                            <em>Set decimal mode</em></p>

                        <p>Operation: 1 &rarr; D</p>

                        <pre>
N Z C I D V
_ _ _ _ 1 _
                        </pre>

                        <p class="table-note">(Ref: 3.3.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>SED</td>
                                <td>F8</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="SEI">SEI</h5>

                        <p><strong>SEI</strong>
                            <em>Set interrupt disable status</em></p>

                        <p>Operation: 1 &rarr; I</p>

                        <pre>
N Z C I D V
_ _ _ 1 _ _
                        </pre>

                        <p class="table-note">(Ref: 3.2.1)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>SEI</td>
                                <td>78</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="STA">STA</h5>

                        <p><strong>STA</strong>
                            <em>Store accumulator in memory</em></p>

                        <p>Operation: A &rarr; M</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 2.1.2)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>STA Oper</td>
                                <td>85</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>STA Oper, X</td>
                                <td>95</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>STA Oper</td>
                                <td>8D</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute, X</td>
                                <td>STA Oper, X</td>
                                <td>9D</td>
                                <td>3</td>
                                <td>5</td>
                            </tr>
                            <tr>
                                <td>Absolute, Y</td>
                                <td>STA Oper, Y</td>
                                <td>99</td>
                                <td>3</td>
                                <td>5</td>
                            </tr>
                            <tr>
                                <td>(Indirect, X)</td>
                                <td>STA (Oper, X)</td>
                                <td>81</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                            <tr>
                                <td>(Indirect), Y</td>
                                <td>STA (Oper), Y</td>
                                <td>91</td>
                                <td>2</td>
                                <td>6</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="STX">STX</h5>

                        <p><strong>STX</strong>
                            <em>Store index X in memory</em></p>

                        <p>Operation: X &rarr; M</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.2)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>STX Oper</td>
                                <td>86</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, Y</td>
                                <td>STX Oper, Y</td>
                                <td>96</td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>STX Oper</td>
                                <td>8E</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="STY">STY</h5>

                        <p><strong>STY</strong>
                            <em>Store index Y in memory</em></p>

                        <p>Operation: Y &rarr; M</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.3)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Zero Page</td>
                                <td>STY Oper</td>
                                <td>84</td>
                                <td>2</td>
                                <td>3</td>
                            </tr>
                            <tr>
                                <td>Zero Page, X</td>
                                <td>STY Oper, X</td>
                                <td>964/td>
                                <td>2</td>
                                <td>4</td>
                            </tr>
                            <tr>
                                <td>Absolute</td>
                                <td>STY Oper</td>
                                <td>8C</td>
                                <td>3</td>
                                <td>4</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="TAX">TAX</h5>

                        <p><strong>TAX</strong>
                            <em>Transfer accumulator to index X</em></p>

                        <p>Operation: A &rarr; X</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.11)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>TAX</td>
                                <td>AA</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="TAY">TAY</h5>

                        <p><strong>TAY</strong>
                            <em>Transfer accumulator to index Y</em></p>

                        <p>Operation: A &rarr; Y</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.13)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>TAY</td>
                                <td>A8</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="TSX">TSX</h5>

                        <p><strong>TSX</strong>
                            <em>Transfer stack pointer to index X</em></p>

                        <p>Operation: S &rarr; X</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 8.9)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>TSX</td>
                                <td>BA</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="TXA">TXA</h5>

                        <p><strong>TXA</strong>
                            <em>Transfer index X to accumulator</em></p>

                        <p>Operation: X &rarr; A</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 8.9)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>TXA</td>
                                <td>8A</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="TXS">TXS</h5>

                        <p><strong>TXS</strong>
                            <em>Transfer index X to stack pointer</em></p>

                        <p>Operation: X &rarr; S</p>

                        <pre>
N Z C I D V
_ _ _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 8.8)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>TXS</td>
                                <td>9A</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="TYA">TYA</h5>

                        <p><strong>TYA</strong>
                            <em>Transfer index Y to accumulator</em></p>

                        <p>Operation: S &rarr; X</p>

                        <pre>
N Z C I D V
&radic; &radic; _ _ _ _
                        </pre>

                        <p class="table-note">(Ref: 7.14)</p>

                        <table>
                            <tr>
                                <th>Addressing Mode</th>
                                <th>Assembly Language Form</th>
                                <th>OP CODE</th>
                                <th>No. Bytes</th>
                                <th>No. Cycles</th>
                            </tr>
                            <tr>
                                <td>Implied</td>
                                <td>TYA</td>
                                <td>98</td>
                                <td>1</td>
                                <td>2</td>
                            </tr>
                        </table>

                        <hr>

                        <h4 id="Instruction_Addressing_Modes">Instruction Addressing Modes and Related Execution Times
                            (in clock cycles)</h4>

                        <table>
                            <tr>
                                <th class="rotate">
                                    <div><span>Instruction</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Accumulator</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Immediate</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Zero Page</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Zero Page, X</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Zero Page, Y</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Absolute</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Absolute, X</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Absolute, Y</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Implied</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Relative</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>(Indirect, X)</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>(Indirect), Y</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Absolute <br>Indirect</span></div>
                                </th>
                            </tr>
                            <tr>
                                <td>ADC</td>
                                <td>-</td>
                                <td>2</td>
                                <td>3</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4</td>
                                <td>4*</td>
                                <td>4*</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>5*</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>AND</td>
                                <td>-</td>
                                <td>2</td>
                                <td>3</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4</td>
                                <td>4*</td>
                                <td>4*</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>5*</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>ASL</td>
                                <td>2</td>
                                <td>-</td>
                                <td>5</td>
                                <td>6</td>
                                <td>-</td>
                                <td>7</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>BCC</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2**</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>BCS</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2**</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>BEQ</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2**</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>BIT</td>
                                <td>-</td>
                                <td>-</td>
                                <td>3</td>
                                <td>-</td>
                                <td>-</td>
                                <td>4</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>BMI</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2**</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>BNE</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2**</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>BPL</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2**</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>BRK</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>BVC</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2**</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>BVS</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2**</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>CLC</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>CLD</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>CLI</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>CLV</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>CMP</td>
                                <td>-</td>
                                <td>2</td>
                                <td>3</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4</td>
                                <td>4*</td>
                                <td>4*</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>5*</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>CPX</td>
                                <td>-</td>
                                <td>2</td>
                                <td>3</td>
                                <td>-</td>
                                <td>-</td>
                                <td>4</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>CPY</td>
                                <td>-</td>
                                <td>2</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>4</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>DEC</td>
                                <td>-</td>
                                <td>-</td>
                                <td>5</td>
                                <td>6</td>
                                <td>-</td>
                                <td>6</td>
                                <td>7</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>DEX</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>DEY</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>EOR</td>
                                <td>-</td>
                                <td>2</td>
                                <td>3</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4</td>
                                <td>4*</td>
                                <td>4*</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>5*</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>INC</td>
                                <td>-</td>
                                <td>-</td>
                                <td>5</td>
                                <td>6</td>
                                <td>-</td>
                                <td>6</td>
                                <td>7</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>INX</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>INY</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>JMP</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>3</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>5</td>
                            </tr>
                            <tr>
                                <td>JSR</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>LDA</td>
                                <td>-</td>
                                <td>2</td>
                                <td>3</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4</td>
                                <td>4*</td>
                                <td>4*</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>5*</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>LDX</td>
                                <td>-</td>
                                <td>2</td>
                                <td>3</td>
                                <td>-</td>
                                <td>4</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4*</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>LDY</td>
                                <td>-</td>
                                <td>2</td>
                                <td>3</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4</td>
                                <td>4*</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>LSR</td>
                                <td>2</td>
                                <td>-</td>
                                <td>5</td>
                                <td>6</td>
                                <td>-</td>
                                <td>6</td>
                                <td>7</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>NOP</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>ORA</td>
                                <td>-</td>
                                <td>2</td>
                                <td>3</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4</td>
                                <td>4*</td>
                                <td>4*</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>5*</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>PHA</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>3</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>PHP</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>3</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>PLA</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>4</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>PLP</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>4</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>ROL</td>
                                <td>2</td>
                                <td>-</td>
                                <td>5</td>
                                <td>6</td>
                                <td>-</td>
                                <td>6</td>
                                <td>7</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>ROR</td>
                                <td>2</td>
                                <td>-</td>
                                <td>5</td>
                                <td>6</td>
                                <td>-</td>
                                <td>6</td>
                                <td>7</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>RTI</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>RTS</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>SBC</td>
                                <td>-</td>
                                <td>2</td>
                                <td>3</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4</td>
                                <td>4*</td>
                                <td>4*</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>5*</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>SEC</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>SED</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>SEI</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>STA</td>
                                <td>-</td>
                                <td>-</td>
                                <td>3</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4</td>
                                <td>5</td>
                                <td>5</td>
                                <td>-</td>
                                <td>-</td>
                                <td>6</td>
                                <td>6</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>STX</td>
                                <td>-</td>
                                <td>-</td>
                                <td>3</td>
                                <td>-</td>
                                <td>4</td>
                                <td>4</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>STY</td>
                                <td>-</td>
                                <td>-</td>
                                <td>3</td>
                                <td>4</td>
                                <td>-</td>
                                <td>4</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>TAX</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>TAY</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>TSX</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>TXA</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>TXS</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>TXA</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>TYA</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>2</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <th class="rotate">
                                    <div><span>Instruction</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Accumulator</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Immediate</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Zero Page</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Zero Page, X</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Zero Page, Y</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Absolute</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Absolute, X</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Absolute, Y</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Implied</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Relative</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>(Indirect, X)</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>(Indirect), Y</span></div>
                                </th>
                                <th class="rotate">
                                    <div><span>Absolute <br>Indirect</span></div>
                                </th>
                            </tr>
                        </table>

                        <p class="table-note">* Add one cycle if indexing across page boundary.
                            <br>** Add one cycle if branch is taken. Add one additional if branching operation crosses
                            page boundary</p>

                        <pre>
                                00 - BRK                        20 - JSR
                                01 - ORA - (Indirect,X)         21 - AND - (Indirect,X)
                                02 - Future Expansion           22 - Future Expansion
                                03 - Future Expansion           23 - Future Expansion
                                04 - Future Expansion           24 - BIT - Zero Page
                                05 - ORA - Zero Page            25 - AND - Zero Page
                                06 - ASL - Zero Page            26 - ROL - Zero Page
                                07 - Future Expansion           27 - Future Expansion
                                08 - PHP                        28 - PLP
                                09 - ORA - Immediate            29 - AND - Immediate
                                0A - ASL - Accumulator          2A - ROL - Accumulator
                                0B - Future Expansion           2B - Future Expansion
                                0C - Future Expansion           2C - BIT - Absolute
                                0D - ORA - Absolute             2D - AND - Absolute
                                0E - ASL - Absolute             2E - ROL - Absolute
                                0F - Future Expansion           2F - Future Expansion
                                10 - BPL                        30 - BMI
                                11 - ORA - (Indirect),Y         31 - AND - (Indirect),Y
                                12 - Future Expansion           32 - Future Expansion
                                13 - Future Expansion           33 - Future Expansion
                                14 - Future Expansion           34 - Future Expansion
                                15 - ORA - Zero Page,X          35 - AND - Zero Page,X
                                16 - ASL - Zero Page,X          36 - ROL - Zero Page,X
                                17 - Future Expansion           37 - Future Expansion
                                18 - CLC                        38 - SEC
                                19 - ORA - Absolute,Y           39 - AND - Absolute,Y
                                1A - Future Expansion           3A - Future Expansion
                                1B - Future Expansion           3B - Future Expansion
                                1C - Future Expansion           3C - Future Expansion
                                1D - ORA - Absolute,X           3D - AND - Absolute,X
                                1E - ASL - Absolute,X           3E - ROL - Absolute,X
                                1F - Future Expansion           3F - Future Expansion
                                40 - RTI                        60 - RTS
                                41 - EOR - (Indirect,X)         61 - ADC - (Indirect,X)
                                42 - Future Expansion           62 - Future Expansion
                                43 - Future Expansion           63 - Future Expansion
                                44 - Future Expansion           64 - Future Expansion
                                45 - EOR - Zero Page            65 - ADC - Zero Page
                                46 - LSR - Zero Page            66 - ROR - Zero Page
                                47 - Future Expansion           67 - Future Expansion
                                48 - PHA                        68 - PLA
                                49 - EOR - Immediate            69 - ADC - Immediate
                                4A - LSR - Accumulator          6A - ROR - Accumulator
                                4B - Future Expansion           6B - Future Expansion
                                4C - JMP - Absolute             6C - JMP - Indirect
                                4D - EOR - Absolute             6D - ADC - Absolute
                                4E - LSR - Absolute             6E - ROR - Absolute
                                4F - Future Expansion           6F - Future Expansion
                                50 - BVC                        70 - BVS
                                51 - EOR - (Indirect),Y         71 - ADC - (Indirect),Y
                                52 - Future Expansion           72 - Future Expansion
                                53 - Future Expansion           73 - Future Expansion
                                54 - Future Expansion           74 - Future Expansion
                                55 - EOR - Zero Page,X          75 - ADC - Zero Page,X
                                56 - LSR - Zero Page,X          76 - ROR - Zero Page,X
                                57 - Future Expansion           77 - Future Expansion
                                58 - CLI                        78 - SEI
                                59 - EOR - Absolute,Y           79 - ADC - Absolute,Y
                                5A - Future Expansion           7A - Future Expansion
                                5B - Future Expansion           7B - Future Expansion
                                5C - Future Expansion           7C - Future Expansion
                                50 - EOR - Absolute,X           70 - ADC - Absolute,X
                                5E - LSR - Absolute,X           7E - ROR - Absolute,X
                                5F - Future Expansion           7F - Future Expansion
                                80 - Future Expansion           A0 - LDY - Immediate
                                81 - STA - (Indirect,X)         A1 - LDA - (Indirect,X)
                                82 - Future Expansion           A2 - LDX - Immediate
                                83 - Future Expansion           A3 - Future Expansion
                                84 - STY - Zero Page            A4 - LDY - Zero Page
                                85 - STA - Zero Page            A5 - LDA - Zero Page
                                86 - STX - Zero Page            A6 - LDX - Zero Page
                                87 - Future Expansion           A7 - Future Expansion
                                88 - DEY                        A8 - TAY
                                89 - Future Expansion           A9 - LDA - Immediate
                                8A - TXA                        AA - TAX
                                8B - Future Expansion           AB - Future Expansion
                                8C - STY - Absolute             AC - LDY - Absolute
                                80 - STA - Absolute             AD - LDA - Absolute
                                8E - STX - Absolute             AE - LDX - Absolute
                                8F - Future Expansion           AF - Future Expansion
                                90 - BCC                        B0 - BCS
                                91 - STA - (Indirect),Y         B1 - LDA - (Indirect),Y
                                92 - Future Expansion           B2 - Future Expansion
                                93 - Future Expansion           B3 - Future Expansion
                                94 - STY - Zero Page,X          B4 - LDY - Zero Page,X
                                95 - STA - Zero Page,X          BS - LDA - Zero Page,X
                                96 - STX - Zero Page,Y          B6 - LDX - Zero Page,Y
                                97 - Future Expansion           B7 - Future Expansion
                                98 - TYA                        B8 - CLV
                                99 - STA - Absolute,Y           B9 - LDA - Absolute,Y
                                9A - TXS                        BA - TSX
                                9B - Future Expansion           BB - Future Expansion
                                9C - Future Expansion           BC - LDY - Absolute,X
                                90 - STA - Absolute,X           BD - LDA - Absolute,X
                                9E - Future Expansion           BE - LDX - Absolute,Y
                                9F - Future Expansion           BF - Future Expansion
                                C0 - Cpy - Immediate            E0 - CPX - Immediate
                                C1 - CMP - (Indirect,X)         E1 - SBC - (Indirect,X)
                                C2 - Future Expansion           E2 - Future Expansion
                                C3 - Future Expansion           E3 - Future Expansion
                                C4 - CPY - Zero Page            E4 - CPX - Zero Page
                                C5 - CMP - Zero Page            E5 - SBC - Zero Page
                                C6 - DEC - Zero Page            E6 - INC - Zero Page
                                C7 - Future Expansion           E7 - Future Expansion
                                C8 - INY                        E8 - INX
                                C9 - CMP - Immediate            E9 - SBC - Immediate
                                CA - DEX                        EA - NOP
                                CB - Future Expansion           EB - Future Expansion
                                CC - CPY - Absolute             EC - CPX - Absolute
                                CD - CMP - Absolute             ED - SBC - Absolute
                                CE - DEC - Absolute             EE - INC - Absolute
                                CF - Future Expansion           EF - Future Expansion
                                D0 - BNE                        F0 - BEQ
                                D1 - CMP   (Indirect@,Y         F1 - SBC - (Indirect),Y
                                D2 - Future Expansion           F2 - Future Expansion
                                D3 - Future Expansion           F3 - Future Expansion
                                D4 - Future Expansion           F4 - Future Expansion
                                D5 - CMP - Zero Page,X          F5 - SBC - Zero Page,X
                                D6 - DEC - Zero Page,X          F6 - INC - Zero Page,X
                                D7 - Future Expansion           F7 - Future Expansion
                                D8 - CLD                        F8 - SED
                                D9 - CMP - Absolute,Y           F9 - SBC - Absolute,Y
                                DA - Future Expansion           FA - Future Expansion
                                DB - Future Expansion           FB - Future Expansion
                                DC - Future Expansion           FC - Future Expansion
                                DD - CMP - Absolute,X           FD - SBC - Absolute,X
                                DE - DEC - Absolute,X           FE - INC - Absolute,X
                                DF - Future Expansion           FF - Future Expansion
                        </pre>

                        <hr>

                        <h4 id="Memory_Management">Memory Management on the Commodore 64</h4>

                        <p>The Commodore 64 has 64K bytes of RAM. It also has 20K bytes of ROM,
                            containing BASIC, the operating system, and the standard character set.
                            It also accesses input/output devices as a 4K chunk of memory. How is
                            this all possible on a computer with a 16-bit address bus, that is
                            normally only capable of addressing 64K?</p>

                        <p>The secret is in the 6510 processor chip itself. On the chip is an
                            input/output port. This port is used to control whether RAM or ROM or I/O
                            will appear in certain portions of the system's memory. The port is also
                            used to control the Datassette(TM), so it is important to affect only the
                            proper bits.</p>

                        <p>The 6510 input/output port appears at location 1. The data direction
                            register for this port appears at location 0. The port is controlled like
                            any of the other input/output ports in the system... the data direction
                            controls whether a given bit will be an input or an output, and the
                            actual data transfer occurs through the port itself. The lines in the
                            6510 control port are defined as follows:</p>

                        <table>
                            <tr>
                                <th>Name</th>
                                <th>Bit</th>
                                <th>Direction</th>
                                <th>Description</th>
                            </tr>
                            <tr>
                                <td>LORAM</td>
                                <td>0</td>
                                <td>OUTPUT</td>
                                <td>Control for RAM/ROM at $A000-$BFFF </td>
                            </tr>
                            <tr>
                                <td>HIRAM</td>
                                <td>1</td>
                                <td>OUTPUT</td>
                                <td>Control for RAM/ROM at $E000-$FFFF </td>
                            </tr>
                            <tr>
                                <td>CHAREN</td>
                                <td>2</td>
                                <td>OUTPUT</td>
                                <td>Control for I/O/ROM at $D000-$DFFF</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>3</td>
                                <td>OUTPUT</td>
                                <td>Cassette write line</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>4</td>
                                <td>INPUT</td>
                                <td>Cassette switch sense (0 = play button down)</td>
                            </tr>
                            <tr>
                                <td></td>
                                <td>5</td>
                                <td>OUTPUT</td>
                                <td>Cassette motor control (0 = motor spins)</td>
                            </tr>
                        </table>

                        <p>The proper value for the data direction register is as follows:</p>

                        <pre>
                                BITS 5 4 3 2 1 0
                                ----------------
                                     1 0 1 1 1 1
                        </pre>

                        <p>(where 1 is an output, and 0 is an input).</p>

                        <p> This gives a value of 47 decimal. The Commodore 64 automatically sets
                            the data direction register to this value.</p>

                        <p>The control lines, in general, perform the function given in their de-
                            scriptions. However, a combination of control lines are occasionally used
                            to get a particular memory configuration.</p>

                        <p>LORAM (bit 0) can generally be thought of as a control line which banks
                            the 8K byte BASIC ROM in and out of the microprocessor address space.
                            Normally, this line is HIGH for BASIC operation. If this line is
                            programmed LOW, the BASIC ROM will disappear from the memory map and be
                            replaced by 8K bytes of RAM from $A000-$BFFF.</p>

                        <p>HIRAM (bit 1) can generally be thought of as a control line which banks
                            the 8K byte KERNAL ROM in and out of the microprocessor address space.
                            Normally, this line is HIGH for BASIC operation. If this line is
                            programmed LOW, the KERNAL ROM will disappear from the memory map and be
                            replaced by 8K bytes of RAM from $E000-$FFFF.</p>

                        <p>CHAREN (bit 2) is used only to bank the 4K byte character generator ROM
                            in or out of the microprocessor address space. From the processor point
                            of view, the character ROM occupies the same address space as the I/O
                            devices ($D000-$DFFF). When the CHAREN line is set to 1 (as is normal),
                            the I/O devices appear in the microprocessor address space, and the
                            character ROM is not accessable. When the CHAREN bit is cleared to 0, the
                            character ROM appears in the processor address space, and the I/O devices
                            are not accessable. (The microprocessor only needs to access the
                            character ROM when downloading the character set from ROM to RAM. Special
                            care is needed for this... see the section on PROGRAMMABLE CHARACTERS in
                            the GRAPHICS chapter). CHAREN can be overridden by other control lines in
                            certain memory configurations. CHAREN will have no effect on any memory
                            configuration without I/O devices. RAM will appear from $D000-$DFFF
                            instead.</p>

                        <p><strong>NOTE:</strong> In any memory map containing ROM, a WRITE (a POKE) to a ROM
                            location will store data in the RAM "under" the ROM. Writing to a ROM location stores
                            data in the "hidden" RAM. For example, this allows a hi-resolution screen to be kept
                            underneath a ROM, and be changed without having to bank the screen back into the processor
                            address space. Of course a READ of a ROM location will return the contents of the ROM,
                            not the "hidden" RAM.</p>

                        <h4>Commodore 64 Fundamental Memory Map</h4>

                        <img src="https://i.postimg.cc/fRZ59f0V/memory-map.png" alt="Memory Map">

                        <h4>I/O Breakdown</h4>

                        <table>
                            <tr>
                                <td>D000-D3FF</td>
                                <td>VIC (Video Controller</td>
                                <td>1K Bytes</td>
                            </tr>
                            <tr>
                                <td>D4000-D7FF</td>
                                <td>SID (Sound Synthesizer)</td>
                                <td>1K Bytes</td>
                            </tr>
                            <tr>
                                <td>D800-DBFF</td>
                                <td>Color RAM</td>
                                <td>1K Nybbles</td>
                            </tr>
                            <tr>
                                <td>DC00-DCFF</td>
                                <td>CIA1 (Keyboard)</td>
                                <td>256 Bytes</td>
                            </tr>
                            <tr>
                                <td>DD00-DDFF</td>
                                <td>CIA2 (Serial Bus, User Port/RS-232)</td>
                                <td>256 Bytes</td>
                            </tr>
                            <tr>
                                <td>DE00-DEFF</td>
                                <td>Open I/O slot #1 (CP/M Enable)</td>
                                <td>256 Bytes</td>
                            </tr>
                            <tr>
                                <td>DF00-DFFF</td>
                                <td>Open I/O slot #2 (Disk)</td>
                                <td>256 Bytes</td>
                            </tr>
                        </table>

                        <p>The two open I/O slots are for general purpose user I/O, special purpose
                            I/O cartridges (such as IEEE), and have been tentatively designated
                            for enabling the Z-80 cartridge (CP/M option) and for interfacing to a
                            low-cost high-speed disk system.</p>

                        <p>The system provides for "auto-start" of the program in a Commodore 64
                            Expansion Cartridge. The cartridge program is started if the first nine
                            bytes of the cartridge ROM starting at location 32768 ($8000) contain
                            specific data. The first two bytes must hold the Cold Start vector to be
                            used by the cartridge program. The next two bytes at 32770 ($8002) must
                            be the Warm Start vector used by the cartridge program. The next three
                            bytes must be the letters, CBM, with bit 7 set in each letter. The last
                            two bytes must be the digits "80" in PET ASCII.</p>

                        <h5>Commodore 64 Memory Maps</h5>

                        <p>The following table lists the various memory configurations available
                            on the COMMODORE 64, the states of the control lines which select each
                            memory map, and the intended use of each map.</p>

                        <img src="https://i.postimg.cc/j2qhq1t6/mem-map1.png" alt="Memory Map 1">
                        <br>
                        <img src="https://i.postimg.cc/hPj0HNCc/mem-map2.png" alt="Memory Map 2">
                        <br>
                        <img src="https://i.postimg.cc/t4nNgWQc/mem-map3.png" alt="Memory Map 3">
                        <br>
                        <img src="https://i.postimg.cc/pdNY5rPL/mem-map4.png" alt="Memory Map 4">
                        <br>
                        <img src="https://i.postimg.cc/LszktSsB/mem-map5.png" alt="Memory Map 5">
                        <br>
                        <img src="https://i.postimg.cc/bYLTVq9m/mem-map6.png" alt="Memory Map 6">
                        <br>
                        <img src="https://i.postimg.cc/8cym7bz2/mem-map7.png" alt="Memory Map 7">
                        <br>
                        <img src="https://i.postimg.cc/QxyqsSP5/mem-map8.png" alt="Memory Map 8">

                        <hr>

                        <h4 id="The_KERNAL">The KERNAL</h4>

                        <p>One of the problems facing programmers in the microcomputer field is
                            the question of what to do when changes are made to the operating system
                            of the computer by the company. Machine language programs which took much
                            time to develop might no longer work, forcing major revisions in the
                            program. To alleviate this problem, Commodore has developed a method of
                            protecting software writers called the KERNAL.</p>

                        <p>Essentially, the KERNAL is a standardized JUMP TABLE to the input,
                            output, and memory management routines in the operating system. The
                            locations of each routine in ROM may change as the system is upgraded.
                            But the KERNAL jump table will always be changed to match. If your
                            machine language routines only use the system ROM routines through the
                            KERNAL, it will take much less work to modify them, should that need ever
                            arise.</p>

                        <p>The KERNAL is the operating system of the Commodore 64 computer. All
                            input, output, and memory management is controlled by the KERNAL.</p>

                        <p>To simplify the machine language programs you write, and to make sure
                            that future versions of the Commodore 64 operating system don't make your
                            machine language programs obsolete, the KERNAL contains a jump table for
                            you to use. By taking advantage of the 39 input/output routines and other
                            utilities available to you from the table, not only do you save time, you
                            also make it easier to translate your programs from one Commodore
                            computer to another.</p>

                        <p>The jump table is located on the last page of memory, in read-only
                            memory (ROM).</p>

                        <p>To use the KERNAL jump table, first you set up the parameters that the
                            KERNAL routine needs to work. Then JSR (Jump to SubRoutine) to the proper
                            place in the KERNAL jump table. After performing its function, the KERNAL
                            transfers control back to your machine language program. Depending on
                            which KERNAL routine you are using, certain registers may pass parameters
                            back to your program. The particular registers for each KERNAL routine
                            may be found in the individual descriptions of the KERNAL subroutines.</p>

                        <p>A good question at this point is why use the jump table at all? Why not
                            just JSR directly to the KERNAL subroutine involved? The jump table is
                            used so that if the KERNAL or BASIC is changed, your machine language
                            programs will still work. In future operating systems the routines may
                            have their memory locations moved around to a different position in the
                            memory map... but the jump table will still work correctly!</p>

                        <hr>

                        <h4 id="KERNAL_Power-up_Activities">KERNAL Power-Up Activities</h4>

                        <ol>
                            <li>On power-up, the KERNAL first resets the stack pointer, and clears
                                decimal mode.</li>
                            <li>The KERNAL then checks for the presence of an autostart ROM cartridge
                                at location $8000 HEX (32768 decimal). If this is present, normal
                                initialization is suspended, and control is transferred to the car-
                                tridge code. If an autostart ROM is not present, normal system ini-
                                tialization continues.</li>
                            <li>Next, the KERNAL initializes all INPUT/OUTPUT devices. The serial bus
                                is initialized. Both 6526 CIA chips are set to the proper values for
                                keyboard scanning, and the 60-Hz timer is activated. The SID chip is
                                cleared. The BASIC memory map is selected and the cassette motor is
                                switched off.</li>
                            <li>Next, the KERNAL performs a RAM test, setting the top and bottom of
                                memory pointers. Also, page zero is initialized, and the tape buffer
                                is set up. The RAM TEST routine is a nondestructive test starting at location
                                $0300 and working upward. Once the test has found the first non-RAM
                                location, the top of RAM has its pointer set. The bottom of memory is
                                always set to $0800, and the screen setup is always set at $0400.</li>
                            <li>Finally, the KERNAL performs these other activities. I/O vectors are
                                set to default values. The indirect jump table in low memory is estab-
                                lished. The screen is then cleared, and all screen editor variables
                                reset. Then the indirect at $A000 is used to start BASIC.</li>
                        </ol>

                        <h5>How to Use the Kernal</h5>

                        <p>When writing machine language programs it is often convenient to use
                            the routines which are already part of the operating system for input/
                            output, access to the system clock, memory management, and other similar
                            operations. It is an unnecessary duplication of effort to write these
                            routines over and over again, so easy access to the operating system
                            helps speed machine language programming.</p>

                        <p>As mentioned before, the KERNAL is a jump table. This is just a collection of JMP
                            instructions to many operating system routines.</p>

                        <p>To use a KERNAL routine you must first make all of the preparations
                            that the routine demands. If one routine says that you must call another
                            KERNAL routine first, then that routine must be called. If the routine
                            expects you to put a number in the accumulator, then that number must be
                            there. Otherwise your routines have little chance of working the way you
                            expect them to work.</p>

                        <p>After all preparations are made, you must call the routine by means of
                            the JSR instruction. All KERNAL routines you can access are structured as
                            SUBROUTINES, and must end with an RTS instruction. When the KERNAL
                            routine has finished its task, control is returned to your program at the
                            instruction after the JSR.</p>

                        <p>Many of the KERNAL routines return error codes in the status word or
                            the accumulator if you have problems in the routine. Good programming
                            practice and the success of your machine language programs demand that
                            you handle this properly. If you ignore an error return, the rest of your
                            program might "bomb."</p>

                        <p>That's all there is to do when you're using the KERNAL. Just these
                            three simple steps:</p>

                        <ol>
                            <li>Set up</li>
                            <li>Call the routine</li>
                            <li>Error handling</li>
                        </ol>

                        <p>The following conventions are used in describing the KERNAL routines:</p>

                        <ul>
                            <li><strong>FUNCTION NAME:</strong> Name of the KERNAL routine.</li>
                            <li><strong>CALL ADDRESS:</strong> This is the call address of the KERNAL routine, given in
                                hexadecimal.</li>
                            <li><strong>COMMUNICATION REGISTERS:</strong> Registers listed under this heading are used
                                to pass parameters to and from the KERNAL routines.
                            </li>
                            <li><strong>PREPARATORY ROUTINES:</strong> Certain KERNAL routines require that data be set
                                up before they can operate. The routines needed are listed here.</li>
                            <li><strong>ERROR RETURNS:</strong> A return from a KERNAL routine with the CARRY set
                                indicates that an error was encountered in processing. The accumulator
                                will contain the number of the error.</li>
                            <li><strong>STACK REQUIREMENTS:</strong> This is the actual number of stack bytes used by
                                the KERNAL routine.</li>
                            <li><strong>REGISTERS AFFECTED:</strong> All registers used by the KERNAL routine are listed
                                here.</li>
                            <li><strong>DESCRIPTION:</strong> A short tutorial on the function of the KERNAL routine is
                                given here.</li>
                        </ul>

                        <p>The list of the KERNAL routines follows.</p>

                        <hr>

                        <h4 id="KERNAL_Routines">User Callable KERNAL Routines</h4>

                        <table>
                            <tr>
                                <th rowspan="2">Name</th>
                                <th colspan="2">Decimal</th>
                                <th rowspan="2">Function</th>
                            </tr>
                            <tr>
                                <th>Hex</th>
                                <th>Decimal</th>
                            </tr>
                            <tr>
                                <td>ACPTR</td>
                                <td>$FFA5</td>
                                <td>65445</td>
                                <td>Input byte from serial port.</td>
                            </tr>
                            <tr>
                                <td>CHKIN</td>
                                <td>$FFC6</td>
                                <td>65478</td>
                                <td>Open channel for input</td>
                            </tr>
                            <tr>
                                <td>CHKOUT</td>
                                <td>$FFC9</td>
                                <td>65481</td>
                                <td>Open channel for output</td>
                            </tr>
                            <tr>
                                <td>CHRIN</td>
                                <td>$FFCF</td>
                                <td>65487</td>
                                <td>Input character from channel</td>
                            </tr>
                            <tr>
                                <td>CHROUT</td>
                                <td>$FFD2</td>
                                <td>65490</td>
                                <td>Output character to channel</td>
                            </tr>
                            <tr>
                                <td>CIOUT</td>
                                <td>$FFA8</td>
                                <td>65448</td>
                                <td>Output byte to serial port</td>
                            </tr>
                            <tr>
                                <td>CINT</td>
                                <td>$FF81</td>
                                <td>65409</td>
                                <td>Initialize screen editor</td>
                            </tr>
                            <tr>
                                <td>CLALL</td>
                                <td>$FFE7</td>
                                <td>65511</td>
                                <td>Close all channels and files</td>
                            </tr>
                            <tr>
                                <td>CLOSE</td>
                                <td>$FFC3</td>
                                <td>65475</td>
                                <td>Close a specified logical file</td>
                            </tr>
                            <tr>
                                <td>CLRCHN</td>
                                <td>$FFCC</td>
                                <td>65484</td>
                                <td>Close input and output channels</td>
                            </tr>
                            <tr>
                                <td>GETIN</td>
                                <td>$FFE4</td>
                                <td>65508</td>
                                <td>Get character from keyboard queue (keyboard buffer)</td>
                            </tr>
                            <tr>
                                <td>IOBASE</td>
                                <td>$FFF3</td>
                                <td>65523</td>
                                <td>Returns base address of I/O devices</td>
                            </tr>
                            <tr>
                                <td>IOINIT</td>
                                <td>$FF84</td>
                                <td>65412</td>
                                <td>Initialize input/output</td>
                            </tr>
                            <tr>
                                <td>LISTEN</td>
                                <td>$FFB1</td>
                                <td>65457</td>
                                <td>Command devices on the serial bus to LISTEN</td>
                            </tr>
                            <tr>
                                <td>LOAD</td>
                                <td>$FFD5</td>
                                <td>65493</td>
                                <td>Load RAM from a device</td>
                            </tr>
                            <tr>
                                <td>MEMBOT</td>
                                <td>$FF9C</td>
                                <td>65436</td>
                                <td>Read/set the bottom of memory</td>
                            </tr>
                            <tr>
                                <td>MEMTOP</td>
                                <td>$FF99</td>
                                <td>65433</td>
                                <td>Read/set the top of memory</td>
                            </tr>
                            <tr>
                                <td>OPEN</td>
                                <td>$FFC0</td>
                                <td>65472</td>
                                <td>Open a logical file</td>
                            </tr>
                            <tr>
                                <td>PLOT</td>
                                <td>$FFF0</td>
                                <td>65520</td>
                                <td>Read/set X, Y cursor position</td>
                            </tr>
                            <tr>
                                <td>RAMTAS</td>
                                <td>$FF87</td>
                                <td>65415</td>
                                <td>Initialize RAM, allocate tape buffer, set screen $0400</td>
                            </tr>
                            <tr>
                                <td>RDTIM</td>
                                <td>$FFDE</td>
                                <td>65502</td>
                                <td>Read real time clock</td>
                            </tr>
                            <tr>
                                <td>READST</td>
                                <td>$FFB7</td>
                                <td>65463</td>
                                <td>Read I/O status word</td>
                            </tr>
                            <tr>
                                <td>RESTOR</td>
                                <td>$FF8A</td>
                                <td>65418</td>
                                <td>Restore default I/O vectors</td>
                            </tr>
                            <tr>
                                <td>SAVE</td>
                                <td>$FFD8</td>
                                <td>65496</td>
                                <td>Save RAM to device</td>
                            </tr>
                            <tr>
                                <td>SCNKEY</td>
                                <td>$FF9F</td>
                                <td>65439</td>
                                <td>Scan keyboard</td>
                            </tr>
                            <tr>
                                <td>SCREEN</td>
                                <td>$FFED</td>
                                <td>65517</td>
                                <td>Return X, Y organization of screen</td>
                            </tr>
                            <tr>
                                <td>SECOND</td>
                                <td>$FF93</td>
                                <td>65427</td>
                                <td>Send secondary address after LISTEN</td>
                            </tr>
                            <tr>
                                <td>SETLFS</td>
                                <td>$FFBA</td>
                                <td>65466</td>
                                <td>Set logical, first, and second addresses</td>
                            </tr>
                            <tr>
                                <td>SETMSG</td>
                                <td>$FF90</td>
                                <td>65424</td>
                                <td>Control KERNAL messages</td>
                            </tr>
                            <tr>
                                <td>SETNAM</td>
                                <td>$FFBA</td>
                                <td>65469</td>
                                <td>Set file name</td>
                            </tr>
                            <tr>
                                <td>SETTIM</td>
                                <td>$FFDB</td>
                                <td>65499</td>
                                <td>Set real time clock</td>
                            </tr>
                            <tr>
                                <td>SETTMO</td>
                                <td>$FFA2</td>
                                <td>65442</td>
                                <td>Set timeout on serial bus</td>
                            </tr>
                            <tr>
                                <td>STOP</td>
                                <td>$FFE1</td>
                                <td>65505</td>
                                <td>Scan stop key</td>
                            </tr>
                            <tr>
                                <td>TALK</td>
                                <td>$FFB4</td>
                                <td>65460</td>
                                <td>Command serial bus device to TALK</td>
                            </tr>
                            <tr>
                                <td>TKSA</td>
                                <td>$FF96</td>
                                <td>65430</td>
                                <td>Send secondary address after TALK</td>
                            </tr>
                            <tr>
                                <td>UDTIM</td>
                                <td>$FFEA</td>
                                <td>65514</td>
                                <td>Increment real time clock</td>
                            </tr>
                            <tr>
                                <td>UNLSN</td>
                                <td>$FFAE</td>
                                <td>65454</td>
                                <td>Command serial bus to UNLISTEN</td>
                            </tr>
                            <tr>
                                <td>UNTLK</td>
                                <td>$FFAB</td>
                                <td>65451</td>
                                <td>Command serial bus to UNTALK</td>
                            </tr>
                            <tr>
                                <td>VECTOR</td>
                                <td>$FF8D</td>
                                <td>65421</td>
                                <td>Sead/set vectored I/O</td>
                            </tr>
                        </table>

                        <hr>

                        <h5 id="ACPTR">ACPTR</h5>

                        <p><strong>Purpose: </strong> Get data from the serial bus
                            <br><strong>Call address: </strong> $FFA5 (hex) 65445 (decimal)
                            <br><strong>Communication registers: </strong> A
                            <br><strong>Preparatory routines: </strong> TALK, TKSA
                            <br><strong>Error returns: </strong>See READST
                            <br><strong>Stack requirements: </strong>13
                            <br><strong>Registers affected: </strong>A, X</p>

                        <p><strong>Description: </strong>This is the routine to use when you want to get informa-
                            tion from a device on the serial bus, like a disk. This routine gets a
                            byte of data off the serial bus using full handshaking. The data is
                            returned in the accumulator. To prepare for this routine the TALK routine
                            must be called first to command the device on the serial bus to send data
                            through the bus. If the input device needs a secondary command, it must
                            be sent by using the TKSA KERNAL routine before calling this routine.
                            Errors are returned in the status word. The READST routine is used to
                            read the status word.</p>

                        <p><strong>How to Use:</strong></p>

                        <ol>
                            <li>Command a device on the serial bus to prepare to send data to
                                the Commodore 64. (Use the TALK and TKSA KERNAL routines.)</li>
                            <li>Call this routine (using JSR).</li>
                            <li>Store or otherwise use the data.</li>
                        </ol>

                        <p class="example">Example:</p>

                        <blockquote>
                            <code>
                                ;GET A BYTE FROM THE BUS
                                <br>JSR ACPTR
                                <br>STA DATA
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="CHKIN">CHKIN</h5>

                        <p><strong>Purpose:</strong> Open a channel for input
                            <br><strong>Call address:</strong> $FFC6 (hex) 65478 (decimal)
                            <br><strong>Communication registers:</strong> X
                            <br><strong>Preparatory routines:</strong> (OPEN)
                            <br><strong>Error returns:</strong> None
                            <br><strong>Stack requirements:</strong> None
                            <br><strong>Registers affected:</strong>A, X</p>

                        <p><strong>Description:</strong>Any logical file that has already been opened by the
                            KERNAL OPEN routine can be defined as an input channel by this routine.
                            Naturally, the device on the channel must be an input device. Otherwise
                            an error will occur, and the routine will abort.</p>

                        <p>If you are getting data from anywhere other than the keyboard, this
                            routine must be called before using either the CHRIN or the GETIN KERNAL
                            routines for data input. If you want to use the input from the keyboard,
                            and no other input channels are opened, then the calls to this routine,
                            and to the OPEN routine are not needed.</p>

                        <p>When this routine is used with a device on the serial bus, it auto-
                            matically sends the talk address (and the secondary address if one was
                            specified by the OPEN routine) over the bus.</p>

                        <p><strong>How to Use:</strong></p>

                        <ol>
                            <li>OPEN the logical file (if necessary; see description above)</li>
                            <li>Load the X register with number of the logical file to be used.</li>
                            <li>Call this routine (using a JSR command)</li>
                        </ol>

                        <p><strong>Possible errors are:</strong></p>

                        <blockquote>
                            <code>
                                #3: File not open
                                <br>#5: Device not present
                                <br>#6: File not an input file
                            </code>
                        </blockquote>

                        <p class="example">Example:</p>

                        <blockquote>
                            <code>
                                ;PREPARE FOR INPUT FROM LOGICAL FILE 2
                                <br>LDX #2
                                <br>JSR CHKIN
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="CHKOUT">CHKOUT</h5>

                        <p><strong>Purpose:</strong> Open a channel for output.
                            <br><strong>Call address:</strong> $FFC9 (hex) 65481 (decimal)
                            <br><strong>Communication registers:</strong> X
                            <br><strong>Preparatory routines:</strong> (OPEN)
                            <br><strong>Error returns:</strong> 0, 3, 5, 7 (see READST)
                            <br><strong>Stack requirements:</strong> 4+
                            <br><strong>Registers affected:</strong> A, X</p>

                        <p><strong>Description:</strong> Any logical file number that has been created by the
                            KERNAL routine OPEN can be defined as an output channel. Of course, the
                            device you intend opening a channel to must be an output device.
                            Otherwise an error will occur, and the routine will be aborted.</p>

                        <p>This routine must be called before any data is sent to any output
                            device unless you want to use the Commodore 64 screen as your output
                            device. If screen output is desired, and there are no other output chan-
                            nels already defined, then calls to this routine, and to the OPEN routine
                            are not needed.</p>

                        <p> When used to open a channel to a device on the serial bus, this routine
                            will automatically send the LISTEN address specified by the OPEN routine
                            (and a secondary address if there was one).</p>

                        <p><strong>How to Use:</strong></p>

                        <p><strong><em>REMEMBER:</em></strong> This routine is NOT NEEDED to send data to the
                            screen.</p>

                        <ol>
                            <li>Use the KERNAL OPEN routine to specify a logical file number, a LISTEN address, and
                                a secondary address (if needed).</li>
                            <li>Load the X register with the logical file number used in the open statement.</li>
                            <li>Call this routine (by using the JSR intstruction).</li>
                        </ol>

                        <p class="example">Example:</p>

                        <pre>
LDX #3      ;DEFINE LGICAL FILE 3 AS AN OUTPUT CHANNEL
JSR CHKOUT
                        </pre>

                        <p><strong>Possible errors are:</strong></p>

                        <blockquote>
                            <code>
                                #3: File not open
                                <br>#5: Device not present
                                <br>#7: Not an output file
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="CHRIN">CHRIN</h5>

                        <p><strong>Purpose:</strong> Get a character from the input channel
                            <br><strong>Call address:</strong> $FFCF (hex) 65487 (decimal)
                            <br><strong>Communication registers:</strong> A
                            <br><strong>Preparatory routines:</strong> (OPEN, CHKIN)
                            <br><strong>Error returns:</strong> 0 (See READST)
                            <br><strong>Stack requirements:</strong> 7+
                            <br><strong>Registers affected:</strong> A, X</p>

                        <p><strong>Description:</strong> This routine gets a byte of data from a channel already
                            set up as the input channel by the KERNAL routine CHKIN. If the CHKIN has
                            NOT been used to define another input channel, then all your data is
                            expected from the keyboard. The data byte is returned in the accumulator.
                            The channel remains open after the call.</p>

                        <p>Input from the keyboard is handled in a special way. First, the cursor
                            is turned on, and blinks until a carriage return is typed on the
                            keyboard. All characters on the line (up to 88 characters) are stored in
                            the BASIC input buffer. These characters can be retrieved one at a time
                            by calling this routine once for each character. When the carriage return
                            is retrieved, the entire line has been processed. The next time this
                            routine is called, the whole process begins again, i.e., by flashing the
                            cursor.</p>

                        <p><strong>How to Use:</strong></p>

                        <p><strong><em>From the keyboard:</em></strong></p>

                        <ol>
                            <li>Retrieve a byte of data by calling this routine.</li>
                            <li>Store the data byte.</li>
                            <li>Check if it is the last data byte (is it a CR?)</li>
                            <li>Go to step 1.</li>
                        </ol>

                        <p class="example">Example:</p>

                        <pre>
    LDY $#00        ;PREPARE THE Y REGISTER TO STORE THE DATA
RD  JSR CHRIN
    STA DATA,Y      ;STORE THE YTH DATA BYTE IN THE YTH LOCATION IN THE DATA AREA.
    INY
    CMP #CR         ;IS IT A CARRIAGE RETURN?
    BNE RD          ;NO, GET ANOTHER DATA BYTE
                        </pre>

                        <p class="example">Example:</p>

                        <blockquote>
                            <code>
                                JSR CHRIN
                                <br>STA DATA
                            </code>
                        </blockquote>

                        <p><strong><em>From other devices:</em></strong></p>

                        <ol>
                            <li>Use the KERNAL OPEN and CHKIN routines.</li>
                            <li>Call this routine (using a JSR instruction)</li>
                            <li>Store the data.</li>
                        </ol>

                        <p class="example">Example:</p>

                        <blockquote>
                            <code>
                                JSR CHRIN
                                <br>STA DATA
                            </code>
                        </blockquote>

                        <hr>

                        <h5 id="CHROUT">CHROUT</h5>

                        <p><strong>Purpose:</strong> Output a character
                            <br><strong>Call address:</strong> $FFD2 (hex) 65490 (decimal)
                            <br><strong>Communication registers:</strong> A
                            <br><strong>Preparatory routines:</strong> (CHKOUT, OPEN)
                            <br><strong>Error returns:</strong> 0 (See READST)
                            <br><strong>Stack requirements:</strong> 8+
                            <br><strong>Registers affected:</strong> A</p>

                        <p><strong>Description:</strong> This routine outputs a character to an already opened
                            channel. Use the KERNAL OPEN and CHKOUT routines to set up the output
                            channel before calling this routine, If this call is omitted, data is
                            sent to the default output device (number 3, the screen). The data byte
                            to be output is loaded into the accumulator, and this routine is called.
                            The data is then sent to the specified output device. The channel is left
                            open after the call.</p>

                        <p><strong>NOTE:</strong> Care must be taken when using this routine to send data to a specific
                            serial device since data will be sent to all open output channels on the bus. Unless this is
                            desired, all open output channels on the serial bus other than the intended destination
                            channel must be closed by a call to the KERNAL CLRCHN routine.</p>

                        <p><strong>How to Use:</strong></p>

                        <ol>
                            <li>Use the CHKOUT KERNAL routine if needed, (see description above).</li>
                            <li>Load the data to be output into the accumulator.</li>
                            <li>Call this routine.</li>
                        </ol>

                        <p class="example">Example:</p>

                        <pre>
    ;DUPLICATE THE BASIC INSTRUCTION CMD4, "A";
    LDS #4          ;LOGICAL FILE #4
    JSR CHKOUT      ;OPEN CHANNEL OUT
    LDA #'A
    JSR CHROUT      ;SEND CHARACTER
                        </pre>

                        <hr>

                        <h5 id="CIOUT">CIOUT</h5>

                        <p><strong>Purpose:</strong> Transmit a byte over the serial bus
                            <br><strong>Call address:</strong> $FFA8 (hex) 65448 (decimal)
                            <br><strong>Communication registers:</strong> A
                            <br><strong>Preparatory routines:</strong> LISTEN, [SECOND]
                            <br><strong>Error returns:</strong> See READST
                            <br><strong>Stack requirements:</strong> 5
                            <br><strong>Registers affected:</strong> None</p>

                        <p><strong>Description:</strong> This routine is used to send information to devices on the
                            serial bus. A call to this routine will put a data byte onto the serial
                            bus using full serial handshaking. Before this routine is called, the
                            LISTEN KERNAL routine must be used to command a device on the serial bus
                            to get ready to receive data. (If a device needs a secondary address, it
                            must also be sent by using the SECOND KERNAL routine.) The accumulator is
                            loaded with a byte to handshake as data on the serial bus. A device must
                            be listening or the status word will return a timeout. This routine
                            always buffers one character. (The routine holds the previous character
                            to be sent back.) So when a call to the KERNAL UNLSN routine is made to
                            end the data transmission, the buffered character is sent with an End Or
                            Identify (EOI) set. Then the UNLSN command is sent to the device.</p>

                        <p><strong>How to Use:</strong></p>

                        <ol>
                            <li>Use the LISTEN KERNAL routine (and the SECOND routine if needed).</li>
                            <li>Load the accumulator with a byte of data.</li>
                            <li>Call this routine to send the data byte.</li>
                        </ol>

                        <p class="example">Example:</p>

                        <pre>
    LDA #'A     ;SEND AN X TO THE SERIAL BUS
    JSR CIOUT
                        </pre>

                        <hr>

                        <h5 id="CINT">CINT</h5>

                        <p><strong>Purpose:</strong> Initialize screen editor & 6567 video chip.
                            <br><strong>Call address:</strong> $FF81 (hex) 65409 (decimal)
                            <br><strong>Communication registers:</strong> None
                            <br><strong>Preparatory routines:</strong> None
                            <br><strong>Error returns:</strong> None
                            <br><strong>Stack requirements:</strong> 4
                            <br><strong>Registers affected:</strong> A, X, Y</p>

                        <p><strong>Description:</strong> This routine serts up the 6567 video controller chip in the
                            Commodore 64 for normal operation. The KERNAL screen editor is also initialized. This
                            routine should be called by a Commodore 64 program cartridge.</p>

                        <p><strong>How to Use:</strong></p>

                        <ol>
                            <li>Call this routine.</li>
                        </ol>

                        <p class="example">Example:</p>

                        <pre>
    JSR CINT
    JMP RUN     ;BEGIN EXECUTION
    
                        </pre>

                        <hr>
                    </section>
                </main>
            </div>
        </div>
        <footer>
            <p>All information contained above was obtained from
                <a href="http://www.zimmers.net/cbmpics/cbm/c64/c64prg.txt">the text version</a> and
                <a href="http://www.classiccmp.org/cini/pdf/Commodore/C64%20Programmer's%20Reference%20Guide.pdf">the
                    PDF copy</a> of the
                <em>Commodore 64 Programmer's Reference Guide</em>.
            </p>
        </footer>
    </div>
</body>

</html>